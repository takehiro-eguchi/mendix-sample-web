function _mergeNamespaces(n, m) {
	m.forEach(function (e) {
		e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
			if (k !== 'default' && !(k in n)) {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	});
	return Object.freeze(n);
}

var commonjsGlobal$1 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function getDefaultExportFromCjs$1(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}

var isMergeableObject = function(value) {
  return /* @__PURE__ */ function(value2) {
    return !!value2 && "object" == typeof value2;
  }(value) && !function(value2) {
    var stringValue = Object.prototype.toString.call(value2);
    return "[object RegExp]" === stringValue || "[object Date]" === stringValue || function(value3) {
      return value3.$$typeof === REACT_ELEMENT_TYPE;
    }(value2);
  }(value);
};
var REACT_ELEMENT_TYPE = "function" == typeof Symbol && Symbol.for ? Symbol.for("react.element") : 60103;
function cloneUnlessOtherwiseSpecified(value, options) {
  return false !== options.clone && options.isMergeableObject(value) ? deepmerge((val = value, Array.isArray(val) ? [] : {}), value, options) : value;
  var val;
}
function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function(element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}
function getKeys(target) {
  return Object.keys(target).concat(function(target2) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target2).filter(function(symbol) {
      return Object.propertyIsEnumerable.call(target2, symbol);
    }) : [];
  }(target));
}
function propertyIsOnObject(object, property) {
  try {
    return property in object;
  } catch (_) {
    return false;
  }
}
function mergeObject(target, source, options) {
  var destination = {};
  return options.isMergeableObject(target) && getKeys(target).forEach(function(key) {
    destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
  }), getKeys(source).forEach(function(key) {
    (function(target2, key2) {
      return propertyIsOnObject(target2, key2) && !(Object.hasOwnProperty.call(target2, key2) && Object.propertyIsEnumerable.call(target2, key2));
    })(target, key) || (propertyIsOnObject(target, key) && options.isMergeableObject(source[key]) ? destination[key] = function(key2, options2) {
      if (!options2.customMerge)
        return deepmerge;
      var customMerge = options2.customMerge(key2);
      return "function" == typeof customMerge ? customMerge : deepmerge;
    }(key, options)(target[key], source[key], options) : destination[key] = cloneUnlessOtherwiseSpecified(source[key], options));
  }), destination;
}
function deepmerge(target, source, options) {
  (options = options || {}).arrayMerge = options.arrayMerge || defaultArrayMerge, options.isMergeableObject = options.isMergeableObject || isMergeableObject, options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var sourceIsArray = Array.isArray(source);
  return sourceIsArray === Array.isArray(target) ? sourceIsArray ? options.arrayMerge(target, source, options) : mergeObject(target, source, options) : cloneUnlessOtherwiseSpecified(source, options);
}
deepmerge.all = function(array, options) {
  if (!Array.isArray(array))
    throw new Error("first argument should be an array");
  return array.reduce(function(prev, next) {
    return deepmerge(prev, next, options);
  }, {});
};
var deepmerge$1 = getDefaultExportFromCjs$1(deepmerge);

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getDefaultExportFromNamespaceIfPresent (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var react$1 = {exports: {}};

var react_development$2 = {exports: {}};

var react_development = react_development$2.exports;

(function (module, exports) {
	"use strict";
	/**
	 * @license React
	 * react.development.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	if (true) {
	  (function() {
	    "use strict";
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
	      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
	    }
	    var ReactVersion = "18.2.0";
	    var REACT_ELEMENT_TYPE = Symbol.for("react.element");
	    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
	    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
	    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
	    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
	    var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
	    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
	    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
	    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
	    var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
	    var REACT_MEMO_TYPE = Symbol.for("react.memo");
	    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
	    var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
	    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
	    var FAUX_ITERATOR_SYMBOL = "@@iterator";
	    function getIteratorFn(maybeIterable) {
	      if (maybeIterable === null || typeof maybeIterable !== "object") {
	        return null;
	      }
	      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
	      if (typeof maybeIterator === "function") {
	        return maybeIterator;
	      }
	      return null;
	    }
	    var ReactCurrentDispatcher = {
	      /**
	       * @internal
	       * @type {ReactComponent}
	       */
	      current: null
	    };
	    var ReactCurrentBatchConfig = {
	      transition: null
	    };
	    var ReactCurrentActQueue = {
	      current: null,
	      // Used to reproduce behavior of `batchedUpdates` in legacy mode.
	      isBatchingLegacy: false,
	      didScheduleLegacyUpdate: false
	    };
	    var ReactCurrentOwner = {
	      /**
	       * @internal
	       * @type {ReactComponent}
	       */
	      current: null
	    };
	    var ReactDebugCurrentFrame = {};
	    var currentExtraStackFrame = null;
	    function setExtraStackFrame(stack) {
	      {
	        currentExtraStackFrame = stack;
	      }
	    }
	    {
	      ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
	        {
	          currentExtraStackFrame = stack;
	        }
	      };
	      ReactDebugCurrentFrame.getCurrentStack = null;
	      ReactDebugCurrentFrame.getStackAddendum = function() {
	        var stack = "";
	        if (currentExtraStackFrame) {
	          stack += currentExtraStackFrame;
	        }
	        var impl = ReactDebugCurrentFrame.getCurrentStack;
	        if (impl) {
	          stack += impl() || "";
	        }
	        return stack;
	      };
	    }
	    var enableScopeAPI = false;
	    var enableCacheElement = false;
	    var enableTransitionTracing = false;
	    var enableLegacyHidden = false;
	    var enableDebugTracing = false;
	    var ReactSharedInternals = {
	      ReactCurrentDispatcher,
	      ReactCurrentBatchConfig,
	      ReactCurrentOwner
	    };
	    {
	      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
	      ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
	    }
	    function warn(format) {
	      {
	        {
	          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            args[_key - 1] = arguments[_key];
	          }
	          printWarning("warn", format, args);
	        }
	      }
	    }
	    function error(format) {
	      {
	        {
	          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	            args[_key2 - 1] = arguments[_key2];
	          }
	          printWarning("error", format, args);
	        }
	      }
	    }
	    function printWarning(level, format, args) {
	      {
	        var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
	        var stack = ReactDebugCurrentFrame2.getStackAddendum();
	        if (stack !== "") {
	          format += "%s";
	          args = args.concat([stack]);
	        }
	        var argsWithFormat = args.map(function(item) {
	          return String(item);
	        });
	        argsWithFormat.unshift("Warning: " + format);
	        Function.prototype.apply.call(console[level], console, argsWithFormat);
	      }
	    }
	    var didWarnStateUpdateForUnmountedComponent = {};
	    function warnNoop(publicInstance, callerName) {
	      {
	        var _constructor = publicInstance.constructor;
	        var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
	        var warningKey = componentName + "." + callerName;
	        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
	          return;
	        }
	        error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
	        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
	      }
	    }
	    var ReactNoopUpdateQueue = {
	      /**
	       * Checks whether or not this composite component is mounted.
	       * @param {ReactClass} publicInstance The instance we want to test.
	       * @return {boolean} True if mounted, false otherwise.
	       * @protected
	       * @final
	       */
	      isMounted: function(publicInstance) {
	        return false;
	      },
	      /**
	       * Forces an update. This should only be invoked when it is known with
	       * certainty that we are **not** in a DOM transaction.
	       *
	       * You may want to call this when you know that some deeper aspect of the
	       * component's state has changed but `setState` was not called.
	       *
	       * This will not invoke `shouldComponentUpdate`, but it will invoke
	       * `componentWillUpdate` and `componentDidUpdate`.
	       *
	       * @param {ReactClass} publicInstance The instance that should rerender.
	       * @param {?function} callback Called after component is updated.
	       * @param {?string} callerName name of the calling function in the public API.
	       * @internal
	       */
	      enqueueForceUpdate: function(publicInstance, callback, callerName) {
	        warnNoop(publicInstance, "forceUpdate");
	      },
	      /**
	       * Replaces all of the state. Always use this or `setState` to mutate state.
	       * You should treat `this.state` as immutable.
	       *
	       * There is no guarantee that `this.state` will be immediately updated, so
	       * accessing `this.state` after calling this method may return the old value.
	       *
	       * @param {ReactClass} publicInstance The instance that should rerender.
	       * @param {object} completeState Next state.
	       * @param {?function} callback Called after component is updated.
	       * @param {?string} callerName name of the calling function in the public API.
	       * @internal
	       */
	      enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
	        warnNoop(publicInstance, "replaceState");
	      },
	      /**
	       * Sets a subset of the state. This only exists because _pendingState is
	       * internal. This provides a merging strategy that is not available to deep
	       * properties which is confusing. TODO: Expose pendingState or don't use it
	       * during the merge.
	       *
	       * @param {ReactClass} publicInstance The instance that should rerender.
	       * @param {object} partialState Next partial state to be merged with state.
	       * @param {?function} callback Called after component is updated.
	       * @param {?string} Name of the calling function in the public API.
	       * @internal
	       */
	      enqueueSetState: function(publicInstance, partialState, callback, callerName) {
	        warnNoop(publicInstance, "setState");
	      }
	    };
	    var assign = Object.assign;
	    var emptyObject = {};
	    {
	      Object.freeze(emptyObject);
	    }
	    function Component(props, context, updater) {
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	    }
	    Component.prototype.isReactComponent = {};
	    Component.prototype.setState = function(partialState, callback) {
	      if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
	        throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
	      }
	      this.updater.enqueueSetState(this, partialState, callback, "setState");
	    };
	    Component.prototype.forceUpdate = function(callback) {
	      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
	    };
	    {
	      var deprecatedAPIs = {
	        isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
	        replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
	      };
	      var defineDeprecationWarning = function(methodName, info) {
	        Object.defineProperty(Component.prototype, methodName, {
	          get: function() {
	            warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
	            return void 0;
	          }
	        });
	      };
	      for (var fnName in deprecatedAPIs) {
	        if (deprecatedAPIs.hasOwnProperty(fnName)) {
	          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	        }
	      }
	    }
	    function ComponentDummy() {
	    }
	    ComponentDummy.prototype = Component.prototype;
	    function PureComponent(props, context, updater) {
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	    }
	    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
	    pureComponentPrototype.constructor = PureComponent;
	    assign(pureComponentPrototype, Component.prototype);
	    pureComponentPrototype.isPureReactComponent = true;
	    function createRef() {
	      var refObject = {
	        current: null
	      };
	      {
	        Object.seal(refObject);
	      }
	      return refObject;
	    }
	    var isArrayImpl = Array.isArray;
	    function isArray(a) {
	      return isArrayImpl(a);
	    }
	    function typeName(value) {
	      {
	        var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
	        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
	        return type;
	      }
	    }
	    function willCoercionThrow(value) {
	      {
	        try {
	          testStringCoercion(value);
	          return false;
	        } catch (e) {
	          return true;
	        }
	      }
	    }
	    function testStringCoercion(value) {
	      return "" + value;
	    }
	    function checkKeyStringCoercion(value) {
	      {
	        if (willCoercionThrow(value)) {
	          error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
	          return testStringCoercion(value);
	        }
	      }
	    }
	    function getWrappedName(outerType, innerType, wrapperName) {
	      var displayName = outerType.displayName;
	      if (displayName) {
	        return displayName;
	      }
	      var functionName = innerType.displayName || innerType.name || "";
	      return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
	    }
	    function getContextName(type) {
	      return type.displayName || "Context";
	    }
	    function getComponentNameFromType(type) {
	      if (type == null) {
	        return null;
	      }
	      {
	        if (typeof type.tag === "number") {
	          error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
	        }
	      }
	      if (typeof type === "function") {
	        return type.displayName || type.name || null;
	      }
	      if (typeof type === "string") {
	        return type;
	      }
	      switch (type) {
	        case REACT_FRAGMENT_TYPE:
	          return "Fragment";
	        case REACT_PORTAL_TYPE:
	          return "Portal";
	        case REACT_PROFILER_TYPE:
	          return "Profiler";
	        case REACT_STRICT_MODE_TYPE:
	          return "StrictMode";
	        case REACT_SUSPENSE_TYPE:
	          return "Suspense";
	        case REACT_SUSPENSE_LIST_TYPE:
	          return "SuspenseList";
	      }
	      if (typeof type === "object") {
	        switch (type.$$typeof) {
	          case REACT_CONTEXT_TYPE:
	            var context = type;
	            return getContextName(context) + ".Consumer";
	          case REACT_PROVIDER_TYPE:
	            var provider = type;
	            return getContextName(provider._context) + ".Provider";
	          case REACT_FORWARD_REF_TYPE:
	            return getWrappedName(type, type.render, "ForwardRef");
	          case REACT_MEMO_TYPE:
	            var outerName = type.displayName || null;
	            if (outerName !== null) {
	              return outerName;
	            }
	            return getComponentNameFromType(type.type) || "Memo";
	          case REACT_LAZY_TYPE: {
	            var lazyComponent = type;
	            var payload = lazyComponent._payload;
	            var init = lazyComponent._init;
	            try {
	              return getComponentNameFromType(init(payload));
	            } catch (x) {
	              return null;
	            }
	          }
	        }
	      }
	      return null;
	    }
	    var hasOwnProperty = Object.prototype.hasOwnProperty;
	    var RESERVED_PROPS = {
	      key: true,
	      ref: true,
	      __self: true,
	      __source: true
	    };
	    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
	    {
	      didWarnAboutStringRefs = {};
	    }
	    function hasValidRef(config) {
	      {
	        if (hasOwnProperty.call(config, "ref")) {
	          var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
	          if (getter && getter.isReactWarning) {
	            return false;
	          }
	        }
	      }
	      return config.ref !== void 0;
	    }
	    function hasValidKey(config) {
	      {
	        if (hasOwnProperty.call(config, "key")) {
	          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
	          if (getter && getter.isReactWarning) {
	            return false;
	          }
	        }
	      }
	      return config.key !== void 0;
	    }
	    function defineKeyPropWarningGetter(props, displayName) {
	      var warnAboutAccessingKey = function() {
	        {
	          if (!specialPropKeyWarningShown) {
	            specialPropKeyWarningShown = true;
	            error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
	          }
	        }
	      };
	      warnAboutAccessingKey.isReactWarning = true;
	      Object.defineProperty(props, "key", {
	        get: warnAboutAccessingKey,
	        configurable: true
	      });
	    }
	    function defineRefPropWarningGetter(props, displayName) {
	      var warnAboutAccessingRef = function() {
	        {
	          if (!specialPropRefWarningShown) {
	            specialPropRefWarningShown = true;
	            error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
	          }
	        }
	      };
	      warnAboutAccessingRef.isReactWarning = true;
	      Object.defineProperty(props, "ref", {
	        get: warnAboutAccessingRef,
	        configurable: true
	      });
	    }
	    function warnIfStringRefCannotBeAutoConverted(config) {
	      {
	        if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
	          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
	          if (!didWarnAboutStringRefs[componentName]) {
	            error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
	            didWarnAboutStringRefs[componentName] = true;
	          }
	        }
	      }
	    }
	    var ReactElement = function(type, key, ref, self, source, owner, props) {
	      var element = {
	        // This tag allows us to uniquely identify this as a React Element
	        $$typeof: REACT_ELEMENT_TYPE,
	        // Built-in properties that belong on the element
	        type,
	        key,
	        ref,
	        props,
	        // Record the component responsible for creating this element.
	        _owner: owner
	      };
	      {
	        element._store = {};
	        Object.defineProperty(element._store, "validated", {
	          configurable: false,
	          enumerable: false,
	          writable: true,
	          value: false
	        });
	        Object.defineProperty(element, "_self", {
	          configurable: false,
	          enumerable: false,
	          writable: false,
	          value: self
	        });
	        Object.defineProperty(element, "_source", {
	          configurable: false,
	          enumerable: false,
	          writable: false,
	          value: source
	        });
	        if (Object.freeze) {
	          Object.freeze(element.props);
	          Object.freeze(element);
	        }
	      }
	      return element;
	    };
	    function createElement(type, config, children) {
	      var propName;
	      var props = {};
	      var key = null;
	      var ref = null;
	      var self = null;
	      var source = null;
	      if (config != null) {
	        if (hasValidRef(config)) {
	          ref = config.ref;
	          {
	            warnIfStringRefCannotBeAutoConverted(config);
	          }
	        }
	        if (hasValidKey(config)) {
	          {
	            checkKeyStringCoercion(config.key);
	          }
	          key = "" + config.key;
	        }
	        self = config.__self === void 0 ? null : config.__self;
	        source = config.__source === void 0 ? null : config.__source;
	        for (propName in config) {
	          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	            props[propName] = config[propName];
	          }
	        }
	      }
	      var childrenLength = arguments.length - 2;
	      if (childrenLength === 1) {
	        props.children = children;
	      } else if (childrenLength > 1) {
	        var childArray = Array(childrenLength);
	        for (var i = 0; i < childrenLength; i++) {
	          childArray[i] = arguments[i + 2];
	        }
	        {
	          if (Object.freeze) {
	            Object.freeze(childArray);
	          }
	        }
	        props.children = childArray;
	      }
	      if (type && type.defaultProps) {
	        var defaultProps = type.defaultProps;
	        for (propName in defaultProps) {
	          if (props[propName] === void 0) {
	            props[propName] = defaultProps[propName];
	          }
	        }
	      }
	      {
	        if (key || ref) {
	          var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
	          if (key) {
	            defineKeyPropWarningGetter(props, displayName);
	          }
	          if (ref) {
	            defineRefPropWarningGetter(props, displayName);
	          }
	        }
	      }
	      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	    }
	    function cloneAndReplaceKey(oldElement, newKey) {
	      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	      return newElement;
	    }
	    function cloneElement(element, config, children) {
	      if (element === null || element === void 0) {
	        throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
	      }
	      var propName;
	      var props = assign({}, element.props);
	      var key = element.key;
	      var ref = element.ref;
	      var self = element._self;
	      var source = element._source;
	      var owner = element._owner;
	      if (config != null) {
	        if (hasValidRef(config)) {
	          ref = config.ref;
	          owner = ReactCurrentOwner.current;
	        }
	        if (hasValidKey(config)) {
	          {
	            checkKeyStringCoercion(config.key);
	          }
	          key = "" + config.key;
	        }
	        var defaultProps;
	        if (element.type && element.type.defaultProps) {
	          defaultProps = element.type.defaultProps;
	        }
	        for (propName in config) {
	          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	            if (config[propName] === void 0 && defaultProps !== void 0) {
	              props[propName] = defaultProps[propName];
	            } else {
	              props[propName] = config[propName];
	            }
	          }
	        }
	      }
	      var childrenLength = arguments.length - 2;
	      if (childrenLength === 1) {
	        props.children = children;
	      } else if (childrenLength > 1) {
	        var childArray = Array(childrenLength);
	        for (var i = 0; i < childrenLength; i++) {
	          childArray[i] = arguments[i + 2];
	        }
	        props.children = childArray;
	      }
	      return ReactElement(element.type, key, ref, self, source, owner, props);
	    }
	    function isValidElement(object) {
	      return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	    }
	    var SEPARATOR = ".";
	    var SUBSEPARATOR = ":";
	    function escape(key) {
	      var escapeRegex = /[=:]/g;
	      var escaperLookup = {
	        "=": "=0",
	        ":": "=2"
	      };
	      var escapedString = key.replace(escapeRegex, function(match) {
	        return escaperLookup[match];
	      });
	      return "$" + escapedString;
	    }
	    var didWarnAboutMaps = false;
	    var userProvidedKeyEscapeRegex = /\/+/g;
	    function escapeUserProvidedKey(text) {
	      return text.replace(userProvidedKeyEscapeRegex, "$&/");
	    }
	    function getElementKey(element, index) {
	      if (typeof element === "object" && element !== null && element.key != null) {
	        {
	          checkKeyStringCoercion(element.key);
	        }
	        return escape("" + element.key);
	      }
	      return index.toString(36);
	    }
	    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
	      var type = typeof children;
	      if (type === "undefined" || type === "boolean") {
	        children = null;
	      }
	      var invokeCallback = false;
	      if (children === null) {
	        invokeCallback = true;
	      } else {
	        switch (type) {
	          case "string":
	          case "number":
	            invokeCallback = true;
	            break;
	          case "object":
	            switch (children.$$typeof) {
	              case REACT_ELEMENT_TYPE:
	              case REACT_PORTAL_TYPE:
	                invokeCallback = true;
	            }
	        }
	      }
	      if (invokeCallback) {
	        var _child = children;
	        var mappedChild = callback(_child);
	        var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
	        if (isArray(mappedChild)) {
	          var escapedChildKey = "";
	          if (childKey != null) {
	            escapedChildKey = escapeUserProvidedKey(childKey) + "/";
	          }
	          mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
	            return c;
	          });
	        } else if (mappedChild != null) {
	          if (isValidElement(mappedChild)) {
	            {
	              if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
	                checkKeyStringCoercion(mappedChild.key);
	              }
	            }
	            mappedChild = cloneAndReplaceKey(
	              mappedChild,
	              // Keep both the (mapped) and old keys if they differ, just as
	              // traverseAllChildren used to do for objects as children
	              escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
	              (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
	                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
	                // eslint-disable-next-line react-internal/safe-string-coercion
	                escapeUserProvidedKey("" + mappedChild.key) + "/"
	              ) : "") + childKey
	            );
	          }
	          array.push(mappedChild);
	        }
	        return 1;
	      }
	      var child;
	      var nextName;
	      var subtreeCount = 0;
	      var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	      if (isArray(children)) {
	        for (var i = 0; i < children.length; i++) {
	          child = children[i];
	          nextName = nextNamePrefix + getElementKey(child, i);
	          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
	        }
	      } else {
	        var iteratorFn = getIteratorFn(children);
	        if (typeof iteratorFn === "function") {
	          var iterableChildren = children;
	          {
	            if (iteratorFn === iterableChildren.entries) {
	              if (!didWarnAboutMaps) {
	                warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
	              }
	              didWarnAboutMaps = true;
	            }
	          }
	          var iterator = iteratorFn.call(iterableChildren);
	          var step;
	          var ii = 0;
	          while (!(step = iterator.next()).done) {
	            child = step.value;
	            nextName = nextNamePrefix + getElementKey(child, ii++);
	            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
	          }
	        } else if (type === "object") {
	          var childrenString = String(children);
	          throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
	        }
	      }
	      return subtreeCount;
	    }
	    function mapChildren(children, func, context) {
	      if (children == null) {
	        return children;
	      }
	      var result = [];
	      var count = 0;
	      mapIntoArray(children, result, "", "", function(child) {
	        return func.call(context, child, count++);
	      });
	      return result;
	    }
	    function countChildren(children) {
	      var n = 0;
	      mapChildren(children, function() {
	        n++;
	      });
	      return n;
	    }
	    function forEachChildren(children, forEachFunc, forEachContext) {
	      mapChildren(children, function() {
	        forEachFunc.apply(this, arguments);
	      }, forEachContext);
	    }
	    function toArray(children) {
	      return mapChildren(children, function(child) {
	        return child;
	      }) || [];
	    }
	    function onlyChild(children) {
	      if (!isValidElement(children)) {
	        throw new Error("React.Children.only expected to receive a single React element child.");
	      }
	      return children;
	    }
	    function createContext(defaultValue) {
	      var context = {
	        $$typeof: REACT_CONTEXT_TYPE,
	        // As a workaround to support multiple concurrent renderers, we categorize
	        // some renderers as primary and others as secondary. We only expect
	        // there to be two concurrent renderers at most: React Native (primary) and
	        // Fabric (secondary); React DOM (primary) and React ART (secondary).
	        // Secondary renderers store their context values on separate fields.
	        _currentValue: defaultValue,
	        _currentValue2: defaultValue,
	        // Used to track how many concurrent renderers this context currently
	        // supports within in a single renderer. Such as parallel server rendering.
	        _threadCount: 0,
	        // These are circular
	        Provider: null,
	        Consumer: null,
	        // Add these to use same hidden class in VM as ServerContext
	        _defaultValue: null,
	        _globalName: null
	      };
	      context.Provider = {
	        $$typeof: REACT_PROVIDER_TYPE,
	        _context: context
	      };
	      var hasWarnedAboutUsingNestedContextConsumers = false;
	      var hasWarnedAboutUsingConsumerProvider = false;
	      var hasWarnedAboutDisplayNameOnConsumer = false;
	      {
	        var Consumer = {
	          $$typeof: REACT_CONTEXT_TYPE,
	          _context: context
	        };
	        Object.defineProperties(Consumer, {
	          Provider: {
	            get: function() {
	              if (!hasWarnedAboutUsingConsumerProvider) {
	                hasWarnedAboutUsingConsumerProvider = true;
	                error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
	              }
	              return context.Provider;
	            },
	            set: function(_Provider) {
	              context.Provider = _Provider;
	            }
	          },
	          _currentValue: {
	            get: function() {
	              return context._currentValue;
	            },
	            set: function(_currentValue) {
	              context._currentValue = _currentValue;
	            }
	          },
	          _currentValue2: {
	            get: function() {
	              return context._currentValue2;
	            },
	            set: function(_currentValue2) {
	              context._currentValue2 = _currentValue2;
	            }
	          },
	          _threadCount: {
	            get: function() {
	              return context._threadCount;
	            },
	            set: function(_threadCount) {
	              context._threadCount = _threadCount;
	            }
	          },
	          Consumer: {
	            get: function() {
	              if (!hasWarnedAboutUsingNestedContextConsumers) {
	                hasWarnedAboutUsingNestedContextConsumers = true;
	                error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
	              }
	              return context.Consumer;
	            }
	          },
	          displayName: {
	            get: function() {
	              return context.displayName;
	            },
	            set: function(displayName) {
	              if (!hasWarnedAboutDisplayNameOnConsumer) {
	                warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
	                hasWarnedAboutDisplayNameOnConsumer = true;
	              }
	            }
	          }
	        });
	        context.Consumer = Consumer;
	      }
	      {
	        context._currentRenderer = null;
	        context._currentRenderer2 = null;
	      }
	      return context;
	    }
	    var Uninitialized = -1;
	    var Pending = 0;
	    var Resolved = 1;
	    var Rejected = 2;
	    function lazyInitializer(payload) {
	      if (payload._status === Uninitialized) {
	        var ctor = payload._result;
	        var thenable = ctor();
	        thenable.then(function(moduleObject2) {
	          if (payload._status === Pending || payload._status === Uninitialized) {
	            var resolved = payload;
	            resolved._status = Resolved;
	            resolved._result = moduleObject2;
	          }
	        }, function(error2) {
	          if (payload._status === Pending || payload._status === Uninitialized) {
	            var rejected = payload;
	            rejected._status = Rejected;
	            rejected._result = error2;
	          }
	        });
	        if (payload._status === Uninitialized) {
	          var pending = payload;
	          pending._status = Pending;
	          pending._result = thenable;
	        }
	      }
	      if (payload._status === Resolved) {
	        var moduleObject = payload._result;
	        {
	          if (moduleObject === void 0) {
	            error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
	          }
	        }
	        {
	          if (!("default" in moduleObject)) {
	            error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
	          }
	        }
	        return moduleObject.default;
	      } else {
	        throw payload._result;
	      }
	    }
	    function lazy(ctor) {
	      var payload = {
	        // We use these fields to store the result.
	        _status: Uninitialized,
	        _result: ctor
	      };
	      var lazyType = {
	        $$typeof: REACT_LAZY_TYPE,
	        _payload: payload,
	        _init: lazyInitializer
	      };
	      {
	        var defaultProps;
	        var propTypes;
	        Object.defineProperties(lazyType, {
	          defaultProps: {
	            configurable: true,
	            get: function() {
	              return defaultProps;
	            },
	            set: function(newDefaultProps) {
	              error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
	              defaultProps = newDefaultProps;
	              Object.defineProperty(lazyType, "defaultProps", {
	                enumerable: true
	              });
	            }
	          },
	          propTypes: {
	            configurable: true,
	            get: function() {
	              return propTypes;
	            },
	            set: function(newPropTypes) {
	              error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
	              propTypes = newPropTypes;
	              Object.defineProperty(lazyType, "propTypes", {
	                enumerable: true
	              });
	            }
	          }
	        });
	      }
	      return lazyType;
	    }
	    function forwardRef(render) {
	      {
	        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
	          error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
	        } else if (typeof render !== "function") {
	          error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
	        } else {
	          if (render.length !== 0 && render.length !== 2) {
	            error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
	          }
	        }
	        if (render != null) {
	          if (render.defaultProps != null || render.propTypes != null) {
	            error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
	          }
	        }
	      }
	      var elementType = {
	        $$typeof: REACT_FORWARD_REF_TYPE,
	        render
	      };
	      {
	        var ownName;
	        Object.defineProperty(elementType, "displayName", {
	          enumerable: false,
	          configurable: true,
	          get: function() {
	            return ownName;
	          },
	          set: function(name) {
	            ownName = name;
	            if (!render.name && !render.displayName) {
	              render.displayName = name;
	            }
	          }
	        });
	      }
	      return elementType;
	    }
	    var REACT_MODULE_REFERENCE;
	    {
	      REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
	    }
	    function isValidElementType(type) {
	      if (typeof type === "string" || typeof type === "function") {
	        return true;
	      }
	      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
	        return true;
	      }
	      if (typeof type === "object" && type !== null) {
	        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
	        // types supported by any Flight configuration anywhere since
	        // we don't know which Flight build this will end up being used
	        // with.
	        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
	          return true;
	        }
	      }
	      return false;
	    }
	    function memo(type, compare) {
	      {
	        if (!isValidElementType(type)) {
	          error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
	        }
	      }
	      var elementType = {
	        $$typeof: REACT_MEMO_TYPE,
	        type,
	        compare: compare === void 0 ? null : compare
	      };
	      {
	        var ownName;
	        Object.defineProperty(elementType, "displayName", {
	          enumerable: false,
	          configurable: true,
	          get: function() {
	            return ownName;
	          },
	          set: function(name) {
	            ownName = name;
	            if (!type.name && !type.displayName) {
	              type.displayName = name;
	            }
	          }
	        });
	      }
	      return elementType;
	    }
	    function resolveDispatcher() {
	      var dispatcher = ReactCurrentDispatcher.current;
	      {
	        if (dispatcher === null) {
	          error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
	        }
	      }
	      return dispatcher;
	    }
	    function useContext(Context) {
	      var dispatcher = resolveDispatcher();
	      {
	        if (Context._context !== void 0) {
	          var realContext = Context._context;
	          if (realContext.Consumer === Context) {
	            error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
	          } else if (realContext.Provider === Context) {
	            error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
	          }
	        }
	      }
	      return dispatcher.useContext(Context);
	    }
	    function useState(initialState) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useState(initialState);
	    }
	    function useReducer(reducer, initialArg, init) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useReducer(reducer, initialArg, init);
	    }
	    function useRef(initialValue) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useRef(initialValue);
	    }
	    function useEffect(create, deps) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useEffect(create, deps);
	    }
	    function useInsertionEffect(create, deps) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useInsertionEffect(create, deps);
	    }
	    function useLayoutEffect(create, deps) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useLayoutEffect(create, deps);
	    }
	    function useCallback(callback, deps) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useCallback(callback, deps);
	    }
	    function useMemo(create, deps) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useMemo(create, deps);
	    }
	    function useImperativeHandle(ref, create, deps) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useImperativeHandle(ref, create, deps);
	    }
	    function useDebugValue(value, formatterFn) {
	      {
	        var dispatcher = resolveDispatcher();
	        return dispatcher.useDebugValue(value, formatterFn);
	      }
	    }
	    function useTransition() {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useTransition();
	    }
	    function useDeferredValue(value) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useDeferredValue(value);
	    }
	    function useId() {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useId();
	    }
	    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
	    }
	    var disabledDepth = 0;
	    var prevLog;
	    var prevInfo;
	    var prevWarn;
	    var prevError;
	    var prevGroup;
	    var prevGroupCollapsed;
	    var prevGroupEnd;
	    function disabledLog() {
	    }
	    disabledLog.__reactDisabledLog = true;
	    function disableLogs() {
	      {
	        if (disabledDepth === 0) {
	          prevLog = console.log;
	          prevInfo = console.info;
	          prevWarn = console.warn;
	          prevError = console.error;
	          prevGroup = console.group;
	          prevGroupCollapsed = console.groupCollapsed;
	          prevGroupEnd = console.groupEnd;
	          var props = {
	            configurable: true,
	            enumerable: true,
	            value: disabledLog,
	            writable: true
	          };
	          Object.defineProperties(console, {
	            info: props,
	            log: props,
	            warn: props,
	            error: props,
	            group: props,
	            groupCollapsed: props,
	            groupEnd: props
	          });
	        }
	        disabledDepth++;
	      }
	    }
	    function reenableLogs() {
	      {
	        disabledDepth--;
	        if (disabledDepth === 0) {
	          var props = {
	            configurable: true,
	            enumerable: true,
	            writable: true
	          };
	          Object.defineProperties(console, {
	            log: assign({}, props, {
	              value: prevLog
	            }),
	            info: assign({}, props, {
	              value: prevInfo
	            }),
	            warn: assign({}, props, {
	              value: prevWarn
	            }),
	            error: assign({}, props, {
	              value: prevError
	            }),
	            group: assign({}, props, {
	              value: prevGroup
	            }),
	            groupCollapsed: assign({}, props, {
	              value: prevGroupCollapsed
	            }),
	            groupEnd: assign({}, props, {
	              value: prevGroupEnd
	            })
	          });
	        }
	        if (disabledDepth < 0) {
	          error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
	        }
	      }
	    }
	    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
	    var prefix;
	    function describeBuiltInComponentFrame(name, source, ownerFn) {
	      {
	        if (prefix === void 0) {
	          try {
	            throw Error();
	          } catch (x) {
	            var match = x.stack.trim().match(/\n( *(at )?)/);
	            prefix = match && match[1] || "";
	          }
	        }
	        return "\n" + prefix + name;
	      }
	    }
	    var reentry = false;
	    var componentFrameCache;
	    {
	      var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
	      componentFrameCache = new PossiblyWeakMap();
	    }
	    function describeNativeComponentFrame(fn, construct) {
	      if (!fn || reentry) {
	        return "";
	      }
	      {
	        var frame = componentFrameCache.get(fn);
	        if (frame !== void 0) {
	          return frame;
	        }
	      }
	      var control;
	      reentry = true;
	      var previousPrepareStackTrace = Error.prepareStackTrace;
	      Error.prepareStackTrace = void 0;
	      var previousDispatcher;
	      {
	        previousDispatcher = ReactCurrentDispatcher$1.current;
	        ReactCurrentDispatcher$1.current = null;
	        disableLogs();
	      }
	      try {
	        if (construct) {
	          var Fake = function() {
	            throw Error();
	          };
	          Object.defineProperty(Fake.prototype, "props", {
	            set: function() {
	              throw Error();
	            }
	          });
	          if (typeof Reflect === "object" && Reflect.construct) {
	            try {
	              Reflect.construct(Fake, []);
	            } catch (x) {
	              control = x;
	            }
	            Reflect.construct(fn, [], Fake);
	          } else {
	            try {
	              Fake.call();
	            } catch (x) {
	              control = x;
	            }
	            fn.call(Fake.prototype);
	          }
	        } else {
	          try {
	            throw Error();
	          } catch (x) {
	            control = x;
	          }
	          fn();
	        }
	      } catch (sample) {
	        if (sample && control && typeof sample.stack === "string") {
	          var sampleLines = sample.stack.split("\n");
	          var controlLines = control.stack.split("\n");
	          var s = sampleLines.length - 1;
	          var c = controlLines.length - 1;
	          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
	            c--;
	          }
	          for (; s >= 1 && c >= 0; s--, c--) {
	            if (sampleLines[s] !== controlLines[c]) {
	              if (s !== 1 || c !== 1) {
	                do {
	                  s--;
	                  c--;
	                  if (c < 0 || sampleLines[s] !== controlLines[c]) {
	                    var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
	                    if (fn.displayName && _frame.includes("<anonymous>")) {
	                      _frame = _frame.replace("<anonymous>", fn.displayName);
	                    }
	                    {
	                      if (typeof fn === "function") {
	                        componentFrameCache.set(fn, _frame);
	                      }
	                    }
	                    return _frame;
	                  }
	                } while (s >= 1 && c >= 0);
	              }
	              break;
	            }
	          }
	        }
	      } finally {
	        reentry = false;
	        {
	          ReactCurrentDispatcher$1.current = previousDispatcher;
	          reenableLogs();
	        }
	        Error.prepareStackTrace = previousPrepareStackTrace;
	      }
	      var name = fn ? fn.displayName || fn.name : "";
	      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
	      {
	        if (typeof fn === "function") {
	          componentFrameCache.set(fn, syntheticFrame);
	        }
	      }
	      return syntheticFrame;
	    }
	    function describeFunctionComponentFrame(fn, source, ownerFn) {
	      {
	        return describeNativeComponentFrame(fn, false);
	      }
	    }
	    function shouldConstruct(Component2) {
	      var prototype = Component2.prototype;
	      return !!(prototype && prototype.isReactComponent);
	    }
	    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
	      if (type == null) {
	        return "";
	      }
	      if (typeof type === "function") {
	        {
	          return describeNativeComponentFrame(type, shouldConstruct(type));
	        }
	      }
	      if (typeof type === "string") {
	        return describeBuiltInComponentFrame(type);
	      }
	      switch (type) {
	        case REACT_SUSPENSE_TYPE:
	          return describeBuiltInComponentFrame("Suspense");
	        case REACT_SUSPENSE_LIST_TYPE:
	          return describeBuiltInComponentFrame("SuspenseList");
	      }
	      if (typeof type === "object") {
	        switch (type.$$typeof) {
	          case REACT_FORWARD_REF_TYPE:
	            return describeFunctionComponentFrame(type.render);
	          case REACT_MEMO_TYPE:
	            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
	          case REACT_LAZY_TYPE: {
	            var lazyComponent = type;
	            var payload = lazyComponent._payload;
	            var init = lazyComponent._init;
	            try {
	              return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
	            } catch (x) {
	            }
	          }
	        }
	      }
	      return "";
	    }
	    var loggedTypeFailures = {};
	    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
	    function setCurrentlyValidatingElement(element) {
	      {
	        if (element) {
	          var owner = element._owner;
	          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
	          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
	        } else {
	          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
	        }
	      }
	    }
	    function checkPropTypes(typeSpecs, values, location, componentName, element) {
	      {
	        var has = Function.call.bind(hasOwnProperty);
	        for (var typeSpecName in typeSpecs) {
	          if (has(typeSpecs, typeSpecName)) {
	            var error$1 = void 0;
	            try {
	              if (typeof typeSpecs[typeSpecName] !== "function") {
	                var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
	                err.name = "Invariant Violation";
	                throw err;
	              }
	              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
	            } catch (ex) {
	              error$1 = ex;
	            }
	            if (error$1 && !(error$1 instanceof Error)) {
	              setCurrentlyValidatingElement(element);
	              error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
	              setCurrentlyValidatingElement(null);
	            }
	            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
	              loggedTypeFailures[error$1.message] = true;
	              setCurrentlyValidatingElement(element);
	              error("Failed %s type: %s", location, error$1.message);
	              setCurrentlyValidatingElement(null);
	            }
	          }
	        }
	      }
	    }
	    function setCurrentlyValidatingElement$1(element) {
	      {
	        if (element) {
	          var owner = element._owner;
	          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
	          setExtraStackFrame(stack);
	        } else {
	          setExtraStackFrame(null);
	        }
	      }
	    }
	    var propTypesMisspellWarningShown;
	    {
	      propTypesMisspellWarningShown = false;
	    }
	    function getDeclarationErrorAddendum() {
	      if (ReactCurrentOwner.current) {
	        var name = getComponentNameFromType(ReactCurrentOwner.current.type);
	        if (name) {
	          return "\n\nCheck the render method of `" + name + "`.";
	        }
	      }
	      return "";
	    }
	    function getSourceInfoErrorAddendum(source) {
	      if (source !== void 0) {
	        var fileName = source.fileName.replace(/^.*[\\\/]/, "");
	        var lineNumber = source.lineNumber;
	        return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
	      }
	      return "";
	    }
	    function getSourceInfoErrorAddendumForProps(elementProps) {
	      if (elementProps !== null && elementProps !== void 0) {
	        return getSourceInfoErrorAddendum(elementProps.__source);
	      }
	      return "";
	    }
	    var ownerHasKeyUseWarning = {};
	    function getCurrentComponentErrorInfo(parentType) {
	      var info = getDeclarationErrorAddendum();
	      if (!info) {
	        var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
	        if (parentName) {
	          info = "\n\nCheck the top-level render call using <" + parentName + ">.";
	        }
	      }
	      return info;
	    }
	    function validateExplicitKey(element, parentType) {
	      if (!element._store || element._store.validated || element.key != null) {
	        return;
	      }
	      element._store.validated = true;
	      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
	        return;
	      }
	      ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
	      var childOwner = "";
	      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	        childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
	      }
	      {
	        setCurrentlyValidatingElement$1(element);
	        error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
	        setCurrentlyValidatingElement$1(null);
	      }
	    }
	    function validateChildKeys(node, parentType) {
	      if (typeof node !== "object") {
	        return;
	      }
	      if (isArray(node)) {
	        for (var i = 0; i < node.length; i++) {
	          var child = node[i];
	          if (isValidElement(child)) {
	            validateExplicitKey(child, parentType);
	          }
	        }
	      } else if (isValidElement(node)) {
	        if (node._store) {
	          node._store.validated = true;
	        }
	      } else if (node) {
	        var iteratorFn = getIteratorFn(node);
	        if (typeof iteratorFn === "function") {
	          if (iteratorFn !== node.entries) {
	            var iterator = iteratorFn.call(node);
	            var step;
	            while (!(step = iterator.next()).done) {
	              if (isValidElement(step.value)) {
	                validateExplicitKey(step.value, parentType);
	              }
	            }
	          }
	        }
	      }
	    }
	    function validatePropTypes(element) {
	      {
	        var type = element.type;
	        if (type === null || type === void 0 || typeof type === "string") {
	          return;
	        }
	        var propTypes;
	        if (typeof type === "function") {
	          propTypes = type.propTypes;
	        } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
	        // Inner props are checked in the reconciler.
	        type.$$typeof === REACT_MEMO_TYPE)) {
	          propTypes = type.propTypes;
	        } else {
	          return;
	        }
	        if (propTypes) {
	          var name = getComponentNameFromType(type);
	          checkPropTypes(propTypes, element.props, "prop", name, element);
	        } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
	          propTypesMisspellWarningShown = true;
	          var _name = getComponentNameFromType(type);
	          error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
	        }
	        if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
	          error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
	        }
	      }
	    }
	    function validateFragmentProps(fragment) {
	      {
	        var keys = Object.keys(fragment.props);
	        for (var i = 0; i < keys.length; i++) {
	          var key = keys[i];
	          if (key !== "children" && key !== "key") {
	            setCurrentlyValidatingElement$1(fragment);
	            error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
	            setCurrentlyValidatingElement$1(null);
	            break;
	          }
	        }
	        if (fragment.ref !== null) {
	          setCurrentlyValidatingElement$1(fragment);
	          error("Invalid attribute `ref` supplied to `React.Fragment`.");
	          setCurrentlyValidatingElement$1(null);
	        }
	      }
	    }
	    function createElementWithValidation(type, props, children) {
	      var validType = isValidElementType(type);
	      if (!validType) {
	        var info = "";
	        if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
	          info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
	        }
	        var sourceInfo = getSourceInfoErrorAddendumForProps(props);
	        if (sourceInfo) {
	          info += sourceInfo;
	        } else {
	          info += getDeclarationErrorAddendum();
	        }
	        var typeString;
	        if (type === null) {
	          typeString = "null";
	        } else if (isArray(type)) {
	          typeString = "array";
	        } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
	          typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
	          info = " Did you accidentally export a JSX literal instead of a component?";
	        } else {
	          typeString = typeof type;
	        }
	        {
	          error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
	        }
	      }
	      var element = createElement.apply(this, arguments);
	      if (element == null) {
	        return element;
	      }
	      if (validType) {
	        for (var i = 2; i < arguments.length; i++) {
	          validateChildKeys(arguments[i], type);
	        }
	      }
	      if (type === REACT_FRAGMENT_TYPE) {
	        validateFragmentProps(element);
	      } else {
	        validatePropTypes(element);
	      }
	      return element;
	    }
	    var didWarnAboutDeprecatedCreateFactory = false;
	    function createFactoryWithValidation(type) {
	      var validatedFactory = createElementWithValidation.bind(null, type);
	      validatedFactory.type = type;
	      {
	        if (!didWarnAboutDeprecatedCreateFactory) {
	          didWarnAboutDeprecatedCreateFactory = true;
	          warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
	        }
	        Object.defineProperty(validatedFactory, "type", {
	          enumerable: false,
	          get: function() {
	            warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
	            Object.defineProperty(this, "type", {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	      return validatedFactory;
	    }
	    function cloneElementWithValidation(element, props, children) {
	      var newElement = cloneElement.apply(this, arguments);
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], newElement.type);
	      }
	      validatePropTypes(newElement);
	      return newElement;
	    }
	    function startTransition(scope, options) {
	      var prevTransition = ReactCurrentBatchConfig.transition;
	      ReactCurrentBatchConfig.transition = {};
	      var currentTransition = ReactCurrentBatchConfig.transition;
	      {
	        ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
	      }
	      try {
	        scope();
	      } finally {
	        ReactCurrentBatchConfig.transition = prevTransition;
	        {
	          if (prevTransition === null && currentTransition._updatedFibers) {
	            var updatedFibersCount = currentTransition._updatedFibers.size;
	            if (updatedFibersCount > 10) {
	              warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
	            }
	            currentTransition._updatedFibers.clear();
	          }
	        }
	      }
	    }
	    var didWarnAboutMessageChannel = false;
	    var enqueueTaskImpl = null;
	    function enqueueTask(task) {
	      if (enqueueTaskImpl === null) {
	        try {
	          var requireString = ("require" + Math.random()).slice(0, 7);
	          var nodeRequire = module && module[requireString];
	          enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
	        } catch (_err) {
	          enqueueTaskImpl = function(callback) {
	            {
	              if (didWarnAboutMessageChannel === false) {
	                didWarnAboutMessageChannel = true;
	                if (typeof MessageChannel === "undefined") {
	                  error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
	                }
	              }
	            }
	            var channel = new MessageChannel();
	            channel.port1.onmessage = callback;
	            channel.port2.postMessage(void 0);
	          };
	        }
	      }
	      return enqueueTaskImpl(task);
	    }
	    var actScopeDepth = 0;
	    var didWarnNoAwaitAct = false;
	    function act(callback) {
	      {
	        var prevActScopeDepth = actScopeDepth;
	        actScopeDepth++;
	        if (ReactCurrentActQueue.current === null) {
	          ReactCurrentActQueue.current = [];
	        }
	        var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
	        var result;
	        try {
	          ReactCurrentActQueue.isBatchingLegacy = true;
	          result = callback();
	          if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
	            var queue = ReactCurrentActQueue.current;
	            if (queue !== null) {
	              ReactCurrentActQueue.didScheduleLegacyUpdate = false;
	              flushActQueue(queue);
	            }
	          }
	        } catch (error2) {
	          popActScope(prevActScopeDepth);
	          throw error2;
	        } finally {
	          ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
	        }
	        if (result !== null && typeof result === "object" && typeof result.then === "function") {
	          var thenableResult = result;
	          var wasAwaited = false;
	          var thenable = {
	            then: function(resolve, reject) {
	              wasAwaited = true;
	              thenableResult.then(function(returnValue2) {
	                popActScope(prevActScopeDepth);
	                if (actScopeDepth === 0) {
	                  recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
	                } else {
	                  resolve(returnValue2);
	                }
	              }, function(error2) {
	                popActScope(prevActScopeDepth);
	                reject(error2);
	              });
	            }
	          };
	          {
	            if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
	              Promise.resolve().then(function() {
	              }).then(function() {
	                if (!wasAwaited) {
	                  didWarnNoAwaitAct = true;
	                  error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
	                }
	              });
	            }
	          }
	          return thenable;
	        } else {
	          var returnValue = result;
	          popActScope(prevActScopeDepth);
	          if (actScopeDepth === 0) {
	            var _queue = ReactCurrentActQueue.current;
	            if (_queue !== null) {
	              flushActQueue(_queue);
	              ReactCurrentActQueue.current = null;
	            }
	            var _thenable = {
	              then: function(resolve, reject) {
	                if (ReactCurrentActQueue.current === null) {
	                  ReactCurrentActQueue.current = [];
	                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);
	                } else {
	                  resolve(returnValue);
	                }
	              }
	            };
	            return _thenable;
	          } else {
	            var _thenable2 = {
	              then: function(resolve, reject) {
	                resolve(returnValue);
	              }
	            };
	            return _thenable2;
	          }
	        }
	      }
	    }
	    function popActScope(prevActScopeDepth) {
	      {
	        if (prevActScopeDepth !== actScopeDepth - 1) {
	          error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
	        }
	        actScopeDepth = prevActScopeDepth;
	      }
	    }
	    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
	      {
	        var queue = ReactCurrentActQueue.current;
	        if (queue !== null) {
	          try {
	            flushActQueue(queue);
	            enqueueTask(function() {
	              if (queue.length === 0) {
	                ReactCurrentActQueue.current = null;
	                resolve(returnValue);
	              } else {
	                recursivelyFlushAsyncActWork(returnValue, resolve, reject);
	              }
	            });
	          } catch (error2) {
	            reject(error2);
	          }
	        } else {
	          resolve(returnValue);
	        }
	      }
	    }
	    var isFlushing = false;
	    function flushActQueue(queue) {
	      {
	        if (!isFlushing) {
	          isFlushing = true;
	          var i = 0;
	          try {
	            for (; i < queue.length; i++) {
	              var callback = queue[i];
	              do {
	                callback = callback(true);
	              } while (callback !== null);
	            }
	            queue.length = 0;
	          } catch (error2) {
	            queue = queue.slice(i + 1);
	            throw error2;
	          } finally {
	            isFlushing = false;
	          }
	        }
	      }
	    }
	    var createElement$1 = createElementWithValidation;
	    var cloneElement$1 = cloneElementWithValidation;
	    var createFactory = createFactoryWithValidation;
	    var Children = {
	      map: mapChildren,
	      forEach: forEachChildren,
	      count: countChildren,
	      toArray,
	      only: onlyChild
	    };
	    exports.Children = Children;
	    exports.Component = Component;
	    exports.Fragment = REACT_FRAGMENT_TYPE;
	    exports.Profiler = REACT_PROFILER_TYPE;
	    exports.PureComponent = PureComponent;
	    exports.StrictMode = REACT_STRICT_MODE_TYPE;
	    exports.Suspense = REACT_SUSPENSE_TYPE;
	    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
	    exports.cloneElement = cloneElement$1;
	    exports.createContext = createContext;
	    exports.createElement = createElement$1;
	    exports.createFactory = createFactory;
	    exports.createRef = createRef;
	    exports.forwardRef = forwardRef;
	    exports.isValidElement = isValidElement;
	    exports.lazy = lazy;
	    exports.memo = memo;
	    exports.startTransition = startTransition;
	    exports.unstable_act = act;
	    exports.useCallback = useCallback;
	    exports.useContext = useContext;
	    exports.useDebugValue = useDebugValue;
	    exports.useDeferredValue = useDeferredValue;
	    exports.useEffect = useEffect;
	    exports.useId = useId;
	    exports.useImperativeHandle = useImperativeHandle;
	    exports.useInsertionEffect = useInsertionEffect;
	    exports.useLayoutEffect = useLayoutEffect;
	    exports.useMemo = useMemo;
	    exports.useReducer = useReducer;
	    exports.useRef = useRef;
	    exports.useState = useState;
	    exports.useSyncExternalStore = useSyncExternalStore;
	    exports.useTransition = useTransition;
	    exports.version = ReactVersion;
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
	      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
	    }
	  })();
	} 
} (react_development$2, react_development$2.exports));

var react_developmentExports = react_development$2.exports;
var react_development$1 = /*@__PURE__*/getDefaultExportFromCjs(react_developmentExports);

var react = react$1.exports;

"use strict";
if (false) {
  module.exports = require("./cjs/react.production.min.js");
} else {
  react$1.exports = react_developmentExports;
}

var reactExports = react$1.exports;
var n = /*@__PURE__*/getDefaultExportFromCjs(reactExports);

var t = /*#__PURE__*/_mergeNamespaces({
	__proto__: null,
	default: n
}, [reactExports]);

class AssertionError extends Error {
  constructor(message = "Unexpected error occurred, please contact your system administrator.") {
    super(message), Object.setPrototypeOf(this, AssertionError.prototype);
  }
}
function ensure(arg) {
  if (null == arg)
    throw new Error("Did not expect an argument to be undefined");
  return arg;
}
function crash() {
  throw new AssertionError();
}
function friendlyName(component) {
  return component.displayName ?? component.name ?? "<component>";
}
function isDefined(value) {
  return void 0 !== value;
}
function isString(value) {
  return "string" == typeof value;
}
function isJson(obj) {
  return null != obj && "object" == typeof obj && obj.constructor === {}.constructor;
}
function isArrayOf(type, value) {
  return value instanceof Array && value.every((v) => void 0 === v || v instanceof type);
}
function unique(list) {
  return Array.from(new Set(list));
}
const identityMapper = (e) => e;
function partition(predicate, array, mapper = identityMapper) {
  const matching = [], unmatching = [];
  return array.forEach((item) => {
    const mappedItem = mapper(item);
    return predicate(item) ? matching.push(mappedItem) : unmatching.push(mappedItem);
  }), [matching, unmatching];
}
function tuple(...args) {
  return args;
}
function mapValues(source, mapValue) {
  const result = {};
  return Object.keys(source).forEach((key) => result[key] = mapValue(source[key], key)), result;
}
function partitionValues(source, predicate) {
  const matching = {}, unmatching = {};
  return Object.keys(source).forEach((key) => {
    (predicate(source[key]) ? matching : unmatching)[key] = source[key];
  }), [matching, unmatching];
}
function filterValues(source, predicate) {
  const result = {};
  return Object.keys(source).forEach((key) => {
    predicate(source[key], key) && (result[key] = source[key]);
  }), result;
}
function uniqueBy(list, keySelector) {
  const res = [], keys = {};
  return list.forEach((item) => {
    const key = keySelector(item);
    Object.prototype.hasOwnProperty.call(keys, key) || (keys[key] = true, res.push(item));
  }), res;
}
function difference(iterable1, iterable2) {
  return new Set([...iterable1].filter((item) => !iterable2.has(item)));
}
function concat(arrays) {
  return [].concat(...arrays);
}
function subtract(from, negate) {
  return from.filter((x) => !negate.includes(x));
}
function asArray(value) {
  return Array.isArray(value) ? value : value ? [value] : [];
}
function escapeXml(s) {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
function containsKey(key, obj) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function flatten(objects) {
  return deepmerge$1.all(objects.filter((object) => {
    return void 0 !== object && (obj = object, !(0 === Object.getOwnPropertyNames(obj).length && obj.constructor === Object));
    var obj;
  }), { clone: false });
}
function lowerCaseFirst(str) {
  return "string" == typeof str[0] ? str[0].toLowerCase() + str.slice(1) : "";
}
function toFriendlyId(widgetId) {
  const parts = widgetId.split(/\./g);
  return parts.length >= 4 ? parts.slice(1, 4).join(".") : widgetId;
}
function toWidgetName(widgetId) {
  const parts = widgetId.split(/\./g);
  return parts.length >= 4 ? parts[3] : void 0;
}
function useIsFirstRender() {
  let result = false;
  return reactExports.useMemo(() => {
    result = true;
  }, []), result;
}
function repeat(length, builder) {
  return Array.from({ length }).map((_, i) => builder(i));
}
function indexByKey(getKey) {
  return (items) => items.reduce((mapObj, item) => (mapObj[getKey(item)] = item, mapObj), /* @__PURE__ */ Object.create(null));
}
function toObjectByKey(items, getKey) {
  return indexByKey(getKey)(items);
}
function toObjectById(items) {
  return toObjectByKey(items, (i) => i.id);
}
function isReferenceType(type) {
  return "ObjectReference" === type || "ObjectReferenceSet" === type;
}
function isNumericType(type) {
  return "Decimal" === type || "Integer" === type || "Long" === type;
}
function hasKey(record, key) {
  return Object.prototype.hasOwnProperty.call(record, key);
}
function useForceUpdate() {
  const [, setState] = reactExports.useState({});
  return reactExports.useCallback(() => setState({}), []);
}
function groupBy(values, getKey) {
  return groupByMap(values, getKey, (v) => v);
}
function groupByMap(values, getKey, mapValue) {
  const result = [];
  for (const value of values) {
    const key = getKey(value), mappedValue = mapValue(value), existingItem = result.find((x) => x.key === key);
    existingItem ? existingItem.values.push(mappedValue) : result.push({ key, values: [mappedValue] });
  }
  return result;
}
function useEnsureConstantValues(...values) {
  const initialValueRef = reactExports.useRef([...values]);
  if (initialValueRef.current.length !== values.length || initialValueRef.current.some((initialValue, index) => values[index] !== initialValue))
    throw new AssertionError("The hook is called with different parameters than previously");
}
function joinPath(...parts) {
  let result = "";
  for (const part of parts)
    void 0 !== part && (result.endsWith("/") && part.startsWith("/") ? result += part.substring(1) : result.endsWith("/") || part.startsWith("/") ? result += part : result += "/" + part);
  return result;
}
function mergeQueryStrings(q1, q2) {
  const result = new URLSearchParams(q1);
  return new URLSearchParams(q2).forEach((value, key) => {
    result.set(key, value);
  }), result.toString();
}

let session$1;
function getSession() {
  return ensure(session$1);
}
function setSession(s) {
  session$1 = s;
}

function getEntityMeta(entity) {
  return getMetadata().get(entity);
}
function getAttributesMeta(entity) {
  return Object.values(getEntityMeta(entity)?.attributes ?? {});
}
function getAttributeType$1(entity, attribute) {
  return getMetadata().get(entity)?.attributes[attribute]?.type;
}
function getAttributeEnumerationType(entity, attribute) {
  const result = getMetadata().get(entity)?.attributes[attribute]?.enumeration;
  if (!result)
    throw new AssertionError(`Attribute ${attribute} is not accessible or not enumeration`);
  return result;
}
function isReferenceAttribute(meta, attribute) {
  return isReferenceType(meta?.attributes[attribute]?.type);
}
function isEntityA(entity, targetEntity) {
  return entity === targetEntity || Boolean(getEntityMeta(entity)?.generalizations.includes(targetEntity));
}
const cachedAttributeOwner = /* @__PURE__ */ new Map();
function computeSupermostEntityWithAttribute(entity, attribute) {
  const cacheKey = `${entity}.${attribute}`, cachedResult = cachedAttributeOwner.get(cacheKey);
  if (void 0 !== cachedResult && !disableCaching)
    return cachedResult;
  const meta = getEntityMeta(entity);
  if (!meta?.attributes[attribute])
    return;
  const result = meta.generalizations.filter((superEntity) => getEntityMeta(superEntity)?.attributes[attribute]).pop() ?? entity;
  return cachedAttributeOwner.set(cacheKey, result), result;
}
var SystemAttribute;
function isSystemAttribute(attr) {
  return Object.values(SystemAttribute).includes(attr);
}
function isFileDocument(entity, checkAsImage = false) {
  return isEntityA(entity, checkAsImage ? "System.Image" : "System.FileDocument");
}
function isImage(objectType) {
  return isEntityA(objectType, "System.Image");
}
function isFileDocumentWithContents(obj, checkAsImage = false) {
  return isFileDocument(obj.objectType, checkAsImage) && true === ensure(obj.attributes.HasContents).value;
}
function deriveEntityId(id) {
  return Number(BigInt(id) >> 48n);
}
!function(SystemAttribute2) {
  SystemAttribute2.ChangedBy = "System.changedBy", SystemAttribute2.Owner = "System.owner", SystemAttribute2.CreatedDate = "createdDate", SystemAttribute2.ChangedDate = "changedDate";
}(SystemAttribute || (SystemAttribute = {}));
const cachedMetadata = /* @__PURE__ */ new Map();
function getMetadata() {
  if (0 === cachedMetadata.size) {
    getSession().getConfig("metadata").forEach((m) => {
      const entityId = m.entityId ?? (void 0 === m.maxObjectId ? void 0 : deriveEntityId(m.maxObjectId)), entityMeta = Object.freeze({ entityId, name: m.objectType, generalization: m.properties.generalization, generalizations: Object.freeze(m.properties.superclasses), specializations: Object.freeze(m.properties.subclasses), isPersistable: m.persistable, maxObjectId: m.maxObjectId, ...m.isRemoteFileEntity && { isRemoteFileEntity: m.isRemoteFileEntity }, needsReachableState: Object.freeze(m.needsReachableState), deleteBehavior: Object.freeze(m.deleteBehavior), attributes: Object.freeze(Object.fromEntries(Object.entries(m.attributes).map(([attr, attrMeta]) => [attr, Object.freeze({ name: attr, type: attrMeta.type, referenceEntity: isReferenceType(attrMeta.type) ? attrMeta.klass : void 0, enumeration: "Enum" === attrMeta.type ? attrMeta.klass : void 0, isDateLocalized: "DateTime" === attrMeta.type ? Boolean(attrMeta.localize) : void 0, isBidiReference: isReferenceType(attrMeta.type) ? Boolean(attrMeta.both) : void 0, isSyncable: false !== attrMeta.sync, isAlwaysReadOnly: Boolean(attrMeta.readonly), defaultValue: attrMeta.defaultValue })]))), indices: (m.indices ?? []).map((index) => Object.freeze({ attributes: index.attributes.map((indexAttr) => Object.freeze({ name: indexAttr.name, direction: indexAttr.direction })) })) });
      cachedMetadata.set(m.objectType, entityMeta), void 0 !== entityId && cachedMetadata.set(entityId, entityMeta);
    });
  }
  return cachedMetadata;
}
const disableCaching = false;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
function getNextId() {
  return ++globalState.mobxGuid;
}
function fail(message) {
  throw invariant(false, message), "X";
}
function invariant(check, message) {
  if (!check)
    throw new Error("[mobx] " + (message || "An invariant failed, however the error is obfuscated because this is a production build."));
}
function once(func) {
  var invoked = false;
  return function() {
    if (!invoked)
      return invoked = true, func.apply(this, arguments);
  };
}
Object.freeze(EMPTY_OBJECT);
var noop = function() {
};
function isObject(value) {
  return null !== value && "object" == typeof value;
}
function isPlainObject(value) {
  if (null === value || "object" != typeof value)
    return false;
  var proto = Object.getPrototypeOf(value);
  return proto === Object.prototype || null === proto;
}
function addHiddenProp(object, propName, value) {
  Object.defineProperty(object, propName, { enumerable: false, writable: true, configurable: true, value });
}
function createInstanceofPredicate(name, clazz) {
  var propName = "isMobX" + name;
  return clazz.prototype[propName] = true, function(x) {
    return isObject(x) && true === x[propName];
  };
}
function isES6Map(thing) {
  return thing instanceof Map;
}
function isES6Set(thing) {
  return thing instanceof Set;
}
function stringifyKey(key) {
  return key && key.toString ? key.toString() : new String(key).toString();
}
function toPrimitive(value) {
  return null === value ? null : "object" == typeof value ? "" + value : value;
}
var ownKeys = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols ? function(obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : Object.getOwnPropertyNames, $mobx = Symbol("mobx administration"), Atom = function() {
  function Atom2(name) {
    void 0 === name && (name = "Atom@" + getNextId()), this.name = name, this.isPendingUnobservation = false, this.isBeingObserved = false, this.observers = /* @__PURE__ */ new Set(), this.diffValue = 0, this.lastAccessedBy = 0, this.lowestObserverState = IDerivationState.NOT_TRACKING;
  }
  return Atom2.prototype.onBecomeObserved = function() {
    this.onBecomeObservedListeners && this.onBecomeObservedListeners.forEach(function(listener) {
      return listener();
    });
  }, Atom2.prototype.onBecomeUnobserved = function() {
    this.onBecomeUnobservedListeners && this.onBecomeUnobservedListeners.forEach(function(listener) {
      return listener();
    });
  }, Atom2.prototype.reportObserved = function() {
    return reportObserved(this);
  }, Atom2.prototype.reportChanged = function() {
    startBatch(), function(observable2) {
      if (observable2.lowestObserverState === IDerivationState.STALE)
        return;
      observable2.lowestObserverState = IDerivationState.STALE, observable2.observers.forEach(function(d) {
        d.dependenciesState === IDerivationState.UP_TO_DATE && (d.isTracing !== TraceMode.NONE && logTraceInfo(d, observable2), d.onBecomeStale()), d.dependenciesState = IDerivationState.STALE;
      });
    }(this), endBatch();
  }, Atom2.prototype.toString = function() {
    return this.name;
  }, Atom2;
}(), isAtom = createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  void 0 === onBecomeObservedHandler && (onBecomeObservedHandler = noop), void 0 === onBecomeUnobservedHandler && (onBecomeUnobservedHandler = noop);
  var atom = new Atom(name);
  return onBecomeObservedHandler !== noop && interceptHook("onBecomeObserved", atom, onBecomeObservedHandler), onBecomeUnobservedHandler !== noop && onBecomeUnobserved(atom, onBecomeUnobservedHandler), atom;
}
var comparer = { identity: function(a, b) {
  return a === b;
}, structural: function(a, b) {
  return deepEqual$1(a, b);
}, default: function(a, b) {
  return Object.is(a, b);
}, shallow: function(a, b) {
  return deepEqual$1(a, b, 1);
} }, extendStatics = function(d, b) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      b2.hasOwnProperty(p) && (d2[p] = b2[p]);
  }, extendStatics(d, b);
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++)
      for (var p in s = arguments[i])
        Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
    return t;
  }, __assign.apply(this, arguments);
};
function __values(o) {
  var m = "function" == typeof Symbol && o[Symbol.iterator], i = 0;
  return m ? m.call(o) : { next: function() {
    return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
  } };
}
function __read(o, n) {
  var m = "function" == typeof Symbol && o[Symbol.iterator];
  if (!m)
    return o;
  var r, e, i = m.call(o), ar = [];
  try {
    for (; (void 0 === n || n-- > 0) && !(r = i.next()).done; )
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      r && !r.done && (m = i.return) && m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
var mobxDidRunLazyInitializersSymbol = Symbol("mobx did run lazy initializers"), mobxPendingDecorators = Symbol("mobx pending decorators"), enumerableDescriptorCache = {}, nonEnumerableDescriptorCache = {};
function initializeInstance(target) {
  var e_1, _a2;
  if (true !== target[mobxDidRunLazyInitializersSymbol]) {
    var decorators = target[mobxPendingDecorators];
    if (decorators) {
      addHiddenProp(target, mobxDidRunLazyInitializersSymbol, true);
      var keys = __spread(Object.getOwnPropertySymbols(decorators), Object.keys(decorators));
      try {
        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
          var d = decorators[keys_1_1.value];
          d.propertyCreator(target, d.prop, d.descriptor, d.decoratorTarget, d.decoratorArguments);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          keys_1_1 && !keys_1_1.done && (_a2 = keys_1.return) && _a2.call(keys_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
  }
}
function createPropDecorator(propertyInitiallyEnumerable, propertyCreator) {
  return function() {
    var decoratorArguments, args, decorator = function(target, prop, descriptor, applyImmediately) {
      if (true === applyImmediately)
        return propertyCreator(target, prop, descriptor, target, decoratorArguments), null;
      if (!Object.prototype.hasOwnProperty.call(target, mobxPendingDecorators)) {
        var inheritedDecorators = target[mobxPendingDecorators];
        addHiddenProp(target, mobxPendingDecorators, __assign({}, inheritedDecorators));
      }
      return target[mobxPendingDecorators][prop] = { prop, propertyCreator, descriptor, decoratorTarget: target, decoratorArguments }, function(prop2, enumerable) {
        var cache = enumerable ? enumerableDescriptorCache : nonEnumerableDescriptorCache;
        return cache[prop2] || (cache[prop2] = { configurable: true, enumerable, get: function() {
          return initializeInstance(this), this[prop2];
        }, set: function(value) {
          initializeInstance(this), this[prop2] = value;
        } });
      }(prop, propertyInitiallyEnumerable);
    };
    return (2 === (args = arguments).length || 3 === args.length) && ("string" == typeof args[1] || "symbol" == typeof args[1]) || 4 === args.length && true === args[3] ? (decoratorArguments = EMPTY_ARRAY, decorator.apply(null, arguments)) : (decoratorArguments = Array.prototype.slice.call(arguments), decorator);
  };
}
function deepEnhancer(v, _, name) {
  return isObservable(v) ? v : Array.isArray(v) ? observable.array(v, { name }) : isPlainObject(v) ? observable.object(v, void 0, { name }) : isES6Map(v) ? observable.map(v, { name }) : isES6Set(v) ? observable.set(v, { name }) : v;
}
function referenceEnhancer(newValue) {
  return newValue;
}
function createDecoratorForEnhancer(enhancer) {
  invariant(enhancer);
  var decorator = createPropDecorator(true, function(target, propertyName, descriptor, _decoratorTarget, decoratorArgs) {
    var initialValue = descriptor ? descriptor.initializer ? descriptor.initializer.call(target) : descriptor.value : void 0;
    asObservableObject(target).addObservableProp(propertyName, initialValue, enhancer);
  }), res = ("undefined" != typeof process && process.env, decorator);
  return res.enhancer = enhancer, res;
}
var defaultCreateObservableOptions = { deep: true, name: void 0, defaultDecorator: void 0, proxy: true };
function asCreateObservableOptions(thing) {
  return null == thing ? defaultCreateObservableOptions : "string" == typeof thing ? { name: thing, deep: true, proxy: true } : thing;
}
Object.freeze(defaultCreateObservableOptions);
var deepDecorator = createDecoratorForEnhancer(deepEnhancer), shallowDecorator = createDecoratorForEnhancer(function(v, _, name) {
  return null == v || isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v) ? v : Array.isArray(v) ? observable.array(v, { name, deep: false }) : isPlainObject(v) ? observable.object(v, void 0, { name, deep: false }) : isES6Map(v) ? observable.map(v, { name, deep: false }) : isES6Set(v) ? observable.set(v, { name, deep: false }) : fail(false);
}), refDecorator = createDecoratorForEnhancer(referenceEnhancer), refStructDecorator = createDecoratorForEnhancer(function(v, oldValue, name) {
  return deepEqual$1(v, oldValue) ? oldValue : v;
});
function getEnhancerFromOptions(options) {
  return options.defaultDecorator ? options.defaultDecorator.enhancer : false === options.deep ? referenceEnhancer : deepEnhancer;
}
var observableFactories = { box: function(value, options) {
  arguments.length > 2 && incorrectlyUsedAsDecorator("box");
  var o = asCreateObservableOptions(options);
  return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
}, array: function(initialValues, options) {
  arguments.length > 2 && incorrectlyUsedAsDecorator("array");
  var o = asCreateObservableOptions(options);
  return function(initialValues2, enhancer, name, owned) {
    void 0 === name && (name = "ObservableArray@" + getNextId());
    void 0 === owned && (owned = false);
    var adm = new ObservableArrayAdministration(name, enhancer, owned);
    object = adm.values, propName = $mobx, value = adm, Object.defineProperty(object, propName, { enumerable: false, writable: false, configurable: true, value });
    var object, propName, value;
    var proxy = new Proxy(adm.values, arrayTraps);
    if (adm.proxy = proxy, initialValues2 && initialValues2.length) {
      var prev = allowStateChangesStart(true);
      adm.spliceWithArray(0, 0, initialValues2), allowStateChangesEnd(prev);
    }
    return proxy;
  }(initialValues, getEnhancerFromOptions(o), o.name);
}, map: function(initialValues, options) {
  arguments.length > 2 && incorrectlyUsedAsDecorator("map");
  var o = asCreateObservableOptions(options);
  return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
}, set: function(initialValues, options) {
  arguments.length > 2 && incorrectlyUsedAsDecorator("set");
  var o = asCreateObservableOptions(options);
  return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
}, object: function(props, decorators, options) {
  "string" == typeof arguments[1] && incorrectlyUsedAsDecorator("object");
  var o = asCreateObservableOptions(options);
  if (false === o.proxy)
    return extendObservable({}, props, decorators, o);
  var defaultDecorator = getDefaultDecoratorFromObjectOptions(o), proxy = function(base) {
    var proxy2 = new Proxy(base, objectProxyTraps);
    return base[$mobx].proxy = proxy2, proxy2;
  }(extendObservable({}, void 0, void 0, o));
  return extendObservableObjectWithProperties(proxy, props, decorators, defaultDecorator), proxy;
}, ref: refDecorator, shallow: shallowDecorator, deep: deepDecorator, struct: refStructDecorator }, observable = function(v, arg2, arg3) {
  if ("string" == typeof arguments[1] || "symbol" == typeof arguments[1])
    return deepDecorator.apply(null, arguments);
  if (isObservable(v))
    return v;
  var res = isPlainObject(v) ? observable.object(v, arg2, arg3) : Array.isArray(v) ? observable.array(v, arg2) : isES6Map(v) ? observable.map(v, arg2) : isES6Set(v) ? observable.set(v, arg2) : v;
  if (res !== v)
    return res;
  fail(false);
};
function incorrectlyUsedAsDecorator(methodName) {
  fail("Expected one or two arguments to observable." + methodName + ". Did you accidentally try to use observable." + methodName + " as decorator?");
}
Object.keys(observableFactories).forEach(function(name) {
  return observable[name] = observableFactories[name];
});
var IDerivationState, TraceMode, computedDecorator = createPropDecorator(false, function(instance, propertyName, descriptor, decoratorTarget, decoratorArgs) {
  var get = descriptor.get, set2 = descriptor.set, options = decoratorArgs[0] || {};
  asObservableObject(instance).addComputedProp(instance, propertyName, __assign({ get, set: set2, context: instance }, options));
}), computedStructDecorator = computedDecorator({ equals: comparer.structural }), computed = function(arg1, arg2, arg3) {
  if ("string" == typeof arg2)
    return computedDecorator.apply(null, arguments);
  if (null !== arg1 && "object" == typeof arg1 && 1 === arguments.length)
    return computedDecorator.apply(null, arguments);
  var opts = "object" == typeof arg2 ? arg2 : {};
  return opts.get = arg1, opts.set = "function" == typeof arg2 ? arg2 : opts.set, opts.name = opts.name || arg1.name || "", new ComputedValue(opts);
};
computed.struct = computedStructDecorator, function(IDerivationState2) {
  IDerivationState2[IDerivationState2.NOT_TRACKING = -1] = "NOT_TRACKING", IDerivationState2[IDerivationState2.UP_TO_DATE = 0] = "UP_TO_DATE", IDerivationState2[IDerivationState2.POSSIBLY_STALE = 1] = "POSSIBLY_STALE", IDerivationState2[IDerivationState2.STALE = 2] = "STALE";
}(IDerivationState || (IDerivationState = {})), function(TraceMode2) {
  TraceMode2[TraceMode2.NONE = 0] = "NONE", TraceMode2[TraceMode2.LOG = 1] = "LOG", TraceMode2[TraceMode2.BREAK = 2] = "BREAK";
}(TraceMode || (TraceMode = {}));
var CaughtException = function(cause) {
  this.cause = cause;
};
function isCaughtException(e) {
  return e instanceof CaughtException;
}
function shouldCompute(derivation) {
  switch (derivation.dependenciesState) {
    case IDerivationState.UP_TO_DATE:
      return false;
    case IDerivationState.NOT_TRACKING:
    case IDerivationState.STALE:
      return true;
    case IDerivationState.POSSIBLY_STALE:
      for (var prevAllowStateReads = allowStateReadsStart(true), prevUntracked = untrackedStart(), obs = derivation.observing, l = obs.length, i = 0; i < l; i++) {
        var obj = obs[i];
        if (isComputedValue(obj)) {
          if (globalState.disableErrorBoundaries)
            obj.get();
          else
            try {
              obj.get();
            } catch (e) {
              return untrackedEnd(prevUntracked), allowStateReadsEnd(prevAllowStateReads), true;
            }
          if (derivation.dependenciesState === IDerivationState.STALE)
            return untrackedEnd(prevUntracked), allowStateReadsEnd(prevAllowStateReads), true;
        }
      }
      return changeDependenciesStateTo0(derivation), untrackedEnd(prevUntracked), allowStateReadsEnd(prevAllowStateReads), false;
  }
}
function checkIfStateModificationsAreAllowed(atom) {
  var hasObservers = atom.observers.size > 0;
  globalState.computationDepth > 0 && hasObservers && fail(false), globalState.allowStateChanges || !hasObservers && "strict" !== globalState.enforceActions || fail(false);
}
function trackDerivedFunction(derivation, f, context) {
  var prevAllowStateReads = allowStateReadsStart(true);
  changeDependenciesStateTo0(derivation), derivation.newObserving = new Array(derivation.observing.length + 100), derivation.unboundDepsCount = 0, derivation.runId = ++globalState.runId;
  var result, prevTracking = globalState.trackingDerivation;
  if (globalState.trackingDerivation = derivation, true === globalState.disableErrorBoundaries)
    result = f.call(context);
  else
    try {
      result = f.call(context);
    } catch (e) {
      result = new CaughtException(e);
    }
  return globalState.trackingDerivation = prevTracking, function(derivation2) {
    for (var prevObserving = derivation2.observing, observing = derivation2.observing = derivation2.newObserving, lowestNewObservingDerivationState = IDerivationState.UP_TO_DATE, i0 = 0, l = derivation2.unboundDepsCount, i = 0; i < l; i++) {
      0 === (dep = observing[i]).diffValue && (dep.diffValue = 1, i0 !== i && (observing[i0] = dep), i0++), dep.dependenciesState > lowestNewObservingDerivationState && (lowestNewObservingDerivationState = dep.dependenciesState);
    }
    observing.length = i0, derivation2.newObserving = null, l = prevObserving.length;
    for (; l--; ) {
      0 === (dep = prevObserving[l]).diffValue && removeObserver(dep, derivation2), dep.diffValue = 0;
    }
    for (; i0--; ) {
      var dep;
      1 === (dep = observing[i0]).diffValue && (dep.diffValue = 0, addObserver(dep, derivation2));
    }
    lowestNewObservingDerivationState !== IDerivationState.UP_TO_DATE && (derivation2.dependenciesState = lowestNewObservingDerivationState, derivation2.onBecomeStale());
  }(derivation), allowStateReadsEnd(prevAllowStateReads), result;
}
function clearObserving(derivation) {
  var obs = derivation.observing;
  derivation.observing = [];
  for (var i = obs.length; i--; )
    removeObserver(obs[i], derivation);
  derivation.dependenciesState = IDerivationState.NOT_TRACKING;
}
function untracked(action2) {
  var prev = untrackedStart();
  try {
    return action2();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  return globalState.trackingDerivation = null, prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  return globalState.allowStateReads = allowStateReads, prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState !== IDerivationState.UP_TO_DATE) {
    derivation.dependenciesState = IDerivationState.UP_TO_DATE;
    for (var obs = derivation.observing, i = obs.length; i--; )
      obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;
  }
}
var currentActionId = 0, nextActionId = 1, functionNameDescriptor = Object.getOwnPropertyDescriptor(function() {
}, "name");
function createAction(actionName, fn, ref) {
  var res = function() {
    return executeAction$1(actionName, fn, ref || this, arguments);
  };
  return res.isMobxAction = true, res;
}
function executeAction$1(actionName, fn, scope, args) {
  var runInfo = function() {
    var notifySpy = false, startTime = 0, prevDerivation = untrackedStart();
    startBatch();
    var prevAllowStateChanges = allowStateChangesStart(true), prevAllowStateReads = allowStateReadsStart(true), runInfo2 = { prevDerivation, prevAllowStateChanges, prevAllowStateReads, notifySpy, startTime, actionId: nextActionId++, parentActionId: currentActionId };
    return currentActionId = runInfo2.actionId, runInfo2;
  }();
  try {
    return fn.apply(scope, args);
  } catch (err) {
    throw runInfo.error = err, err;
  } finally {
    !function(runInfo2) {
      currentActionId !== runInfo2.actionId && fail("invalid action stack. did you forget to finish an action?");
      currentActionId = runInfo2.parentActionId, void 0 !== runInfo2.error && (globalState.suppressReactionErrors = true);
      allowStateChangesEnd(runInfo2.prevAllowStateChanges), allowStateReadsEnd(runInfo2.prevAllowStateReads), endBatch(), untrackedEnd(runInfo2.prevDerivation), runInfo2.notifySpy && false;
      globalState.suppressReactionErrors = false;
    }(runInfo);
  }
}
function allowStateChangesStart(allowStateChanges) {
  var prev = globalState.allowStateChanges;
  return globalState.allowStateChanges = allowStateChanges, prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}
function allowStateChangesInsideComputed(func) {
  var res, prev = globalState.computationDepth;
  globalState.computationDepth = 0;
  try {
    res = func();
  } finally {
    globalState.computationDepth = prev;
  }
  return res;
}
functionNameDescriptor && functionNameDescriptor.configurable;
var ObservableValue = function(_super) {
  function ObservableValue2(value, enhancer, name, notifySpy, equals) {
    void 0 === name && (name = "ObservableValue@" + getNextId()), void 0 === notifySpy && (notifySpy = true), void 0 === equals && (equals = comparer.default);
    var _this = _super.call(this, name) || this;
    return _this.enhancer = enhancer, _this.name = name, _this.equals = equals, _this.hasUnreportedChange = false, _this.value = enhancer(value, void 0, name), _this;
  }
  return function(d, b) {
    function __() {
      this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
  }(ObservableValue2, _super), ObservableValue2.prototype.dehanceValue = function(value) {
    return void 0 !== this.dehancer ? this.dehancer(value) : value;
  }, ObservableValue2.prototype.set = function(newValue) {
    this.value;
    if ((newValue = this.prepareNewValue(newValue)) !== globalState.UNCHANGED) {
      false, this.setNewValue(newValue);
    }
  }, ObservableValue2.prototype.prepareNewValue = function(newValue) {
    if (checkIfStateModificationsAreAllowed(this), hasInterceptors(this)) {
      var change = interceptChange(this, { object: this, type: "update", newValue });
      if (!change)
        return globalState.UNCHANGED;
      newValue = change.newValue;
    }
    return newValue = this.enhancer(newValue, this.value, this.name), this.equals(this.value, newValue) ? globalState.UNCHANGED : newValue;
  }, ObservableValue2.prototype.setNewValue = function(newValue) {
    var oldValue = this.value;
    this.value = newValue, this.reportChanged(), hasListeners(this) && notifyListeners(this, { type: "update", object: this, newValue, oldValue });
  }, ObservableValue2.prototype.get = function() {
    return this.reportObserved(), this.dehanceValue(this.value);
  }, ObservableValue2.prototype.intercept = function(handler) {
    return registerInterceptor(this, handler);
  }, ObservableValue2.prototype.observe = function(listener, fireImmediately) {
    return fireImmediately && listener({ object: this, type: "update", newValue: this.value, oldValue: void 0 }), registerListener(this, listener);
  }, ObservableValue2.prototype.toJSON = function() {
    return this.get();
  }, ObservableValue2.prototype.toString = function() {
    return this.name + "[" + this.value + "]";
  }, ObservableValue2.prototype.valueOf = function() {
    return toPrimitive(this.get());
  }, ObservableValue2.prototype[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, ObservableValue2;
}(Atom);
createInstanceofPredicate("ObservableValue", ObservableValue);
var ComputedValue = function() {
  function ComputedValue2(options) {
    this.dependenciesState = IDerivationState.NOT_TRACKING, this.observing = [], this.newObserving = null, this.isBeingObserved = false, this.isPendingUnobservation = false, this.observers = /* @__PURE__ */ new Set(), this.diffValue = 0, this.runId = 0, this.lastAccessedBy = 0, this.lowestObserverState = IDerivationState.UP_TO_DATE, this.unboundDepsCount = 0, this.__mapid = "#" + getNextId(), this.value = new CaughtException(null), this.isComputing = false, this.isRunningSetter = false, this.isTracing = TraceMode.NONE, invariant(options.get, "missing option for computed: get"), this.derivation = options.get, this.name = options.name || "ComputedValue@" + getNextId(), options.set && (this.setter = createAction(this.name + "-setter", options.set)), this.equals = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer.default), this.scope = options.context, this.requiresReaction = !!options.requiresReaction, this.keepAlive = !!options.keepAlive;
  }
  return ComputedValue2.prototype.onBecomeStale = function() {
    !function(observable2) {
      if (observable2.lowestObserverState !== IDerivationState.UP_TO_DATE)
        return;
      observable2.lowestObserverState = IDerivationState.POSSIBLY_STALE, observable2.observers.forEach(function(d) {
        d.dependenciesState === IDerivationState.UP_TO_DATE && (d.dependenciesState = IDerivationState.POSSIBLY_STALE, d.isTracing !== TraceMode.NONE && logTraceInfo(d, observable2), d.onBecomeStale());
      });
    }(this);
  }, ComputedValue2.prototype.onBecomeObserved = function() {
    this.onBecomeObservedListeners && this.onBecomeObservedListeners.forEach(function(listener) {
      return listener();
    });
  }, ComputedValue2.prototype.onBecomeUnobserved = function() {
    this.onBecomeUnobservedListeners && this.onBecomeUnobservedListeners.forEach(function(listener) {
      return listener();
    });
  }, ComputedValue2.prototype.get = function() {
    this.isComputing && fail("Cycle detected in computation " + this.name + ": " + this.derivation), 0 !== globalState.inBatch || 0 !== this.observers.size || this.keepAlive ? (reportObserved(this), shouldCompute(this) && this.trackAndCompute() && function(observable2) {
      if (observable2.lowestObserverState === IDerivationState.STALE)
        return;
      observable2.lowestObserverState = IDerivationState.STALE, observable2.observers.forEach(function(d) {
        d.dependenciesState === IDerivationState.POSSIBLY_STALE ? d.dependenciesState = IDerivationState.STALE : d.dependenciesState === IDerivationState.UP_TO_DATE && (observable2.lowestObserverState = IDerivationState.UP_TO_DATE);
      });
    }(this)) : shouldCompute(this) && (this.warnAboutUntrackedRead(), startBatch(), this.value = this.computeValue(false), endBatch());
    var result = this.value;
    if (isCaughtException(result))
      throw result.cause;
    return result;
  }, ComputedValue2.prototype.peek = function() {
    var res = this.computeValue(false);
    if (isCaughtException(res))
      throw res.cause;
    return res;
  }, ComputedValue2.prototype.set = function(value) {
    if (this.setter) {
      invariant(!this.isRunningSetter, "The setter of computed value '" + this.name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?"), this.isRunningSetter = true;
      try {
        this.setter.call(this.scope, value);
      } finally {
        this.isRunningSetter = false;
      }
    } else
      invariant(false, false);
  }, ComputedValue2.prototype.trackAndCompute = function() {
    var oldValue = this.value, wasSuspended = this.dependenciesState === IDerivationState.NOT_TRACKING, newValue = this.computeValue(true), changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals(oldValue, newValue);
    return changed && (this.value = newValue), changed;
  }, ComputedValue2.prototype.computeValue = function(track) {
    var res;
    if (this.isComputing = true, globalState.computationDepth++, track)
      res = trackDerivedFunction(this, this.derivation, this.scope);
    else if (true === globalState.disableErrorBoundaries)
      res = this.derivation.call(this.scope);
    else
      try {
        res = this.derivation.call(this.scope);
      } catch (e) {
        res = new CaughtException(e);
      }
    return globalState.computationDepth--, this.isComputing = false, res;
  }, ComputedValue2.prototype.suspend = function() {
    this.keepAlive || (clearObserving(this), this.value = void 0);
  }, ComputedValue2.prototype.observe = function(listener, fireImmediately) {
    var _this = this, firstTime = true, prevValue = void 0;
    return autorun(function() {
      var newValue = _this.get();
      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({ type: "update", object: _this, newValue, oldValue: prevValue }), untrackedEnd(prevU);
      }
      firstTime = false, prevValue = newValue;
    });
  }, ComputedValue2.prototype.warnAboutUntrackedRead = function() {
  }, ComputedValue2.prototype.toJSON = function() {
    return this.get();
  }, ComputedValue2.prototype.toString = function() {
    return this.name + "[" + this.derivation.toString() + "]";
  }, ComputedValue2.prototype.valueOf = function() {
    return toPrimitive(this.get());
  }, ComputedValue2.prototype[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, ComputedValue2;
}(), isComputedValue = createInstanceofPredicate("ComputedValue", ComputedValue), MobXGlobals = function() {
  this.version = 5, this.UNCHANGED = {}, this.trackingDerivation = null, this.computationDepth = 0, this.runId = 0, this.mobxGuid = 0, this.inBatch = 0, this.pendingUnobservations = [], this.pendingReactions = [], this.isRunningReactions = false, this.allowStateChanges = true, this.allowStateReads = true, this.enforceActions = false, this.spyListeners = [], this.globalReactionErrorHandlers = [], this.computedRequiresReaction = false, this.reactionRequiresObservable = false, this.observableRequiresReaction = false, this.computedConfigurable = false, this.disableErrorBoundaries = false, this.suppressReactionErrors = false;
}, mockGlobal = {};
function getGlobal() {
  return "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : mockGlobal;
}
var canMergeGlobalState = true, isolateCalled = false, globalState = function() {
  var global2 = getGlobal();
  return global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals && (canMergeGlobalState = false), global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version && (canMergeGlobalState = false), canMergeGlobalState ? global2.__mobxGlobals ? (global2.__mobxInstanceCount += 1, global2.__mobxGlobals.UNCHANGED || (global2.__mobxGlobals.UNCHANGED = {}), global2.__mobxGlobals) : (global2.__mobxInstanceCount = 1, global2.__mobxGlobals = new MobXGlobals()) : (setTimeout(function() {
    isolateCalled || fail("There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`");
  }, 1), new MobXGlobals());
}();
function getGlobalState() {
  return globalState;
}
function addObserver(observable2, node) {
  observable2.observers.add(node), observable2.lowestObserverState > node.dependenciesState && (observable2.lowestObserverState = node.dependenciesState);
}
function removeObserver(observable2, node) {
  observable2.observers.delete(node), 0 === observable2.observers.size && queueForUnobservation(observable2);
}
function queueForUnobservation(observable2) {
  false === observable2.isPendingUnobservation && (observable2.isPendingUnobservation = true, globalState.pendingUnobservations.push(observable2));
}
function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (0 == --globalState.inBatch) {
    runReactions();
    for (var list = globalState.pendingUnobservations, i = 0; i < list.length; i++) {
      var observable2 = list[i];
      observable2.isPendingUnobservation = false, 0 === observable2.observers.size && (observable2.isBeingObserved && (observable2.isBeingObserved = false, observable2.onBecomeUnobserved()), observable2 instanceof ComputedValue && observable2.suspend());
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable2) {
  var derivation = globalState.trackingDerivation;
  return null !== derivation ? (derivation.runId !== observable2.lastAccessedBy && (observable2.lastAccessedBy = derivation.runId, derivation.newObserving[derivation.unboundDepsCount++] = observable2, observable2.isBeingObserved || (observable2.isBeingObserved = true, observable2.onBecomeObserved())), true) : (0 === observable2.observers.size && globalState.inBatch > 0 && queueForUnobservation(observable2), false);
}
function logTraceInfo(derivation, observable2) {
  if (console.log("[mobx.trace] '" + derivation.name + "' is invalidated due to a change in: '" + observable2.name + "'"), derivation.isTracing === TraceMode.BREAK) {
    var lines = [];
    printDepTree(nodeToDependencyTree(getAtom(derivation, property)), lines, 1), new Function("debugger;\n/*\nTracing '" + derivation.name + "'\n\nYou are entering this break point because derivation '" + derivation.name + "' is being traced and '" + observable2.name + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
  }
  var property;
}
function printDepTree(tree, lines, depth) {
  lines.length >= 1e3 ? lines.push("(and many more)") : (lines.push("" + new Array(depth).join("	") + tree.name), tree.dependencies && tree.dependencies.forEach(function(child) {
    return printDepTree(child, lines, depth + 1);
  }));
}
var Reaction = function() {
  function Reaction2(name, onInvalidate, errorHandler, requiresObservable) {
    void 0 === name && (name = "Reaction@" + getNextId()), void 0 === requiresObservable && (requiresObservable = false), this.name = name, this.onInvalidate = onInvalidate, this.errorHandler = errorHandler, this.requiresObservable = requiresObservable, this.observing = [], this.newObserving = [], this.dependenciesState = IDerivationState.NOT_TRACKING, this.diffValue = 0, this.runId = 0, this.unboundDepsCount = 0, this.__mapid = "#" + getNextId(), this.isDisposed = false, this._isScheduled = false, this._isTrackPending = false, this._isRunning = false, this.isTracing = TraceMode.NONE;
  }
  return Reaction2.prototype.onBecomeStale = function() {
    this.schedule();
  }, Reaction2.prototype.schedule = function() {
    this._isScheduled || (this._isScheduled = true, globalState.pendingReactions.push(this), runReactions());
  }, Reaction2.prototype.isScheduled = function() {
    return this._isScheduled;
  }, Reaction2.prototype.runReaction = function() {
    if (!this.isDisposed) {
      if (startBatch(), this._isScheduled = false, shouldCompute(this)) {
        this._isTrackPending = true;
        try {
          this.onInvalidate(), this._isTrackPending;
        } catch (e) {
          this.reportExceptionInDerivation(e);
        }
      }
      endBatch();
    }
  }, Reaction2.prototype.track = function(fn) {
    if (!this.isDisposed) {
      startBatch(), this._isRunning = true;
      var result = trackDerivedFunction(this, fn, void 0);
      this._isRunning = false, this._isTrackPending = false, this.isDisposed && clearObserving(this), isCaughtException(result) && this.reportExceptionInDerivation(result.cause), endBatch();
    }
  }, Reaction2.prototype.reportExceptionInDerivation = function(error) {
    var _this = this;
    if (this.errorHandler)
      this.errorHandler(error, this);
    else {
      if (globalState.disableErrorBoundaries)
        throw error;
      var message = "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'";
      globalState.suppressReactionErrors ? console.warn("[mobx] (error in reaction '" + this.name + "' suppressed, fix error of causing action below)") : console.error(message, error), globalState.globalReactionErrorHandlers.forEach(function(f) {
        return f(error, _this);
      });
    }
  }, Reaction2.prototype.dispose = function() {
    this.isDisposed || (this.isDisposed = true, this._isRunning || (startBatch(), clearObserving(this), endBatch()));
  }, Reaction2.prototype.getDisposer = function() {
    var r = this.dispose.bind(this);
    return r[$mobx] = this, r;
  }, Reaction2.prototype.toString = function() {
    return "Reaction[" + this.name + "]";
  }, Reaction2.prototype.trace = function(enterBreakPoint) {
    void 0 === enterBreakPoint && (enterBreakPoint = false), function() {
      for (var args = [], _i = 0; _i < arguments.length; _i++)
        args[_i] = arguments[_i];
      var enterBreakPoint2 = false;
      "boolean" == typeof args[args.length - 1] && (enterBreakPoint2 = args.pop());
      var derivation = function(args2) {
        switch (args2.length) {
          case 0:
            return globalState.trackingDerivation;
          case 1:
            return getAtom(args2[0]);
          case 2:
            return getAtom(args2[0], args2[1]);
        }
      }(args);
      if (!derivation)
        return fail(false);
      derivation.isTracing === TraceMode.NONE && console.log("[mobx.trace] '" + derivation.name + "' tracing enabled");
      derivation.isTracing = enterBreakPoint2 ? TraceMode.BREAK : TraceMode.LOG;
    }(this, enterBreakPoint);
  }, Reaction2;
}(), MAX_REACTION_ITERATIONS = 100, reactionScheduler = function(f) {
  return f();
};
function runReactions() {
  globalState.inBatch > 0 || globalState.isRunningReactions || reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = true;
  for (var allReactions = globalState.pendingReactions, iterations = 0; allReactions.length > 0; ) {
    ++iterations === MAX_REACTION_ITERATIONS && (console.error("Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations. Probably there is a cycle in the reactive function: " + allReactions[0]), allReactions.splice(0));
    for (var remainingReactions = allReactions.splice(0), i = 0, l = remainingReactions.length; i < l; i++)
      remainingReactions[i].runReaction();
  }
  globalState.isRunningReactions = false;
}
var isReaction = createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
  var baseScheduler = reactionScheduler;
  reactionScheduler = function(f) {
    return fn(function() {
      return baseScheduler(f);
    });
  };
}
function dontReassignFields() {
  fail(false);
}
function namedActionDecorator(name) {
  return function(target, prop, descriptor) {
    if (descriptor) {
      if (descriptor.value)
        return { value: createAction(name, descriptor.value), enumerable: false, configurable: true, writable: true };
      var initializer_1 = descriptor.initializer;
      return { enumerable: false, configurable: true, writable: true, initializer: function() {
        return createAction(name, initializer_1.call(this));
      } };
    }
    return (/* @__PURE__ */ function(name2) {
      return function(target2, prop2, descriptor2) {
        Object.defineProperty(target2, prop2, { configurable: true, enumerable: false, get: function() {
        }, set: function(value) {
          addHiddenProp(this, prop2, action(name2, value));
        } });
      };
    }(name)).apply(this, arguments);
  };
}
var action = function(arg1, arg2, arg3, arg4) {
  return 1 === arguments.length && "function" == typeof arg1 ? createAction(arg1.name || "<unnamed action>", arg1) : 2 === arguments.length && "function" == typeof arg2 ? createAction(arg1, arg2) : 1 === arguments.length && "string" == typeof arg1 ? namedActionDecorator(arg1) : true !== arg4 ? namedActionDecorator(arg2).apply(null, arguments) : void addHiddenProp(arg1, arg2, createAction(arg1.name || arg2, arg3.value, this));
};
function runInAction(arg1, arg2) {
  "string" == typeof arg1 || arg1.name;
  return executeAction$1(0, "function" == typeof arg1 ? arg1 : arg2, this, void 0);
}
function defineBoundAction(target, propertyName, fn) {
  addHiddenProp(target, propertyName, createAction(propertyName, fn.bind(target)));
}
function autorun(view, opts) {
  void 0 === opts && (opts = EMPTY_OBJECT);
  var reaction2, name = opts && opts.name || view.name || "Autorun@" + getNextId();
  if (!opts.scheduler && !opts.delay)
    reaction2 = new Reaction(name, function() {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  else {
    var scheduler_1 = createSchedulerFromOptions(opts), isScheduled_1 = false;
    reaction2 = new Reaction(name, function() {
      isScheduled_1 || (isScheduled_1 = true, scheduler_1(function() {
        isScheduled_1 = false, reaction2.isDisposed || reaction2.track(reactionRunner);
      }));
    }, opts.onError, opts.requiresObservable);
  }
  function reactionRunner() {
    view(reaction2);
  }
  return reaction2.schedule(), reaction2.getDisposer();
}
action.bound = function(target, propertyName, descriptor, applyToInstance) {
  return true === applyToInstance ? (defineBoundAction(target, propertyName, descriptor.value), null) : descriptor ? { configurable: true, enumerable: false, get: function() {
    return defineBoundAction(this, propertyName, descriptor.value || descriptor.initializer.call(this)), this[propertyName];
  }, set: dontReassignFields } : { enumerable: false, configurable: true, set: function(v) {
    defineBoundAction(this, propertyName, v);
  }, get: function() {
  } };
};
var run = function(f) {
  return f();
};
function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function(f) {
    return setTimeout(f, opts.delay);
  } : run;
}
function reaction(expression, effect, opts) {
  void 0 === opts && (opts = EMPTY_OBJECT);
  var errorHandler, baseFn, value, name = opts.name || "Reaction@" + getNextId(), effectAction = action(name, opts.onError ? (errorHandler = opts.onError, baseFn = effect, function() {
    try {
      return baseFn.apply(this, arguments);
    } catch (e) {
      errorHandler.call(this, e);
    }
  }) : effect), runSync = !opts.scheduler && !opts.delay, scheduler = createSchedulerFromOptions(opts), firstTime = true, isScheduled = false, equals = opts.compareStructural ? comparer.structural : opts.equals || comparer.default, r = new Reaction(name, function() {
    firstTime || runSync ? reactionRunner() : isScheduled || (isScheduled = true, scheduler(reactionRunner));
  }, opts.onError, opts.requiresObservable);
  function reactionRunner() {
    if (isScheduled = false, !r.isDisposed) {
      var changed = false;
      r.track(function() {
        var nextValue = expression(r);
        changed = firstTime || !equals(value, nextValue), value = nextValue;
      }), firstTime && opts.fireImmediately && effectAction(value, r), firstTime || true !== changed || effectAction(value, r), firstTime && (firstTime = false);
    }
  }
  return r.schedule(), r.getDisposer();
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook("onBecomeUnobserved", thing, arg2);
}
function interceptHook(hook, thing, arg2, arg3) {
  var atom = getAtom(thing), cb = arg2, listenersKey = hook + "Listeners";
  return atom[listenersKey] ? atom[listenersKey].add(cb) : atom[listenersKey] = /* @__PURE__ */ new Set([cb]), "function" != typeof atom[hook] ? fail(false) : function() {
    var hookListeners = atom[listenersKey];
    hookListeners && (hookListeners.delete(cb), 0 === hookListeners.size && delete atom[listenersKey]);
  };
}
function configure(options) {
  var enforceActions = options.enforceActions, computedRequiresReaction = options.computedRequiresReaction, computedConfigurable = options.computedConfigurable, disableErrorBoundaries = options.disableErrorBoundaries, reactionScheduler2 = options.reactionScheduler, reactionRequiresObservable = options.reactionRequiresObservable, observableRequiresReaction = options.observableRequiresReaction;
  if (true === options.isolateGlobalState && ((globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) && fail("isolateGlobalState should be called before MobX is running any reactions"), isolateCalled = true, canMergeGlobalState && (0 == --getGlobal().__mobxInstanceCount && (getGlobal().__mobxGlobals = void 0), globalState = new MobXGlobals())), void 0 !== enforceActions) {
    var ea = void 0;
    switch (enforceActions) {
      case true:
      case "observed":
        ea = true;
        break;
      case false:
      case "never":
        ea = false;
        break;
      case "strict":
      case "always":
        ea = "strict";
        break;
      default:
        fail("Invalid value for 'enforceActions': '" + enforceActions + "', expected 'never', 'always' or 'observed'");
    }
    globalState.enforceActions = ea, globalState.allowStateChanges = true !== ea && "strict" !== ea;
  }
  void 0 !== computedRequiresReaction && (globalState.computedRequiresReaction = !!computedRequiresReaction), void 0 !== reactionRequiresObservable && (globalState.reactionRequiresObservable = !!reactionRequiresObservable), void 0 !== observableRequiresReaction && (globalState.observableRequiresReaction = !!observableRequiresReaction, globalState.allowStateReads = !globalState.observableRequiresReaction), void 0 !== computedConfigurable && (globalState.computedConfigurable = !!computedConfigurable), void 0 !== disableErrorBoundaries && (true === disableErrorBoundaries && console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled."), globalState.disableErrorBoundaries = !!disableErrorBoundaries), reactionScheduler2 && setReactionScheduler(reactionScheduler2);
}
function extendObservable(target, properties, decorators, options) {
  var defaultDecorator = getDefaultDecoratorFromObjectOptions(options = asCreateObservableOptions(options));
  return initializeInstance(target), asObservableObject(target, options.name, defaultDecorator.enhancer), properties && extendObservableObjectWithProperties(target, properties, decorators, defaultDecorator), target;
}
function getDefaultDecoratorFromObjectOptions(options) {
  return options.defaultDecorator || (false === options.deep ? refDecorator : deepDecorator);
}
function extendObservableObjectWithProperties(target, properties, decorators, defaultDecorator) {
  var e_2, _b;
  startBatch();
  try {
    var keys = ownKeys(properties);
    try {
      for (var keys_2 = __values(keys), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {
        var key = keys_2_1.value, descriptor = Object.getOwnPropertyDescriptor(properties, key);
        0;
        var decorator = decorators && key in decorators ? decorators[key] : descriptor.get ? computedDecorator : defaultDecorator;
        0;
        var resultDescriptor = decorator(target, key, descriptor, true);
        resultDescriptor && Object.defineProperty(target, key, resultDescriptor);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        keys_2_1 && !keys_2_1.done && (_b = keys_2.return) && _b.call(keys_2);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
  } finally {
    endBatch();
  }
}
function nodeToDependencyTree(node) {
  var list, res, result = { name: node.name };
  return node.observing && node.observing.length > 0 && (result.dependencies = (list = node.observing, res = [], list.forEach(function(item) {
    -1 === res.indexOf(item) && res.push(item);
  }), res).map(nodeToDependencyTree)), result;
}
function isObservable(value) {
  return 1 !== arguments.length && fail(false), function(value2) {
    return null != value2 && (isObservableObject(value2) || !!value2[$mobx] || isAtom(value2) || isReaction(value2) || isComputedValue(value2));
  }(value);
}
function set(obj, key, value) {
  if (2 !== arguments.length || isObservableSet(obj))
    if (isObservableObject(obj)) {
      var adm = obj[$mobx];
      adm.values.get(key) ? adm.write(key, value) : adm.addObservableProp(key, value, adm.defaultEnhancer);
    } else if (isObservableMap(obj))
      obj.set(key, value);
    else if (isObservableSet(obj))
      obj.add(key);
    else {
      if (!isObservableArray(obj))
        return fail(false);
      "number" != typeof key && (key = parseInt(key, 10)), invariant(key >= 0, "Not a valid index: '" + key + "'"), startBatch(), key >= obj.length && (obj.length = key + 1), obj[key] = value, endBatch();
    }
  else {
    startBatch();
    var values_1 = key;
    try {
      for (var key_1 in values_1)
        set(obj, key_1, values_1[key_1]);
    } finally {
      endBatch();
    }
  }
}
function transaction(action2, thisArg) {
  void 0 === thisArg && (thisArg = void 0), startBatch();
  try {
    return action2.apply(thisArg);
  } finally {
    endBatch();
  }
}
function getAdm(target) {
  return target[$mobx];
}
function isPropertyKey(val) {
  return "string" == typeof val || "number" == typeof val || "symbol" == typeof val;
}
var objectProxyTraps = { has: function(target, name) {
  if (name === $mobx || "constructor" === name || name === mobxDidRunLazyInitializersSymbol)
    return true;
  var adm = getAdm(target);
  return isPropertyKey(name) ? adm.has(name) : name in target;
}, get: function(target, name) {
  if (name === $mobx || "constructor" === name || name === mobxDidRunLazyInitializersSymbol)
    return target[name];
  var adm = getAdm(target), observable2 = adm.values.get(name);
  if (observable2 instanceof Atom) {
    var result = observable2.get();
    return void 0 === result && adm.has(name), result;
  }
  return isPropertyKey(name) && adm.has(name), target[name];
}, set: function(target, name, value) {
  return !!isPropertyKey(name) && (set(target, name, value), true);
}, deleteProperty: function(target, name) {
  return !!isPropertyKey(name) && (getAdm(target).remove(name), true);
}, ownKeys: function(target) {
  return getAdm(target).keysAtom.reportObserved(), Reflect.ownKeys(target);
}, preventExtensions: function(target) {
  return fail("Dynamic observable objects cannot be frozen"), false;
} };
function hasInterceptors(interceptable) {
  return void 0 !== interceptable.interceptors && interceptable.interceptors.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors || (interceptable.interceptors = []);
  return interceptors.push(handler), once(function() {
    var idx = interceptors.indexOf(handler);
    -1 !== idx && interceptors.splice(idx, 1);
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();
  try {
    for (var interceptors = __spread(interceptable.interceptors || []), i = 0, l = interceptors.length; i < l && (invariant(!(change = interceptors[i](change)) || change.type, "Intercept handlers should return nothing or a change object"), change); i++)
      ;
    return change;
  } finally {
    untrackedEnd(prevU);
  }
}
function hasListeners(listenable) {
  return void 0 !== listenable.changeListeners && listenable.changeListeners.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners || (listenable.changeListeners = []);
  return listeners.push(handler), once(function() {
    var idx = listeners.indexOf(handler);
    -1 !== idx && listeners.splice(idx, 1);
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart(), listeners = listenable.changeListeners;
  if (listeners) {
    for (var i = 0, l = (listeners = listeners.slice()).length; i < l; i++)
      listeners[i](change);
    untrackedEnd(prevU);
  }
}
var arrayTraps = { get: function(target, name) {
  return name === $mobx ? target[$mobx] : "length" === name ? target[$mobx].getArrayLength() : "number" == typeof name ? arrayExtensions.get.call(target, name) : "string" != typeof name || isNaN(name) ? arrayExtensions.hasOwnProperty(name) ? arrayExtensions[name] : target[name] : arrayExtensions.get.call(target, parseInt(name));
}, set: function(target, name, value) {
  return "length" === name && target[$mobx].setArrayLength(value), "number" == typeof name && arrayExtensions.set.call(target, name, value), "symbol" == typeof name || isNaN(name) ? target[name] = value : arrayExtensions.set.call(target, parseInt(name), value), true;
}, preventExtensions: function(target) {
  return fail("Observable arrays cannot be frozen"), false;
} };
var ObservableArrayAdministration = function() {
  function ObservableArrayAdministration2(name, enhancer, owned) {
    this.owned = owned, this.values = [], this.proxy = void 0, this.lastKnownLength = 0, this.atom = new Atom(name || "ObservableArray@" + getNextId()), this.enhancer = function(newV, oldV) {
      return enhancer(newV, oldV, name + "[..]");
    };
  }
  return ObservableArrayAdministration2.prototype.dehanceValue = function(value) {
    return void 0 !== this.dehancer ? this.dehancer(value) : value;
  }, ObservableArrayAdministration2.prototype.dehanceValues = function(values) {
    return void 0 !== this.dehancer && values.length > 0 ? values.map(this.dehancer) : values;
  }, ObservableArrayAdministration2.prototype.intercept = function(handler) {
    return registerInterceptor(this, handler);
  }, ObservableArrayAdministration2.prototype.observe = function(listener, fireImmediately) {
    return void 0 === fireImmediately && (fireImmediately = false), fireImmediately && listener({ object: this.proxy, type: "splice", index: 0, added: this.values.slice(), addedCount: this.values.length, removed: [], removedCount: 0 }), registerListener(this, listener);
  }, ObservableArrayAdministration2.prototype.getArrayLength = function() {
    return this.atom.reportObserved(), this.values.length;
  }, ObservableArrayAdministration2.prototype.setArrayLength = function(newLength) {
    if ("number" != typeof newLength || newLength < 0)
      throw new Error("[mobx.array] Out of range: " + newLength);
    var currentLength = this.values.length;
    if (newLength !== currentLength)
      if (newLength > currentLength) {
        for (var newItems = new Array(newLength - currentLength), i = 0; i < newLength - currentLength; i++)
          newItems[i] = void 0;
        this.spliceWithArray(currentLength, 0, newItems);
      } else
        this.spliceWithArray(newLength, currentLength - newLength);
  }, ObservableArrayAdministration2.prototype.updateArrayLength = function(oldLength, delta) {
    if (oldLength !== this.lastKnownLength)
      throw new Error("[mobx] Modification exception: the internal structure of an observable array was changed.");
    this.lastKnownLength += delta;
  }, ObservableArrayAdministration2.prototype.spliceWithArray = function(index, deleteCount, newItems) {
    var _this = this;
    checkIfStateModificationsAreAllowed(this.atom);
    var length = this.values.length;
    if (void 0 === index ? index = 0 : index > length ? index = length : index < 0 && (index = Math.max(0, length + index)), deleteCount = 1 === arguments.length ? length - index : null == deleteCount ? 0 : Math.max(0, Math.min(deleteCount, length - index)), void 0 === newItems && (newItems = EMPTY_ARRAY), hasInterceptors(this)) {
      var change = interceptChange(this, { object: this.proxy, type: "splice", index, removedCount: deleteCount, added: newItems });
      if (!change)
        return EMPTY_ARRAY;
      deleteCount = change.removedCount, newItems = change.added;
    }
    newItems = 0 === newItems.length ? newItems : newItems.map(function(v) {
      return _this.enhancer(v, void 0);
    });
    var res = this.spliceItemsIntoValues(index, deleteCount, newItems);
    return 0 === deleteCount && 0 === newItems.length || this.notifyArraySplice(index, newItems, res), this.dehanceValues(res);
  }, ObservableArrayAdministration2.prototype.spliceItemsIntoValues = function(index, deleteCount, newItems) {
    var _a2;
    if (newItems.length < 1e4)
      return (_a2 = this.values).splice.apply(_a2, __spread([index, deleteCount], newItems));
    var res = this.values.slice(index, index + deleteCount);
    return this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount)), res;
  }, ObservableArrayAdministration2.prototype.notifyArrayChildUpdate = function(index, newValue, oldValue) {
    var notifySpy = !this.owned && false, notify = hasListeners(this), change = notify || notifySpy ? { object: this.proxy, type: "update", index, newValue, oldValue } : null;
    this.atom.reportChanged(), notify && notifyListeners(this, change);
  }, ObservableArrayAdministration2.prototype.notifyArraySplice = function(index, added, removed) {
    var notifySpy = !this.owned && false, notify = hasListeners(this), change = notify || notifySpy ? { object: this.proxy, type: "splice", index, removed, added, removedCount: removed.length, addedCount: added.length } : null;
    this.atom.reportChanged(), notify && notifyListeners(this, change);
  }, ObservableArrayAdministration2;
}(), arrayExtensions = { intercept: function(handler) {
  return this[$mobx].intercept(handler);
}, observe: function(listener, fireImmediately) {
  return void 0 === fireImmediately && (fireImmediately = false), this[$mobx].observe(listener, fireImmediately);
}, clear: function() {
  return this.splice(0);
}, replace: function(newItems) {
  var adm = this[$mobx];
  return adm.spliceWithArray(0, adm.values.length, newItems);
}, toJS: function() {
  return this.slice();
}, toJSON: function() {
  return this.toJS();
}, splice: function(index, deleteCount) {
  for (var newItems = [], _i = 2; _i < arguments.length; _i++)
    newItems[_i - 2] = arguments[_i];
  var adm = this[$mobx];
  switch (arguments.length) {
    case 0:
      return [];
    case 1:
      return adm.spliceWithArray(index);
    case 2:
      return adm.spliceWithArray(index, deleteCount);
  }
  return adm.spliceWithArray(index, deleteCount, newItems);
}, spliceWithArray: function(index, deleteCount, newItems) {
  return this[$mobx].spliceWithArray(index, deleteCount, newItems);
}, push: function() {
  for (var items = [], _i = 0; _i < arguments.length; _i++)
    items[_i] = arguments[_i];
  var adm = this[$mobx];
  return adm.spliceWithArray(adm.values.length, 0, items), adm.values.length;
}, pop: function() {
  return this.splice(Math.max(this[$mobx].values.length - 1, 0), 1)[0];
}, shift: function() {
  return this.splice(0, 1)[0];
}, unshift: function() {
  for (var items = [], _i = 0; _i < arguments.length; _i++)
    items[_i] = arguments[_i];
  var adm = this[$mobx];
  return adm.spliceWithArray(0, 0, items), adm.values.length;
}, reverse: function() {
  var clone = this.slice();
  return clone.reverse.apply(clone, arguments);
}, sort: function(compareFn) {
  var clone = this.slice();
  return clone.sort.apply(clone, arguments);
}, remove: function(value) {
  var adm = this[$mobx], idx = adm.dehanceValues(adm.values).indexOf(value);
  return idx > -1 && (this.splice(idx, 1), true);
}, get: function(index) {
  var adm = this[$mobx];
  if (adm) {
    if (index < adm.values.length)
      return adm.atom.reportObserved(), adm.dehanceValue(adm.values[index]);
    console.warn("[mobx.array] Attempt to read an array index (" + index + ") that is out of bounds (" + adm.values.length + "). Please check length first. Out of bound indices will not be tracked by MobX");
  }
}, set: function(index, newValue) {
  var adm = this[$mobx], values = adm.values;
  if (index < values.length) {
    checkIfStateModificationsAreAllowed(adm.atom);
    var oldValue = values[index];
    if (hasInterceptors(adm)) {
      var change = interceptChange(adm, { type: "update", object: adm.proxy, index, newValue });
      if (!change)
        return;
      newValue = change.newValue;
    }
    (newValue = adm.enhancer(newValue, oldValue)) !== oldValue && (values[index] = newValue, adm.notifyArrayChildUpdate(index, newValue, oldValue));
  } else {
    if (index !== values.length)
      throw new Error("[mobx.array] Index out of bounds, " + index + " is larger than " + values.length);
    adm.spliceWithArray(index, 0, [newValue]);
  }
} };
["concat", "flat", "includes", "indexOf", "join", "lastIndexOf", "slice", "toString", "toLocaleString"].forEach(function(funcName) {
  "function" == typeof Array.prototype[funcName] && (arrayExtensions[funcName] = function() {
    var adm = this[$mobx];
    adm.atom.reportObserved();
    var dehancedValues = adm.dehanceValues(adm.values);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  });
}), ["every", "filter", "find", "findIndex", "flatMap", "forEach", "map", "some"].forEach(function(funcName) {
  "function" == typeof Array.prototype[funcName] && (arrayExtensions[funcName] = function(callback, thisArg) {
    var _this = this, adm = this[$mobx];
    return adm.atom.reportObserved(), adm.dehanceValues(adm.values)[funcName](function(element, index) {
      return callback.call(thisArg, element, index, _this);
    }, thisArg);
  });
}), ["reduce", "reduceRight"].forEach(function(funcName) {
  arrayExtensions[funcName] = function() {
    var _this = this, adm = this[$mobx];
    adm.atom.reportObserved();
    var callback = arguments[0];
    return arguments[0] = function(accumulator, currentValue, index) {
      return currentValue = adm.dehanceValue(currentValue), callback(accumulator, currentValue, index, _this);
    }, adm.values[funcName].apply(adm.values, arguments);
  };
});
var _a$1, isObservableArrayAdministration = createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
}
var _a$1$1, ObservableMapMarker = {}, ObservableMap = function() {
  function ObservableMap2(initialData, enhancer, name) {
    if (void 0 === enhancer && (enhancer = deepEnhancer), void 0 === name && (name = "ObservableMap@" + getNextId()), this.enhancer = enhancer, this.name = name, this[_a$1] = ObservableMapMarker, this._keysAtom = createAtom(this.name + ".keys()"), this[Symbol.toStringTag] = "Map", "function" != typeof Map)
      throw new Error("mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js");
    this._data = /* @__PURE__ */ new Map(), this._hasMap = /* @__PURE__ */ new Map(), this.merge(initialData);
  }
  return ObservableMap2.prototype._has = function(key) {
    return this._data.has(key);
  }, ObservableMap2.prototype.has = function(key) {
    var _this = this;
    if (!globalState.trackingDerivation)
      return this._has(key);
    var entry = this._hasMap.get(key);
    if (!entry) {
      var newEntry = entry = new ObservableValue(this._has(key), referenceEnhancer, this.name + "." + stringifyKey(key) + "?", false);
      this._hasMap.set(key, newEntry), onBecomeUnobserved(newEntry, function() {
        return _this._hasMap.delete(key);
      });
    }
    return entry.get();
  }, ObservableMap2.prototype.set = function(key, value) {
    var hasKey = this._has(key);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, { type: hasKey ? "update" : "add", object: this, newValue: value, name: key });
      if (!change)
        return this;
      value = change.newValue;
    }
    return hasKey ? this._updateValue(key, value) : this._addValue(key, value), this;
  }, ObservableMap2.prototype.delete = function(key) {
    var _this = this;
    if ((checkIfStateModificationsAreAllowed(this._keysAtom), hasInterceptors(this)) && !(change = interceptChange(this, { type: "delete", object: this, name: key })))
      return false;
    if (this._has(key)) {
      var notify = hasListeners(this), change = notify ? { type: "delete", object: this, oldValue: this._data.get(key).value, name: key } : null;
      return transaction(function() {
        _this._keysAtom.reportChanged(), _this._updateHasMapEntry(key, false), _this._data.get(key).setNewValue(void 0), _this._data.delete(key);
      }), notify && notifyListeners(this, change), true;
    }
    return false;
  }, ObservableMap2.prototype._updateHasMapEntry = function(key, value) {
    var entry = this._hasMap.get(key);
    entry && entry.setNewValue(value);
  }, ObservableMap2.prototype._updateValue = function(key, newValue) {
    var observable2 = this._data.get(key);
    if ((newValue = observable2.prepareNewValue(newValue)) !== globalState.UNCHANGED) {
      var notify = hasListeners(this), change = notify ? { type: "update", object: this, oldValue: observable2.value, name: key, newValue } : null;
      false, observable2.setNewValue(newValue), notify && notifyListeners(this, change);
    }
  }, ObservableMap2.prototype._addValue = function(key, newValue) {
    var _this = this;
    checkIfStateModificationsAreAllowed(this._keysAtom), transaction(function() {
      var observable2 = new ObservableValue(newValue, _this.enhancer, _this.name + "." + stringifyKey(key), false);
      _this._data.set(key, observable2), newValue = observable2.value, _this._updateHasMapEntry(key, true), _this._keysAtom.reportChanged();
    });
    var notify = hasListeners(this);
    notify && notifyListeners(this, notify ? { type: "add", object: this, name: key, newValue } : null);
  }, ObservableMap2.prototype.get = function(key) {
    return this.has(key) ? this.dehanceValue(this._data.get(key).get()) : this.dehanceValue(void 0);
  }, ObservableMap2.prototype.dehanceValue = function(value) {
    return void 0 !== this.dehancer ? this.dehancer(value) : value;
  }, ObservableMap2.prototype.keys = function() {
    return this._keysAtom.reportObserved(), this._data.keys();
  }, ObservableMap2.prototype.values = function() {
    var self2 = this, keys = this.keys();
    return makeIterable({ next: function() {
      var _b = keys.next(), done = _b.done, value = _b.value;
      return { done, value: done ? void 0 : self2.get(value) };
    } });
  }, ObservableMap2.prototype.entries = function() {
    var self2 = this, keys = this.keys();
    return makeIterable({ next: function() {
      var _b = keys.next(), done = _b.done, value = _b.value;
      return { done, value: done ? void 0 : [value, self2.get(value)] };
    } });
  }, ObservableMap2.prototype[_a$1 = $mobx, Symbol.iterator] = function() {
    return this.entries();
  }, ObservableMap2.prototype.forEach = function(callback, thisArg) {
    var e_1, _b;
    try {
      for (var _c = __values(this), _d = _c.next(); !_d.done; _d = _c.next()) {
        var _e = __read(_d.value, 2), key = _e[0], value = _e[1];
        callback.call(thisArg, value, key, this);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        _d && !_d.done && (_b = _c.return) && _b.call(_c);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  }, ObservableMap2.prototype.merge = function(other) {
    var _this = this;
    return isObservableMap(other) && (other = other.toJS()), transaction(function() {
      var prev = allowStateChangesStart(true);
      try {
        isPlainObject(other) ? function(object) {
          var enumerables = /* @__PURE__ */ new Set();
          for (var key in object)
            enumerables.add(key);
          return Object.getOwnPropertySymbols(object).forEach(function(k) {
            Object.getOwnPropertyDescriptor(object, k).enumerable && enumerables.add(k);
          }), Array.from(enumerables);
        }(other).forEach(function(key) {
          return _this.set(key, other[key]);
        }) : Array.isArray(other) ? other.forEach(function(_b) {
          var _c = __read(_b, 2), key = _c[0], value = _c[1];
          return _this.set(key, value);
        }) : isES6Map(other) ? (other.constructor !== Map && fail("Cannot initialize from classes that inherit from Map: " + other.constructor.name), other.forEach(function(value, key) {
          return _this.set(key, value);
        })) : null != other && fail("Cannot initialize map from " + other);
      } finally {
        allowStateChangesEnd(prev);
      }
    }), this;
  }, ObservableMap2.prototype.clear = function() {
    var _this = this;
    transaction(function() {
      untracked(function() {
        var e_2, _b;
        try {
          for (var _c = __values(_this.keys()), _d = _c.next(); !_d.done; _d = _c.next()) {
            var key = _d.value;
            _this.delete(key);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            _d && !_d.done && (_b = _c.return) && _b.call(_c);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      });
    });
  }, ObservableMap2.prototype.replace = function(values) {
    var _this = this;
    return transaction(function() {
      var e_3, _b, e_4, _c, replacementMap = function(dataStructure) {
        if (isES6Map(dataStructure) || isObservableMap(dataStructure))
          return dataStructure;
        if (Array.isArray(dataStructure))
          return new Map(dataStructure);
        if (isPlainObject(dataStructure)) {
          var map = /* @__PURE__ */ new Map();
          for (var key2 in dataStructure)
            map.set(key2, dataStructure[key2]);
          return map;
        }
        return fail("Cannot convert to map from '" + dataStructure + "'");
      }(values), orderedData = /* @__PURE__ */ new Map(), keysReportChangedCalled = false;
      try {
        for (var _d = __values(_this._data.keys()), _e = _d.next(); !_e.done; _e = _d.next()) {
          var key = _e.value;
          if (!replacementMap.has(key))
            if (_this.delete(key))
              keysReportChangedCalled = true;
            else {
              var value = _this._data.get(key);
              orderedData.set(key, value);
            }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          _e && !_e.done && (_b = _d.return) && _b.call(_d);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      try {
        for (var _f = __values(replacementMap.entries()), _g = _f.next(); !_g.done; _g = _f.next()) {
          var _h = __read(_g.value, 2), keyExisted = (key = _h[0], value = _h[1], _this._data.has(key));
          if (_this.set(key, value), _this._data.has(key)) {
            var value_1 = _this._data.get(key);
            orderedData.set(key, value_1), keyExisted || (keysReportChangedCalled = true);
          }
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          _g && !_g.done && (_c = _f.return) && _c.call(_f);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
      if (!keysReportChangedCalled)
        if (_this._data.size !== orderedData.size)
          _this._keysAtom.reportChanged();
        else
          for (var iter1 = _this._data.keys(), iter2 = orderedData.keys(), next1 = iter1.next(), next2 = iter2.next(); !next1.done; ) {
            if (next1.value !== next2.value) {
              _this._keysAtom.reportChanged();
              break;
            }
            next1 = iter1.next(), next2 = iter2.next();
          }
      _this._data = orderedData;
    }), this;
  }, Object.defineProperty(ObservableMap2.prototype, "size", { get: function() {
    return this._keysAtom.reportObserved(), this._data.size;
  }, enumerable: true, configurable: true }), ObservableMap2.prototype.toPOJO = function() {
    var e_5, _b, res = {};
    try {
      for (var _c = __values(this), _d = _c.next(); !_d.done; _d = _c.next()) {
        var _e = __read(_d.value, 2), key = _e[0], value = _e[1];
        res["symbol" == typeof key ? key : stringifyKey(key)] = value;
      }
    } catch (e_5_1) {
      e_5 = { error: e_5_1 };
    } finally {
      try {
        _d && !_d.done && (_b = _c.return) && _b.call(_c);
      } finally {
        if (e_5)
          throw e_5.error;
      }
    }
    return res;
  }, ObservableMap2.prototype.toJS = function() {
    return new Map(this);
  }, ObservableMap2.prototype.toJSON = function() {
    return this.toPOJO();
  }, ObservableMap2.prototype.toString = function() {
    var _this = this;
    return this.name + "[{ " + Array.from(this.keys()).map(function(key) {
      return stringifyKey(key) + ": " + _this.get(key);
    }).join(", ") + " }]";
  }, ObservableMap2.prototype.observe = function(listener, fireImmediately) {
    return registerListener(this, listener);
  }, ObservableMap2.prototype.intercept = function(handler) {
    return registerInterceptor(this, handler);
  }, ObservableMap2;
}(), isObservableMap = createInstanceofPredicate("ObservableMap", ObservableMap), ObservableSetMarker = {}, ObservableSet = function() {
  function ObservableSet2(initialData, enhancer, name) {
    if (void 0 === enhancer && (enhancer = deepEnhancer), void 0 === name && (name = "ObservableSet@" + getNextId()), this.name = name, this[_a$1$1] = ObservableSetMarker, this._data = /* @__PURE__ */ new Set(), this._atom = createAtom(this.name), this[Symbol.toStringTag] = "Set", "function" != typeof Set)
      throw new Error("mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js");
    this.enhancer = function(newV, oldV) {
      return enhancer(newV, oldV, name);
    }, initialData && this.replace(initialData);
  }
  return ObservableSet2.prototype.dehanceValue = function(value) {
    return void 0 !== this.dehancer ? this.dehancer(value) : value;
  }, ObservableSet2.prototype.clear = function() {
    var _this = this;
    transaction(function() {
      untracked(function() {
        var e_1, _b;
        try {
          for (var _c = __values(_this._data.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
            var value = _d.value;
            _this.delete(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            _d && !_d.done && (_b = _c.return) && _b.call(_c);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    });
  }, ObservableSet2.prototype.forEach = function(callbackFn, thisArg) {
    var e_2, _b;
    try {
      for (var _c = __values(this), _d = _c.next(); !_d.done; _d = _c.next()) {
        var value = _d.value;
        callbackFn.call(thisArg, value, value, this);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        _d && !_d.done && (_b = _c.return) && _b.call(_c);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
  }, Object.defineProperty(ObservableSet2.prototype, "size", { get: function() {
    return this._atom.reportObserved(), this._data.size;
  }, enumerable: true, configurable: true }), ObservableSet2.prototype.add = function(value) {
    var _this = this;
    if ((checkIfStateModificationsAreAllowed(this._atom), hasInterceptors(this)) && !(change = interceptChange(this, { type: "add", object: this, newValue: value })))
      return this;
    if (!this.has(value)) {
      transaction(function() {
        _this._data.add(_this.enhancer(value, void 0)), _this._atom.reportChanged();
      });
      var notify = hasListeners(this), change = notify ? { type: "add", object: this, newValue: value } : null;
      notify && notifyListeners(this, change);
    }
    return this;
  }, ObservableSet2.prototype.delete = function(value) {
    var _this = this;
    if (hasInterceptors(this) && !(change = interceptChange(this, { type: "delete", object: this, oldValue: value })))
      return false;
    if (this.has(value)) {
      var notify = hasListeners(this), change = notify ? { type: "delete", object: this, oldValue: value } : null;
      return transaction(function() {
        _this._atom.reportChanged(), _this._data.delete(value);
      }), notify && notifyListeners(this, change), true;
    }
    return false;
  }, ObservableSet2.prototype.has = function(value) {
    return this._atom.reportObserved(), this._data.has(this.dehanceValue(value));
  }, ObservableSet2.prototype.entries = function() {
    var nextIndex = 0, keys = Array.from(this.keys()), values = Array.from(this.values());
    return makeIterable({ next: function() {
      var index = nextIndex;
      return nextIndex += 1, index < values.length ? { value: [keys[index], values[index]], done: false } : { done: true };
    } });
  }, ObservableSet2.prototype.keys = function() {
    return this.values();
  }, ObservableSet2.prototype.values = function() {
    this._atom.reportObserved();
    var self2 = this, nextIndex = 0, observableValues = Array.from(this._data.values());
    return makeIterable({ next: function() {
      return nextIndex < observableValues.length ? { value: self2.dehanceValue(observableValues[nextIndex++]), done: false } : { done: true };
    } });
  }, ObservableSet2.prototype.replace = function(other) {
    var _this = this;
    return isObservableSet(other) && (other = other.toJS()), transaction(function() {
      var prev = allowStateChangesStart(true);
      try {
        Array.isArray(other) || isES6Set(other) ? (_this.clear(), other.forEach(function(value) {
          return _this.add(value);
        })) : null != other && fail("Cannot initialize set from " + other);
      } finally {
        allowStateChangesEnd(prev);
      }
    }), this;
  }, ObservableSet2.prototype.observe = function(listener, fireImmediately) {
    return registerListener(this, listener);
  }, ObservableSet2.prototype.intercept = function(handler) {
    return registerInterceptor(this, handler);
  }, ObservableSet2.prototype.toJS = function() {
    return new Set(this);
  }, ObservableSet2.prototype.toString = function() {
    return this.name + "[ " + Array.from(this).join(", ") + " ]";
  }, ObservableSet2.prototype[_a$1$1 = $mobx, Symbol.iterator] = function() {
    return this.values();
  }, ObservableSet2;
}(), isObservableSet = createInstanceofPredicate("ObservableSet", ObservableSet), ObservableObjectAdministration = function() {
  function ObservableObjectAdministration2(target, values, name, defaultEnhancer) {
    void 0 === values && (values = /* @__PURE__ */ new Map()), this.target = target, this.values = values, this.name = name, this.defaultEnhancer = defaultEnhancer, this.keysAtom = new Atom(name + ".keys");
  }
  return ObservableObjectAdministration2.prototype.read = function(key) {
    return this.values.get(key).get();
  }, ObservableObjectAdministration2.prototype.write = function(key, newValue) {
    var instance = this.target, observable2 = this.values.get(key);
    if (observable2 instanceof ComputedValue)
      observable2.set(newValue);
    else {
      if (hasInterceptors(this)) {
        if (!(change = interceptChange(this, { type: "update", object: this.proxy || instance, name: key, newValue })))
          return;
        newValue = change.newValue;
      }
      if ((newValue = observable2.prepareNewValue(newValue)) !== globalState.UNCHANGED) {
        var notify = hasListeners(this), change = notify ? { type: "update", object: this.proxy || instance, oldValue: observable2.value, name: key, newValue } : null;
        false, observable2.setNewValue(newValue), notify && notifyListeners(this, change);
      }
    }
  }, ObservableObjectAdministration2.prototype.has = function(key) {
    var map = this.pendingKeys || (this.pendingKeys = /* @__PURE__ */ new Map()), entry = map.get(key);
    if (entry)
      return entry.get();
    var exists = !!this.values.get(key);
    return entry = new ObservableValue(exists, referenceEnhancer, this.name + "." + stringifyKey(key) + "?", false), map.set(key, entry), entry.get();
  }, ObservableObjectAdministration2.prototype.addObservableProp = function(propName, newValue, enhancer) {
    void 0 === enhancer && (enhancer = this.defaultEnhancer);
    var target = this.target;
    if (hasInterceptors(this)) {
      var change = interceptChange(this, { object: this.proxy || target, name: propName, type: "add", newValue });
      if (!change)
        return;
      newValue = change.newValue;
    }
    var observable2 = new ObservableValue(newValue, enhancer, this.name + "." + stringifyKey(propName), false);
    this.values.set(propName, observable2), newValue = observable2.value, Object.defineProperty(target, propName, function(propName2) {
      return observablePropertyConfigs[propName2] || (observablePropertyConfigs[propName2] = { configurable: true, enumerable: true, get: function() {
        return this[$mobx].read(propName2);
      }, set: function(v) {
        this[$mobx].write(propName2, v);
      } });
    }(propName)), this.notifyPropertyAddition(propName, newValue);
  }, ObservableObjectAdministration2.prototype.addComputedProp = function(propertyOwner, propName, options) {
    var object, prop, descriptor, target = this.target;
    options.name = options.name || this.name + "." + stringifyKey(propName), this.values.set(propName, new ComputedValue(options)), (propertyOwner === target || (object = propertyOwner, prop = propName, !(descriptor = Object.getOwnPropertyDescriptor(object, prop)) || false !== descriptor.configurable && false !== descriptor.writable)) && Object.defineProperty(propertyOwner, propName, function(propName2) {
      return computedPropertyConfigs[propName2] || (computedPropertyConfigs[propName2] = { configurable: globalState.computedConfigurable, enumerable: false, get: function() {
        return getAdministrationForComputedPropOwner(this).read(propName2);
      }, set: function(v) {
        getAdministrationForComputedPropOwner(this).write(propName2, v);
      } });
    }(propName));
  }, ObservableObjectAdministration2.prototype.remove = function(key) {
    if (this.values.has(key)) {
      var target = this.target;
      if (hasInterceptors(this)) {
        if (!(change = interceptChange(this, { object: this.proxy || target, name: key, type: "remove" })))
          return;
      }
      try {
        startBatch();
        var notify = hasListeners(this), oldObservable = this.values.get(key), oldValue = oldObservable && oldObservable.get();
        if (oldObservable && oldObservable.set(void 0), this.keysAtom.reportChanged(), this.values.delete(key), this.pendingKeys) {
          var entry = this.pendingKeys.get(key);
          entry && entry.set(false);
        }
        delete this.target[key];
        var change = notify ? { type: "remove", object: this.proxy || target, oldValue, name: key } : null;
        false, notify && notifyListeners(this, change);
      } finally {
        endBatch();
      }
    }
  }, ObservableObjectAdministration2.prototype.illegalAccess = function(owner, propName) {
    console.warn("Property '" + propName + "' of '" + owner + "' was accessed through the prototype chain. Use 'decorate' instead to declare the prop or access it statically through it's owner");
  }, ObservableObjectAdministration2.prototype.observe = function(callback, fireImmediately) {
    return registerListener(this, callback);
  }, ObservableObjectAdministration2.prototype.intercept = function(handler) {
    return registerInterceptor(this, handler);
  }, ObservableObjectAdministration2.prototype.notifyPropertyAddition = function(key, newValue) {
    var notify = hasListeners(this), change = notify ? { type: "add", object: this.proxy || this.target, name: key, newValue } : null;
    if (notify && notifyListeners(this, change), this.pendingKeys) {
      var entry = this.pendingKeys.get(key);
      entry && entry.set(true);
    }
    this.keysAtom.reportChanged();
  }, ObservableObjectAdministration2.prototype.getKeys = function() {
    var e_1, _a2;
    this.keysAtom.reportObserved();
    var res = [];
    try {
      for (var _b = __values(this.values), _c = _b.next(); !_c.done; _c = _b.next()) {
        var _d = __read(_c.value, 2), key = _d[0];
        _d[1] instanceof ObservableValue && res.push(key);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        _c && !_c.done && (_a2 = _b.return) && _a2.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return res;
  }, ObservableObjectAdministration2;
}();
function asObservableObject(target, name, defaultEnhancer) {
  if (void 0 === name && (name = ""), void 0 === defaultEnhancer && (defaultEnhancer = deepEnhancer), Object.prototype.hasOwnProperty.call(target, $mobx))
    return target[$mobx];
  isPlainObject(target) || (name = (target.constructor.name || "ObservableObject") + "@" + getNextId()), name || (name = "ObservableObject@" + getNextId());
  var adm = new ObservableObjectAdministration(target, /* @__PURE__ */ new Map(), stringifyKey(name), defaultEnhancer);
  return addHiddenProp(target, $mobx, adm), adm;
}
var observablePropertyConfigs = /* @__PURE__ */ Object.create(null), computedPropertyConfigs = /* @__PURE__ */ Object.create(null);
function getAdministrationForComputedPropOwner(owner) {
  var adm = owner[$mobx];
  return adm || (initializeInstance(owner), owner[$mobx]);
}
var isObservableObjectAdministration = createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function isObservableObject(thing) {
  return !!isObject(thing) && (initializeInstance(thing), isObservableObjectAdministration(thing[$mobx]));
}
function getAtom(thing, property) {
  if ("object" == typeof thing && null !== thing) {
    if (isObservableArray(thing))
      return void 0 !== property && fail(false), thing[$mobx].atom;
    if (isObservableSet(thing))
      return thing[$mobx];
    if (isObservableMap(thing)) {
      var anyThing = thing;
      return void 0 === property ? anyThing._keysAtom : ((observable2 = anyThing._data.get(property) || anyThing._hasMap.get(property)) || fail(false), observable2);
    }
    var observable2;
    if (initializeInstance(thing), property && !thing[$mobx] && thing[property], isObservableObject(thing))
      return property ? ((observable2 = thing[$mobx].values.get(property)) || fail(false), observable2) : fail(false);
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing))
      return thing;
  } else if ("function" == typeof thing && isReaction(thing[$mobx]))
    return thing[$mobx];
  return fail(false);
}
var toString = Object.prototype.toString;
function deepEqual$1(a, b, depth) {
  return void 0 === depth && (depth = -1), eq(a, b, depth);
}
function eq(a, b, depth, aStack, bStack) {
  if (a === b)
    return 0 !== a || 1 / a == 1 / b;
  if (null == a || null == b)
    return false;
  if (a != a)
    return b != b;
  var type = typeof a;
  if ("function" !== type && "object" !== type && "object" != typeof b)
    return false;
  var className = toString.call(a);
  if (className !== toString.call(b))
    return false;
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a == "" + b;
    case "[object Number]":
      return +a != +a ? +b != +b : 0 == +a ? 1 / +a == 1 / b : +a == +b;
    case "[object Date]":
    case "[object Boolean]":
      return +a == +b;
    case "[object Symbol]":
      return "undefined" != typeof Symbol && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);
    case "[object Map]":
    case "[object Set]":
      depth >= 0 && depth++;
  }
  a = unwrap(a), b = unwrap(b);
  var areArrays = "[object Array]" === className;
  if (!areArrays) {
    if ("object" != typeof a || "object" != typeof b)
      return false;
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !("function" == typeof aCtor && aCtor instanceof aCtor && "function" == typeof bCtor && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b)
      return false;
  }
  if (0 === depth)
    return false;
  depth < 0 && (depth = -1), bStack = bStack || [];
  for (var length = (aStack = aStack || []).length; length--; )
    if (aStack[length] === a)
      return bStack[length] === b;
  if (aStack.push(a), bStack.push(b), areArrays) {
    if ((length = a.length) !== b.length)
      return false;
    for (; length--; )
      if (!eq(a[length], b[length], depth - 1, aStack, bStack))
        return false;
  } else {
    var keys = Object.keys(a), key = void 0;
    if (length = keys.length, Object.keys(b).length !== length)
      return false;
    for (; length--; )
      if (!has$1(b, key = keys[length]) || !eq(a[key], b[key], depth - 1, aStack, bStack))
        return false;
  }
  return aStack.pop(), bStack.pop(), true;
}
function unwrap(a) {
  return isObservableArray(a) ? a.slice() : isES6Map(a) || isObservableMap(a) || isES6Set(a) || isObservableSet(a) ? Array.from(a.entries()) : a;
}
function has$1(a, key) {
  return Object.prototype.hasOwnProperty.call(a, key);
}
function makeIterable(iterator) {
  return iterator[Symbol.iterator] = getSelf, iterator;
}
function getSelf() {
  return this;
}
if ("undefined" == typeof Proxy || "undefined" == typeof Symbol)
  throw new Error("[mobx] MobX 5+ requires Proxy and Symbol objects. If your environment doesn't support Symbol or Proxy objects, please downgrade to MobX 4. For React Native Android, consider upgrading JSCore.");
"object" == typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ && __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({ spy: function(listener) {
  return console.warn("[mobx.spy] Is a no-op in production builds"), function() {
  };
}, extras: { getDebugName: function(thing, property) {
  return (void 0 !== property ? getAtom(thing, property) : isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing) ? function(thing2) {
    return thing2 || fail("Expecting some object"), isAtom(thing2) || isComputedValue(thing2) || isReaction(thing2) || isObservableMap(thing2) || isObservableSet(thing2) ? thing2 : (initializeInstance(thing2), thing2[$mobx] ? thing2[$mobx] : void fail(false));
  }(thing) : getAtom(thing)).name;
} }, $mobx });
class ObjectLockManager {
  constructor() {
    this.lockMap = /* @__PURE__ */ new Map();
  }
  lock(guids) {
    for (const guid of guids) {
      const lockCount = this.lockMap.get(guid) ?? 0;
      this.lockMap.set(guid, lockCount + 1);
    }
    let released = false;
    return () => {
      if (released)
        throw new AssertionError(`Releasing a lock that was already released for GUIDs ${guids.join(", ")}`);
      for (const guid of guids) {
        const lockCount = this.lockMap.get(guid);
        if (void 0 === lockCount)
          throw new AssertionError(`Releasing a lock that was already released for GUID ${guid}`);
        lockCount > 1 ? this.lockMap.set(guid, lockCount - 1) : this.lockMap.delete(guid);
      }
      released = true;
    };
  }
  getLockedGuids() {
    return new Set(this.lockMap.keys());
  }
  getLockCount(guid) {
    return this.lockMap.get(guid) ?? 0;
  }
  clear() {
    this.lockMap.clear();
  }
  static getInstance() {
    return ObjectLockManager.instance;
  }
}
ObjectLockManager.instance = new ObjectLockManager();
const subscriptionsByKey = /* @__PURE__ */ new Map(), lockManager$1 = ObjectLockManager.getInstance();
function subscribe$1(subscription) {
  const subscriptionKey = getSubscriptionKey(subscription), subscriptionsForKey = subscriptionsByKey.get(subscriptionKey) ?? [];
  subscriptionsForKey.push(subscription), subscriptionsByKey.set(subscriptionKey, subscriptionsForKey);
  let releaseLockFn = () => {
  };
  return "guid" in subscription && (releaseLockFn = lockManager$1.lock([subscription.guid])), { unsubscribe: () => {
    const currentSubscriptionsForKey = subscriptionsByKey.has(subscriptionKey) ? subscriptionsByKey.get(subscriptionKey) : [], subscriptionIndex = currentSubscriptionsForKey.indexOf(subscription);
    releaseLockFn(), -1 !== subscriptionIndex && (currentSubscriptionsForKey.splice(subscriptionIndex, 1), 0 === currentSubscriptionsForKey.length && subscriptionsByKey.delete(subscriptionKey));
  } };
}
async function publish(...messages) {
  const callbacks = [], handled = [];
  for (const message of messages) {
    let matchingSubs;
    if ("entity" in message) {
      matchingSubs = [message.entity].concat(getEntityMeta(message.entity)?.generalizations ?? []).reduce((subs, entity) => (subscriptionsByKey.get(entity)?.forEach((s) => subs.push(s)), subs), []);
    } else {
      const subscriptionKey = getSubscriptionKey(message);
      matchingSubs = subscriptionsByKey.has(subscriptionKey) ? subscriptionsByKey.get(subscriptionKey) : [];
    }
    matchingSubs.length && (matchingSubs.forEach((s) => {
      const callback = "val" in message ? s.callback.bind(s, message.val) : s.callback.bind(s, void 0);
      callbacks.push({ callback, priority: s.priority ?? 0, sync: s.sync ?? false });
    }), handled.push(message));
  }
  const prioritizedCallbacks = groupBy(callbacks, (v) => v.priority).sort((a, b) => a.key - b.key), asyncUpdates = [];
  for (const group of prioritizedCallbacks) {
    const [sync, async] = runInAction(() => partition((e) => e.sync, group.values, (e) => e.callback.apply(void 0)));
    await Promise.all(sync), asyncUpdates.push(...async);
  }
  return await Promise.all(asyncUpdates), { handled };
}
function getTags(guid) {
  const tags = [];
  for (const subscriptions of subscriptionsByKey.values())
    for (const subscription of subscriptions) {
      if (!("guid" in subscription) || subscription.guid !== guid || void 0 === subscription.tag)
        break;
      tags.push(subscription.tag);
    }
  return tags;
}
function getSubscriptionKey(subscriptionOrMessage) {
  if ("guid" in subscriptionOrMessage && "attr" in subscriptionOrMessage && "val" in subscriptionOrMessage && subscriptionOrMessage.val)
    return `${subscriptionOrMessage.guid}:${subscriptionOrMessage.attr}:validation`;
  if ("guid" in subscriptionOrMessage && "attr" in subscriptionOrMessage)
    return `${subscriptionOrMessage.guid}:${subscriptionOrMessage.attr}`;
  if ("guid" in subscriptionOrMessage)
    return subscriptionOrMessage.guid;
  if ("entity" in subscriptionOrMessage)
    return subscriptionOrMessage.entity;
  if ("topic" in subscriptionOrMessage)
    return subscriptionOrMessage.topic;
  if ("param" in subscriptionOrMessage)
    return subscriptionOrMessage.param;
  throw new AssertionError("Unknown subscription or message");
}

var hasRequiredScheduler_production_min, hasRequiredScheduler, hasRequiredReactDom_production_min, reactDom = { exports: {} }, reactDom_production_min = {}, scheduler = { exports: {} }, scheduler_production_min = {};
function requireScheduler() {
  return hasRequiredScheduler || (hasRequiredScheduler = 1, scheduler.exports = (hasRequiredScheduler_production_min || (hasRequiredScheduler_production_min = 1, function(exports) {
    function f(a, b) {
      var c = a.length;
      a.push(b);
      a:
        for (; 0 < c; ) {
          var d = c - 1 >>> 1, e = a[d];
          if (!(0 < g(e, b)))
            break a;
          a[d] = b, a[c] = e, c = d;
        }
    }
    function h(a) {
      return 0 === a.length ? null : a[0];
    }
    function k(a) {
      if (0 === a.length)
        return null;
      var b = a[0], c = a.pop();
      if (c !== b) {
        a[0] = c;
        a:
          for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
            var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
            if (0 > g(C, c))
              n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
            else {
              if (!(n < e && 0 > g(x, c)))
                break a;
              a[d] = x, a[n] = c, d = n;
            }
          }
      }
      return b;
    }
    function g(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return 0 !== c ? c : a.id - b.id;
    }
    if ("object" == typeof performance && "function" == typeof performance.now) {
      var l = performance;
      exports.unstable_now = function() {
        return l.now();
      };
    } else {
      var p = Date, q = p.now();
      exports.unstable_now = function() {
        return p.now() - q;
      };
    }
    var r = [], t = [], u = 1, v = null, y = 3, z = false, A = false, B = false, D = "function" == typeof setTimeout ? setTimeout : null, E = "function" == typeof clearTimeout ? clearTimeout : null, F = "undefined" != typeof setImmediate ? setImmediate : null;
    function G(a) {
      for (var b = h(t); null !== b; ) {
        if (null === b.callback)
          k(t);
        else {
          if (!(b.startTime <= a))
            break;
          k(t), b.sortIndex = b.expirationTime, f(r, b);
        }
        b = h(t);
      }
    }
    function H(a) {
      if (B = false, G(a), !A)
        if (null !== h(r))
          A = true, I(J);
        else {
          var b = h(t);
          null !== b && K(H, b.startTime - a);
        }
    }
    function J(a, b) {
      A = false, B && (B = false, E(L), L = -1), z = true;
      var c = y;
      try {
        for (G(b), v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
          var d = v.callback;
          if ("function" == typeof d) {
            v.callback = null, y = v.priorityLevel;
            var e = d(v.expirationTime <= b);
            b = exports.unstable_now(), "function" == typeof e ? v.callback = e : v === h(r) && k(r), G(b);
          } else
            k(r);
          v = h(r);
        }
        if (null !== v)
          var w = true;
        else {
          var m = h(t);
          null !== m && K(H, m.startTime - b), w = false;
        }
        return w;
      } finally {
        v = null, y = c, z = false;
      }
    }
    "undefined" != typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    var S, N = false, O = null, L = -1, P = 5, Q = -1;
    function M() {
      return !(exports.unstable_now() - Q < P);
    }
    function R() {
      if (null !== O) {
        var a = exports.unstable_now();
        Q = a;
        var b = true;
        try {
          b = O(true, a);
        } finally {
          b ? S() : (N = false, O = null);
        }
      } else
        N = false;
    }
    if ("function" == typeof F)
      S = function() {
        F(R);
      };
    else if ("undefined" != typeof MessageChannel) {
      var T = new MessageChannel(), U = T.port2;
      T.port1.onmessage = R, S = function() {
        U.postMessage(null);
      };
    } else
      S = function() {
        D(R, 0);
      };
    function I(a) {
      O = a, N || (N = true, S());
    }
    function K(a, b) {
      L = D(function() {
        a(exports.unstable_now());
      }, b);
    }
    exports.unstable_IdlePriority = 5, exports.unstable_ImmediatePriority = 1, exports.unstable_LowPriority = 4, exports.unstable_NormalPriority = 3, exports.unstable_Profiling = null, exports.unstable_UserBlockingPriority = 2, exports.unstable_cancelCallback = function(a) {
      a.callback = null;
    }, exports.unstable_continueExecution = function() {
      A || z || (A = true, I(J));
    }, exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
    }, exports.unstable_getCurrentPriorityLevel = function() {
      return y;
    }, exports.unstable_getFirstCallbackNode = function() {
      return h(r);
    }, exports.unstable_next = function(a) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y;
      }
      var c = y;
      y = b;
      try {
        return a();
      } finally {
        y = c;
      }
    }, exports.unstable_pauseExecution = function() {
    }, exports.unstable_requestPaint = function() {
    }, exports.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y;
      y = a;
      try {
        return b();
      } finally {
        y = c;
      }
    }, exports.unstable_scheduleCallback = function(a, b, c) {
      var d = exports.unstable_now();
      switch (c = "object" == typeof c && null !== c && "number" == typeof (c = c.delay) && 0 < c ? d + c : d, a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      return a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e = c + e, sortIndex: -1 }, c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J))), a;
    }, exports.unstable_shouldYield = M, exports.unstable_wrapCallback = function(a) {
      var b = y;
      return function() {
        var c = y;
        y = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y = c;
        }
      };
    };
  }(scheduler_production_min)), scheduler_production_min)), scheduler.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
!function checkDCE() {
  if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
}(), reactDom.exports = function() {
  if (hasRequiredReactDom_production_min)
    return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa = n, ca = requireScheduler();
  function p(a2) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c = 1; c < arguments.length; c++)
      b += "&args[]=" + encodeURIComponent(arguments[c]);
    return "Minified React error #" + a2 + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a2, b) {
    ha(a2, b), ha(a2 + "Capture", b);
  }
  function ha(a2, b) {
    for (ea[a2] = b, a2 = 0; a2 < b.length; a2++)
      da.add(b[a2]);
  }
  var ia = !("undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function v(a2, b, c, d, e, f, g) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b, this.attributeName = d, this.attributeNamespace = e, this.mustUseProperty = c, this.propertyName = a2, this.type = b, this.sanitizeURL = f, this.removeEmptyString = g;
  }
  var z = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
    z[a2] = new v(a2, 0, false, a2, null, false, false);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
    var b = a2[0];
    z[b] = new v(b, 1, false, a2[1], null, false, false);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
    z[a2] = new v(a2, 2, false, a2.toLowerCase(), null, false, false);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
    z[a2] = new v(a2, 2, false, a2, null, false, false);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
    z[a2] = new v(a2, 3, false, a2.toLowerCase(), null, false, false);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
    z[a2] = new v(a2, 3, true, a2, null, false, false);
  }), ["capture", "download"].forEach(function(a2) {
    z[a2] = new v(a2, 4, false, a2, null, false, false);
  }), ["cols", "rows", "size", "span"].forEach(function(a2) {
    z[a2] = new v(a2, 6, false, a2, null, false, false);
  }), ["rowSpan", "start"].forEach(function(a2) {
    z[a2] = new v(a2, 5, false, a2.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a2) {
    return a2[1].toUpperCase();
  }
  function ta(a2, b, c, d) {
    var e = z.hasOwnProperty(b) ? z[b] : null;
    (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) && (function(a3, b2, c2, d2) {
      if (null == b2 || function(a4, b3, c3, d3) {
        if (null !== c3 && 0 === c3.type)
          return false;
        switch (typeof b3) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            return !d3 && (null !== c3 ? !c3.acceptsBooleans : "data-" !== (a4 = a4.toLowerCase().slice(0, 5)) && "aria-" !== a4);
          default:
            return false;
        }
      }(a3, b2, c2, d2))
        return true;
      if (d2)
        return false;
      if (null !== c2)
        switch (c2.type) {
          case 3:
            return !b2;
          case 4:
            return false === b2;
          case 5:
            return isNaN(b2);
          case 6:
            return isNaN(b2) || 1 > b2;
        }
      return false;
    }(b, c, e, d) && (c = null), d || null === e ? function(a3) {
      return !!ja.call(ma, a3) || !ja.call(la, a3) && (ka.test(a3) ? ma[a3] = true : (la[a3] = true, false));
    }(b) && (null === c ? a2.removeAttribute(b) : a2.setAttribute(b, "" + c)) : e.mustUseProperty ? a2[e.propertyName] = null === c ? 3 !== e.type && "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a2.removeAttribute(b) : (c = 3 === (e = e.type) || 4 === e && true === c ? "" : "" + c, d ? a2.setAttributeNS(d, b, c) : a2.setAttribute(b, c))));
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
    var b = a2.replace(ra, sa);
    z[b] = new v(b, 1, false, a2, null, false, false);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
    var b = a2.replace(ra, sa);
    z[b] = new v(b, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
    var b = a2.replace(ra, sa);
    z[b] = new v(b, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
  }), ["tabIndex", "crossOrigin"].forEach(function(a2) {
    z[a2] = new v(a2, 1, false, a2.toLowerCase(), null, false, false);
  }), z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false), ["src", "href", "action", "formAction"].forEach(function(a2) {
    z[a2] = new v(a2, 1, false, a2.toLowerCase(), null, true, true);
  });
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy"), Ia = Symbol.for("react.offscreen"), Ja = Symbol.iterator;
  function Ka(a2) {
    return null === a2 || "object" != typeof a2 ? null : "function" == typeof (a2 = Ja && a2[Ja] || a2["@@iterator"]) ? a2 : null;
  }
  var La, A = Object.assign;
  function Ma(a2) {
    if (void 0 === La)
      try {
        throw Error();
      } catch (c) {
        var b = c.stack.trim().match(/\n( *(at )?)/);
        La = b && b[1] || "";
      }
    return "\n" + La + a2;
  }
  var Na = false;
  function Oa(a2, b) {
    if (!a2 || Na)
      return "";
    Na = true;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b)
        if (b = function() {
          throw Error();
        }, Object.defineProperty(b.prototype, "props", { set: function() {
          throw Error();
        } }), "object" == typeof Reflect && Reflect.construct) {
          try {
            Reflect.construct(b, []);
          } catch (l) {
            var d = l;
          }
          Reflect.construct(a2, [], b);
        } else {
          try {
            b.call();
          } catch (l) {
            d = l;
          }
          a2.call(b.prototype);
        }
      else {
        try {
          throw Error();
        } catch (l) {
          d = l;
        }
        a2();
      }
    } catch (l) {
      if (l && d && "string" == typeof l.stack) {
        for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; )
          h--;
        for (; 1 <= g && 0 <= h; g--, h--)
          if (e[g] !== f[h]) {
            if (1 !== g || 1 !== h)
              do {
                if (g--, 0 > --h || e[g] !== f[h]) {
                  var k = "\n" + e[g].replace(" at new ", " at ");
                  return a2.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a2.displayName)), k;
                }
              } while (1 <= g && 0 <= h);
            break;
          }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c;
    }
    return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
  }
  function Pa(a2) {
    switch (a2.tag) {
      case 5:
        return Ma(a2.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return Oa(a2.type, false);
      case 11:
        return Oa(a2.type.render, false);
      case 1:
        return Oa(a2.type, true);
      default:
        return "";
    }
  }
  function Qa(a2) {
    if (null == a2)
      return null;
    if ("function" == typeof a2)
      return a2.displayName || a2.name || null;
    if ("string" == typeof a2)
      return a2;
    switch (a2) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" == typeof a2)
      switch (a2.$$typeof) {
        case Ca:
          return (a2.displayName || "Context") + ".Consumer";
        case Ba:
          return (a2._context.displayName || "Context") + ".Provider";
        case Da:
          var b = a2.render;
          return (a2 = a2.displayName) || (a2 = "" !== (a2 = b.displayName || b.name || "") ? "ForwardRef(" + a2 + ")" : "ForwardRef"), a2;
        case Ga:
          return null !== (b = a2.displayName || null) ? b : Qa(a2.type) || "Memo";
        case Ha:
          b = a2._payload, a2 = a2._init;
          try {
            return Qa(a2(b));
          } catch (c) {
          }
      }
    return null;
  }
  function Ra(a2) {
    var b = a2.type;
    switch (a2.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b.displayName || "Context") + ".Consumer";
      case 10:
        return (b._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a2 = (a2 = b.render).displayName || a2.name || "", b.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b);
      case 8:
        return b === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" == typeof b)
          return b.displayName || b.name || null;
        if ("string" == typeof b)
          return b;
    }
    return null;
  }
  function Sa(a2) {
    switch (typeof a2) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
      case "object":
        return a2;
      default:
        return "";
    }
  }
  function Ta(a2) {
    var b = a2.type;
    return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b || "radio" === b);
  }
  function Va(a2) {
    a2._valueTracker || (a2._valueTracker = function(a3) {
      var b = Ta(a3) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a3.constructor.prototype, b), d = "" + a3[b];
      if (!a3.hasOwnProperty(b) && void 0 !== c && "function" == typeof c.get && "function" == typeof c.set) {
        var e = c.get, f = c.set;
        return Object.defineProperty(a3, b, { configurable: true, get: function() {
          return e.call(this);
        }, set: function(a4) {
          d = "" + a4, f.call(this, a4);
        } }), Object.defineProperty(a3, b, { enumerable: c.enumerable }), { getValue: function() {
          return d;
        }, setValue: function(a4) {
          d = "" + a4;
        }, stopTracking: function() {
          a3._valueTracker = null, delete a3[b];
        } };
      }
    }(a2));
  }
  function Wa(a2) {
    if (!a2)
      return false;
    var b = a2._valueTracker;
    if (!b)
      return true;
    var c = b.getValue(), d = "";
    return a2 && (d = Ta(a2) ? a2.checked ? "true" : "false" : a2.value), (a2 = d) !== c && (b.setValue(a2), true);
  }
  function Xa(a2) {
    if (void 0 === (a2 = a2 || ("undefined" != typeof document ? document : void 0)))
      return null;
    try {
      return a2.activeElement || a2.body;
    } catch (b) {
      return a2.body;
    }
  }
  function Ya(a2, b) {
    var c = b.checked;
    return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a2._wrapperState.initialChecked });
  }
  function Za(a2, b) {
    var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
    c = Sa(null != b.value ? b.value : c), a2._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
  }
  function ab(a2, b) {
    null != (b = b.checked) && ta(a2, "checked", b, false);
  }
  function bb(a2, b) {
    ab(a2, b);
    var c = Sa(b.value), d = b.type;
    if (null != c)
      "number" === d ? (0 === c && "" === a2.value || a2.value != c) && (a2.value = "" + c) : a2.value !== "" + c && (a2.value = "" + c);
    else if ("submit" === d || "reset" === d)
      return void a2.removeAttribute("value");
    b.hasOwnProperty("value") ? cb(a2, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a2, b.type, Sa(b.defaultValue)), null == b.checked && null != b.defaultChecked && (a2.defaultChecked = !!b.defaultChecked);
  }
  function db(a2, b, c) {
    if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
      var d = b.type;
      if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value))
        return;
      b = "" + a2._wrapperState.initialValue, c || b === a2.value || (a2.value = b), a2.defaultValue = b;
    }
    "" !== (c = a2.name) && (a2.name = ""), a2.defaultChecked = !!a2._wrapperState.initialChecked, "" !== c && (a2.name = c);
  }
  function cb(a2, b, c) {
    "number" === b && Xa(a2.ownerDocument) === a2 || (null == c ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c && (a2.defaultValue = "" + c));
  }
  var eb = Array.isArray;
  function fb(a2, b, c, d) {
    if (a2 = a2.options, b) {
      b = {};
      for (var e = 0; e < c.length; e++)
        b["$" + c[e]] = true;
      for (c = 0; c < a2.length; c++)
        e = b.hasOwnProperty("$" + a2[c].value), a2[c].selected !== e && (a2[c].selected = e), e && d && (a2[c].defaultSelected = true);
    } else {
      for (c = "" + Sa(c), b = null, e = 0; e < a2.length; e++) {
        if (a2[e].value === c)
          return a2[e].selected = true, void (d && (a2[e].defaultSelected = true));
        null !== b || a2[e].disabled || (b = a2[e]);
      }
      null !== b && (b.selected = true);
    }
  }
  function gb(a2, b) {
    if (null != b.dangerouslySetInnerHTML)
      throw Error(p(91));
    return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
  }
  function hb(a2, b) {
    var c = b.value;
    if (null == c) {
      if (c = b.children, b = b.defaultValue, null != c) {
        if (null != b)
          throw Error(p(92));
        if (eb(c)) {
          if (1 < c.length)
            throw Error(p(93));
          c = c[0];
        }
        b = c;
      }
      null == b && (b = ""), c = b;
    }
    a2._wrapperState = { initialValue: Sa(c) };
  }
  function ib(a2, b) {
    var c = Sa(b.value), d = Sa(b.defaultValue);
    null != c && ((c = "" + c) !== a2.value && (a2.value = c), null == b.defaultValue && a2.defaultValue !== c && (a2.defaultValue = c)), null != d && (a2.defaultValue = "" + d);
  }
  function jb(a2) {
    var b = a2.textContent;
    b === a2._wrapperState.initialValue && "" !== b && null !== b && (a2.value = b);
  }
  function kb(a2) {
    switch (a2) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a2, b) {
    return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a2;
  }
  var mb, a, nb = (a = function(a2, b) {
    if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
      a2.innerHTML = b;
    else {
      for ((mb = mb || document.createElement("div")).innerHTML = "<svg>" + b.valueOf().toString() + "</svg>", b = mb.firstChild; a2.firstChild; )
        a2.removeChild(a2.firstChild);
      for (; b.firstChild; )
        a2.appendChild(b.firstChild);
    }
  }, "undefined" != typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b, c);
    });
  } : a);
  function ob(a2, b) {
    if (b) {
      var c = a2.firstChild;
      if (c && c === a2.lastChild && 3 === c.nodeType)
        return void (c.nodeValue = b);
    }
    a2.textContent = b;
  }
  var pb = { animationIterationCount: true, aspectRatio: true, borderImageOutset: true, borderImageSlice: true, borderImageWidth: true, boxFlex: true, boxFlexGroup: true, boxOrdinalGroup: true, columnCount: true, columns: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, flexOrder: true, gridArea: true, gridRow: true, gridRowEnd: true, gridRowSpan: true, gridRowStart: true, gridColumn: true, gridColumnEnd: true, gridColumnSpan: true, gridColumnStart: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, floodOpacity: true, stopOpacity: true, strokeDasharray: true, strokeDashoffset: true, strokeMiterlimit: true, strokeOpacity: true, strokeWidth: true }, qb = ["Webkit", "ms", "Moz", "O"];
  function rb(a2, b, c) {
    return null == b || "boolean" == typeof b || "" === b ? "" : c || "number" != typeof b || 0 === b || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b).trim() : b + "px";
  }
  function sb(a2, b) {
    for (var c in a2 = a2.style, b)
      if (b.hasOwnProperty(c)) {
        var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
        "float" === c && (c = "cssFloat"), d ? a2.setProperty(c, e) : a2[c] = e;
      }
  }
  Object.keys(pb).forEach(function(a2) {
    qb.forEach(function(b) {
      b = b + a2.charAt(0).toUpperCase() + a2.substring(1), pb[b] = pb[a2];
    });
  });
  var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a2, b) {
    if (b) {
      if (tb[a2] && (null != b.children || null != b.dangerouslySetInnerHTML))
        throw Error(p(137, a2));
      if (null != b.dangerouslySetInnerHTML) {
        if (null != b.children)
          throw Error(p(60));
        if ("object" != typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML))
          throw Error(p(61));
      }
      if (null != b.style && "object" != typeof b.style)
        throw Error(p(62));
    }
  }
  function vb(a2, b) {
    if (-1 === a2.indexOf("-"))
      return "string" == typeof b.is;
    switch (a2) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a2) {
    return (a2 = a2.target || a2.srcElement || window).correspondingUseElement && (a2 = a2.correspondingUseElement), 3 === a2.nodeType ? a2.parentNode : a2;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a2) {
    if (a2 = Cb(a2)) {
      if ("function" != typeof yb)
        throw Error(p(280));
      var b = a2.stateNode;
      b && (b = Db(b), yb(a2.stateNode, a2.type, b));
    }
  }
  function Eb(a2) {
    zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
  }
  function Fb() {
    if (zb) {
      var a2 = zb, b = Ab;
      if (Ab = zb = null, Bb(a2), b)
        for (a2 = 0; a2 < b.length; a2++)
          Bb(b[a2]);
    }
  }
  function Gb(a2, b) {
    return a2(b);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a2, b, c) {
    if (Ib)
      return a2(b, c);
    Ib = true;
    try {
      return Gb(a2, b, c);
    } finally {
      Ib = false, (null !== zb || null !== Ab) && (Hb(), Fb());
    }
  }
  function Kb(a2, b) {
    var c = a2.stateNode;
    if (null === c)
      return null;
    var d = Db(c);
    if (null === d)
      return null;
    c = d[b];
    a:
      switch (b) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (d = !d.disabled) || (d = !("button" === (a2 = a2.type) || "input" === a2 || "select" === a2 || "textarea" === a2)), a2 = !d;
          break a;
        default:
          a2 = false;
      }
    if (a2)
      return null;
    if (c && "function" != typeof c)
      throw Error(p(231, b, typeof c));
    return c;
  }
  var Lb = false;
  if (ia)
    try {
      var Mb = {};
      Object.defineProperty(Mb, "passive", { get: function() {
        Lb = true;
      } }), window.addEventListener("test", Mb, Mb), window.removeEventListener("test", Mb, Mb);
    } catch (a2) {
      Lb = false;
    }
  function Nb(a2, b, c, d, e, f, g, h, k) {
    var l = Array.prototype.slice.call(arguments, 3);
    try {
      b.apply(c, l);
    } catch (m) {
      this.onError(m);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
    Ob = true, Pb = a2;
  } };
  function Tb(a2, b, c, d, e, f, g, h, k) {
    Ob = false, Pb = null, Nb.apply(Sb, arguments);
  }
  function Vb(a2) {
    var b = a2, c = a2;
    if (a2.alternate)
      for (; b.return; )
        b = b.return;
    else {
      a2 = b;
      do {
        !!(4098 & (b = a2).flags) && (c = b.return), a2 = b.return;
      } while (a2);
    }
    return 3 === b.tag ? c : null;
  }
  function Wb(a2) {
    if (13 === a2.tag) {
      var b = a2.memoizedState;
      if (null === b && null !== (a2 = a2.alternate) && (b = a2.memoizedState), null !== b)
        return b.dehydrated;
    }
    return null;
  }
  function Xb(a2) {
    if (Vb(a2) !== a2)
      throw Error(p(188));
  }
  function Zb(a2) {
    return null !== (a2 = function(a3) {
      var b = a3.alternate;
      if (!b) {
        if (null === (b = Vb(a3)))
          throw Error(p(188));
        return b !== a3 ? null : a3;
      }
      for (var c = a3, d = b; ; ) {
        var e = c.return;
        if (null === e)
          break;
        var f = e.alternate;
        if (null === f) {
          if (null !== (d = e.return)) {
            c = d;
            continue;
          }
          break;
        }
        if (e.child === f.child) {
          for (f = e.child; f; ) {
            if (f === c)
              return Xb(e), a3;
            if (f === d)
              return Xb(e), b;
            f = f.sibling;
          }
          throw Error(p(188));
        }
        if (c.return !== d.return)
          c = e, d = f;
        else {
          for (var g = false, h = e.child; h; ) {
            if (h === c) {
              g = true, c = e, d = f;
              break;
            }
            if (h === d) {
              g = true, d = e, c = f;
              break;
            }
            h = h.sibling;
          }
          if (!g) {
            for (h = f.child; h; ) {
              if (h === c) {
                g = true, c = f, d = e;
                break;
              }
              if (h === d) {
                g = true, d = f, c = e;
                break;
              }
              h = h.sibling;
            }
            if (!g)
              throw Error(p(189));
          }
        }
        if (c.alternate !== d)
          throw Error(p(190));
      }
      if (3 !== c.tag)
        throw Error(p(188));
      return c.stateNode.current === c ? a3 : b;
    }(a2)) ? $b(a2) : null;
  }
  function $b(a2) {
    if (5 === a2.tag || 6 === a2.tag)
      return a2;
    for (a2 = a2.child; null !== a2; ) {
      var b = $b(a2);
      if (null !== b)
        return b;
      a2 = a2.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null, oc = Math.clz32 ? Math.clz32 : function(a2) {
    return 0 === (a2 >>>= 0) ? 32 : 31 - (pc(a2) / qc | 0) | 0;
  }, pc = Math.log, qc = Math.LN2, rc = 64, sc = 4194304;
  function tc(a2) {
    switch (a2 & -a2) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return 4194240 & a2;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return 130023424 & a2;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a2;
    }
  }
  function uc(a2, b) {
    var c = a2.pendingLanes;
    if (0 === c)
      return 0;
    var d = 0, e = a2.suspendedLanes, f = a2.pingedLanes, g = 268435455 & c;
    if (0 !== g) {
      var h = g & ~e;
      0 !== h ? d = tc(h) : 0 != (f &= g) && (d = tc(f));
    } else
      0 != (g = c & ~e) ? d = tc(g) : 0 !== f && (d = tc(f));
    if (0 === d)
      return 0;
    if (0 !== b && b !== d && !(b & e) && ((e = d & -d) >= (f = b & -b) || 16 === e && 4194240 & f))
      return b;
    if (4 & d && (d |= 16 & c), 0 !== (b = a2.entangledLanes))
      for (a2 = a2.entanglements, b &= d; 0 < b; )
        e = 1 << (c = 31 - oc(b)), d |= a2[c], b &= ~e;
    return d;
  }
  function vc(a2, b) {
    switch (a2) {
      case 1:
      case 2:
      case 4:
        return b + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b + 5e3;
      default:
        return -1;
    }
  }
  function xc(a2) {
    return 0 != (a2 = -1073741825 & a2.pendingLanes) ? a2 : 1073741824 & a2 ? 1073741824 : 0;
  }
  function yc() {
    var a2 = rc;
    return !(4194240 & (rc <<= 1)) && (rc = 64), a2;
  }
  function zc(a2) {
    for (var b = [], c = 0; 31 > c; c++)
      b.push(a2);
    return b;
  }
  function Ac(a2, b, c) {
    a2.pendingLanes |= b, 536870912 !== b && (a2.suspendedLanes = 0, a2.pingedLanes = 0), (a2 = a2.eventTimes)[b = 31 - oc(b)] = c;
  }
  function Cc(a2, b) {
    var c = a2.entangledLanes |= b;
    for (a2 = a2.entanglements; c; ) {
      var d = 31 - oc(c), e = 1 << d;
      e & b | a2[d] & b && (a2[d] |= b), c &= ~e;
    }
  }
  var C = 0;
  function Dc(a2) {
    return 1 < (a2 &= -a2) ? 4 < a2 ? 268435455 & a2 ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a2, b) {
    switch (a2) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b.pointerId);
    }
  }
  function Tc(a2, b, c, d, e, f) {
    return null === a2 || a2.nativeEvent !== f ? (a2 = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && null !== (b = Cb(b)) && Fc(b), a2) : (a2.eventSystemFlags |= d, b = a2.targetContainers, null !== e && -1 === b.indexOf(e) && b.push(e), a2);
  }
  function Vc(a2) {
    var b = Wc(a2.target);
    if (null !== b) {
      var c = Vb(b);
      if (null !== c) {
        if (13 === (b = c.tag)) {
          if (null !== (b = Wb(c)))
            return a2.blockedOn = b, void Ic(a2.priority, function() {
              Gc(c);
            });
        } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated)
          return void (a2.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null);
      }
    }
    a2.blockedOn = null;
  }
  function Xc(a2) {
    if (null !== a2.blockedOn)
      return false;
    for (var b = a2.targetContainers; 0 < b.length; ) {
      var c = Yc(a2.domEventName, a2.eventSystemFlags, b[0], a2.nativeEvent);
      if (null !== c)
        return null !== (b = Cb(c)) && Fc(b), a2.blockedOn = c, false;
      var d = new (c = a2.nativeEvent).constructor(c.type, c);
      wb = d, c.target.dispatchEvent(d), wb = null, b.shift();
    }
    return true;
  }
  function Zc(a2, b, c) {
    Xc(a2) && c.delete(b);
  }
  function $c() {
    Jc = false, null !== Lc && Xc(Lc) && (Lc = null), null !== Mc && Xc(Mc) && (Mc = null), null !== Nc && Xc(Nc) && (Nc = null), Oc.forEach(Zc), Pc.forEach(Zc);
  }
  function ad(a2, b) {
    a2.blockedOn === b && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a2) {
    function b(b2) {
      return ad(b2, a2);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a2);
      for (var c = 1; c < Kc.length; c++) {
        var d = Kc[c];
        d.blockedOn === a2 && (d.blockedOn = null);
      }
    }
    for (null !== Lc && ad(Lc, a2), null !== Mc && ad(Mc, a2), null !== Nc && ad(Nc, a2), Oc.forEach(b), Pc.forEach(b), c = 0; c < Qc.length; c++)
      (d = Qc[c]).blockedOn === a2 && (d.blockedOn = null);
    for (; 0 < Qc.length && null === (c = Qc[0]).blockedOn; )
      Vc(c), null === c.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a2, b, c, d) {
    var e = C, f = cd.transition;
    cd.transition = null;
    try {
      C = 1, fd(a2, b, c, d);
    } finally {
      C = e, cd.transition = f;
    }
  }
  function gd(a2, b, c, d) {
    var e = C, f = cd.transition;
    cd.transition = null;
    try {
      C = 4, fd(a2, b, c, d);
    } finally {
      C = e, cd.transition = f;
    }
  }
  function fd(a2, b, c, d) {
    if (dd) {
      var e = Yc(a2, b, c, d);
      if (null === e)
        hd(a2, b, d, id, c), Sc(a2, d);
      else if (function(a3, b2, c2, d2, e2) {
        switch (b2) {
          case "focusin":
            return Lc = Tc(Lc, a3, b2, c2, d2, e2), true;
          case "dragenter":
            return Mc = Tc(Mc, a3, b2, c2, d2, e2), true;
          case "mouseover":
            return Nc = Tc(Nc, a3, b2, c2, d2, e2), true;
          case "pointerover":
            var f2 = e2.pointerId;
            return Oc.set(f2, Tc(Oc.get(f2) || null, a3, b2, c2, d2, e2)), true;
          case "gotpointercapture":
            return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a3, b2, c2, d2, e2)), true;
        }
        return false;
      }(e, a2, b, c, d))
        d.stopPropagation();
      else if (Sc(a2, d), 4 & b && -1 < Rc.indexOf(a2)) {
        for (; null !== e; ) {
          var f = Cb(e);
          if (null !== f && Ec(f), null === (f = Yc(a2, b, c, d)) && hd(a2, b, d, id, c), f === e)
            break;
          e = f;
        }
        null !== e && d.stopPropagation();
      } else
        hd(a2, b, d, null, c);
    }
  }
  var id = null;
  function Yc(a2, b, c, d) {
    if (id = null, null !== (a2 = Wc(a2 = xb(d))))
      if (null === (b = Vb(a2)))
        a2 = null;
      else if (13 === (c = b.tag)) {
        if (null !== (a2 = Wb(b)))
          return a2;
        a2 = null;
      } else if (3 === c) {
        if (b.stateNode.current.memoizedState.isDehydrated)
          return 3 === b.tag ? b.stateNode.containerInfo : null;
        a2 = null;
      } else
        b !== a2 && (a2 = null);
    return id = a2, null;
  }
  function jd(a2) {
    switch (a2) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md)
      return md;
    var a2, d, b = ld, c = b.length, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
    for (a2 = 0; a2 < c && b[a2] === e[a2]; a2++)
      ;
    var g = c - a2;
    for (d = 1; d <= g && b[c - d] === e[f - d]; d++)
      ;
    return md = e.slice(a2, 1 < d ? 1 - d : void 0);
  }
  function od(a2) {
    var b = a2.keyCode;
    return "charCode" in a2 ? 0 === (a2 = a2.charCode) && 13 === b && (a2 = 13) : a2 = b, 10 === a2 && (a2 = 13), 32 <= a2 || 13 === a2 ? a2 : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a2) {
    function b(b2, d, e, f, g) {
      for (var c in this._reactName = b2, this._targetInst = e, this.type = d, this.nativeEvent = f, this.target = g, this.currentTarget = null, a2)
        a2.hasOwnProperty(c) && (b2 = a2[c], this[c] = b2 ? b2(f) : f[c]);
      return this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd, this.isPropagationStopped = qd, this;
    }
    return A(b.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a3 = this.nativeEvent;
      a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" != typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a3 = this.nativeEvent;
      a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" != typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd }), b;
  }
  var wd, xd, yd, sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
    return a2.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
    return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
  }, movementX: function(a2) {
    return "movementX" in a2 ? a2.movementX : (a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2), wd);
  }, movementY: function(a2) {
    return "movementY" in a2 ? a2.movementY : xd;
  } }), Bd = rd(Ad), Dd = rd(A({}, Ad, { dataTransfer: 0 })), Fd = rd(A({}, ud, { relatedTarget: 0 })), Hd = rd(A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 })), Jd = rd(A({}, sd, { clipboardData: function(a2) {
    return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
  } })), Ld = rd(A({}, sd, { data: 0 })), Md = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Nd = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a2) {
    var b = this.nativeEvent;
    return b.getModifierState ? b.getModifierState(a2) : !!(a2 = Od[a2]) && !!b[a2];
  }
  function zd() {
    return Pd;
  }
  var Rd = rd(A({}, ud, { key: function(a2) {
    if (a2.key) {
      var b = Md[a2.key] || a2.key;
      if ("Unidentified" !== b)
        return b;
    }
    return "keypress" === a2.type ? 13 === (a2 = od(a2)) ? "Enter" : String.fromCharCode(a2) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
    return "keypress" === a2.type ? od(a2) : 0;
  }, keyCode: function(a2) {
    return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  }, which: function(a2) {
    return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  } })), Td = rd(A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 })), Vd = rd(A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd })), Xd = rd(A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 })), Zd = rd(A({}, Ad, { deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  }, deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  }, deltaZ: 0, deltaMode: 0 })), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
  ia && "documentMode" in document && (be = document.documentMode);
  var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
  function ge(a2, b) {
    switch (a2) {
      case "keyup":
        return -1 !== $d.indexOf(b.keyCode);
      case "keydown":
        return 229 !== b.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he(a2) {
    return "object" == typeof (a2 = a2.detail) && "data" in a2 ? a2.data : null;
  }
  var ie = false, le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a2) {
    var b = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return "input" === b ? !!le[a2.type] : "textarea" === b;
  }
  function ne(a2, b, c, d) {
    Eb(d), 0 < (b = oe(b, "onChange")).length && (c = new td("onChange", "change", null, c, d), a2.push({ event: c, listeners: b }));
  }
  var pe = null, qe = null;
  function re(a2) {
    se(a2, 0);
  }
  function te(a2) {
    if (Wa(ue(a2)))
      return a2;
  }
  function ve(a2, b) {
    if ("change" === a2)
      return b;
  }
  var we = false;
  if (ia) {
    var xe;
    if (ia) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;"), ye = "function" == typeof ze.oninput;
      }
      xe = ye;
    } else
      xe = false;
    we = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a2) {
    if ("value" === a2.propertyName && te(qe)) {
      var b = [];
      ne(b, qe, a2, xb(a2)), Jb(re, b);
    }
  }
  function Ce(a2, b, c) {
    "focusin" === a2 ? (Ae(), qe = c, (pe = b).attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
  }
  function De(a2) {
    if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
      return te(qe);
  }
  function Ee(a2, b) {
    if ("click" === a2)
      return te(b);
  }
  function Fe(a2, b) {
    if ("input" === a2 || "change" === a2)
      return te(b);
  }
  var He = "function" == typeof Object.is ? Object.is : function(a2, b) {
    return a2 === b && (0 !== a2 || 1 / a2 == 1 / b) || a2 != a2 && b != b;
  };
  function Ie(a2, b) {
    if (He(a2, b))
      return true;
    if ("object" != typeof a2 || null === a2 || "object" != typeof b || null === b)
      return false;
    var c = Object.keys(a2), d = Object.keys(b);
    if (c.length !== d.length)
      return false;
    for (d = 0; d < c.length; d++) {
      var e = c[d];
      if (!ja.call(b, e) || !He(a2[e], b[e]))
        return false;
    }
    return true;
  }
  function Je(a2) {
    for (; a2 && a2.firstChild; )
      a2 = a2.firstChild;
    return a2;
  }
  function Ke(a2, b) {
    var d, c = Je(a2);
    for (a2 = 0; c; ) {
      if (3 === c.nodeType) {
        if (d = a2 + c.textContent.length, a2 <= b && d >= b)
          return { node: c, offset: b - a2 };
        a2 = d;
      }
      a: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break a;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = Je(c);
    }
  }
  function Le(a2, b) {
    return !(!a2 || !b) && (a2 === b || (!a2 || 3 !== a2.nodeType) && (b && 3 === b.nodeType ? Le(a2, b.parentNode) : "contains" in a2 ? a2.contains(b) : !!a2.compareDocumentPosition && !!(16 & a2.compareDocumentPosition(b))));
  }
  function Me() {
    for (var a2 = window, b = Xa(); b instanceof a2.HTMLIFrameElement; ) {
      try {
        var c = "string" == typeof b.contentWindow.location.href;
      } catch (d) {
        c = false;
      }
      if (!c)
        break;
      b = Xa((a2 = b.contentWindow).document);
    }
    return b;
  }
  function Ne(a2) {
    var b = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return b && ("input" === b && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b || "true" === a2.contentEditable);
  }
  function Oe(a2) {
    var b = Me(), c = a2.focusedElem, d = a2.selectionRange;
    if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
      if (null !== d && Ne(c)) {
        if (b = d.start, void 0 === (a2 = d.end) && (a2 = b), "selectionStart" in c)
          c.selectionStart = b, c.selectionEnd = Math.min(a2, c.value.length);
        else if ((a2 = (b = c.ownerDocument || document) && b.defaultView || window).getSelection) {
          a2 = a2.getSelection();
          var e = c.textContent.length, f = Math.min(d.start, e);
          d = void 0 === d.end ? f : Math.min(d.end, e), !a2.extend && f > d && (e = d, d = f, f = e), e = Ke(c, f);
          var g = Ke(c, d);
          e && g && (1 !== a2.rangeCount || a2.anchorNode !== e.node || a2.anchorOffset !== e.offset || a2.focusNode !== g.node || a2.focusOffset !== g.offset) && ((b = b.createRange()).setStart(e.node, e.offset), a2.removeAllRanges(), f > d ? (a2.addRange(b), a2.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a2.addRange(b)));
        }
      }
      for (b = [], a2 = c; a2 = a2.parentNode; )
        1 === a2.nodeType && b.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
      for ("function" == typeof c.focus && c.focus(), c = 0; c < b.length; c++)
        (a2 = b[c]).element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
  function Ue(a2, b, c) {
    var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
    Te || null == Qe || Qe !== Xa(d) || (d = "selectionStart" in (d = Qe) && Ne(d) ? { start: d.selectionStart, end: d.selectionEnd } : { anchorNode: (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection()).anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }, Se && Ie(Se, d) || (Se = d, 0 < (d = oe(Re, "onSelect")).length && (b = new td("onSelect", "select", null, b, c), a2.push({ event: b, listeners: d }), b.target = Qe)));
  }
  function Ve(a2, b) {
    var c = {};
    return c[a2.toLowerCase()] = b.toLowerCase(), c["Webkit" + a2] = "webkit" + b, c["Moz" + a2] = "moz" + b, c;
  }
  var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
  function Ze(a2) {
    if (Xe[a2])
      return Xe[a2];
    if (!We[a2])
      return a2;
    var c, b = We[a2];
    for (c in b)
      if (b.hasOwnProperty(c) && c in Ye)
        return Xe[a2] = b[c];
    return a2;
  }
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a2, b) {
    df.set(a2, b), fa(b, [a2]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf];
    ff(hf.toLowerCase(), "on" + (hf[0].toUpperCase() + hf.slice(1)));
  }
  ff($e, "onAnimationEnd"), ff(af, "onAnimationIteration"), ff(bf, "onAnimationStart"), ff("dblclick", "onDoubleClick"), ff("focusin", "onFocus"), ff("focusout", "onBlur"), ff(cf, "onTransitionEnd"), ha("onMouseEnter", ["mouseout", "mouseover"]), ha("onMouseLeave", ["mouseout", "mouseover"]), ha("onPointerEnter", ["pointerout", "pointerover"]), ha("onPointerLeave", ["pointerout", "pointerover"]), fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a2, b, c) {
    var d = a2.type || "unknown-event";
    a2.currentTarget = c, function(a3, b2, c2, d2, e, f, g, h, k) {
      if (Tb.apply(this, arguments), Ob) {
        if (!Ob)
          throw Error(p(198));
        var l = Pb;
        Ob = false, Pb = null, Qb || (Qb = true, Rb = l);
      }
    }(d, b, void 0, a2), a2.currentTarget = null;
  }
  function se(a2, b) {
    b = !!(4 & b);
    for (var c = 0; c < a2.length; c++) {
      var d = a2[c], e = d.event;
      d = d.listeners;
      a: {
        var f = void 0;
        if (b)
          for (var g = d.length - 1; 0 <= g; g--) {
            var h = d[g], k = h.instance, l = h.currentTarget;
            if (h = h.listener, k !== f && e.isPropagationStopped())
              break a;
            nf(e, h, l), f = k;
          }
        else
          for (g = 0; g < d.length; g++) {
            if (k = (h = d[g]).instance, l = h.currentTarget, h = h.listener, k !== f && e.isPropagationStopped())
              break a;
            nf(e, h, l), f = k;
          }
      }
    }
    if (Qb)
      throw a2 = Rb, Qb = false, Rb = null, a2;
  }
  function D(a2, b) {
    var c = b[of];
    void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
    var d = a2 + "__bubble";
    c.has(d) || (pf(b, a2, 2, false), c.add(d));
  }
  function qf(a2, b, c) {
    var d = 0;
    b && (d |= 4), pf(c, a2, d, b);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a2) {
    if (!a2[rf]) {
      a2[rf] = true, da.forEach(function(b2) {
        "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a2), qf(b2, true, a2));
      });
      var b = 9 === a2.nodeType ? a2 : a2.ownerDocument;
      null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
    }
  }
  function pf(a2, b, c, d) {
    switch (jd(b)) {
      case 1:
        var e = ed;
        break;
      case 4:
        e = gd;
        break;
      default:
        e = fd;
    }
    c = e.bind(null, b, c, a2), e = void 0, !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true), d ? void 0 !== e ? a2.addEventListener(b, c, { capture: true, passive: e }) : a2.addEventListener(b, c, true) : void 0 !== e ? a2.addEventListener(b, c, { passive: e }) : a2.addEventListener(b, c, false);
  }
  function hd(a2, b, c, d, e) {
    var f = d;
    if (!(1 & b || 2 & b || null === d))
      a:
        for (; ; ) {
          if (null === d)
            return;
          var g = d.tag;
          if (3 === g || 4 === g) {
            var h = d.stateNode.containerInfo;
            if (h === e || 8 === h.nodeType && h.parentNode === e)
              break;
            if (4 === g)
              for (g = d.return; null !== g; ) {
                var k = g.tag;
                if ((3 === k || 4 === k) && ((k = g.stateNode.containerInfo) === e || 8 === k.nodeType && k.parentNode === e))
                  return;
                g = g.return;
              }
            for (; null !== h; ) {
              if (null === (g = Wc(h)))
                return;
              if (5 === (k = g.tag) || 6 === k) {
                d = f = g;
                continue a;
              }
              h = h.parentNode;
            }
          }
          d = d.return;
        }
    Jb(function() {
      var d2 = f, e2 = xb(c), g2 = [];
      a: {
        var h2 = df.get(a2);
        if (void 0 !== h2) {
          var k2 = td, n = a2;
          switch (a2) {
            case "keypress":
              if (0 === od(c))
                break a;
            case "keydown":
            case "keyup":
              k2 = Rd;
              break;
            case "focusin":
              n = "focus", k2 = Fd;
              break;
            case "focusout":
              n = "blur", k2 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k2 = Fd;
              break;
            case "click":
              if (2 === c.button)
                break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k2 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k2 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k2 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k2 = Hd;
              break;
            case cf:
              k2 = Xd;
              break;
            case "scroll":
              k2 = vd;
              break;
            case "wheel":
              k2 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k2 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k2 = Td;
          }
          var t = !!(4 & b), J = !t && "scroll" === a2, x = t ? null !== h2 ? h2 + "Capture" : null : h2;
          t = [];
          for (var u, w = d2; null !== w; ) {
            var F = (u = w).stateNode;
            if (5 === u.tag && null !== F && (u = F, null !== x && null != (F = Kb(w, x)) && t.push(tf(w, F, u))), J)
              break;
            w = w.return;
          }
          0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
        }
      }
      if (!(7 & b)) {
        if (k2 = "mouseout" === a2 || "pointerout" === a2, (!(h2 = "mouseover" === a2 || "pointerover" === a2) || c === wb || !(n = c.relatedTarget || c.fromElement) || !Wc(n) && !n[uf]) && (k2 || h2) && (h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window, k2 ? (k2 = d2, null !== (n = (n = c.relatedTarget || c.toElement) ? Wc(n) : null) && (n !== (J = Vb(n)) || 5 !== n.tag && 6 !== n.tag) && (n = null)) : (k2 = null, n = d2), k2 !== n)) {
          if (t = Bd, F = "onMouseLeave", x = "onMouseEnter", w = "mouse", "pointerout" !== a2 && "pointerover" !== a2 || (t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer"), J = null == k2 ? h2 : ue(k2), u = null == n ? h2 : ue(n), (h2 = new t(F, w + "leave", k2, c, e2)).target = J, h2.relatedTarget = u, F = null, Wc(e2) === d2 && ((t = new t(x, w + "enter", n, c, e2)).target = u, t.relatedTarget = J, F = t), J = F, k2 && n)
            b: {
              for (x = n, w = 0, u = t = k2; u; u = vf(u))
                w++;
              for (u = 0, F = x; F; F = vf(F))
                u++;
              for (; 0 < w - u; )
                t = vf(t), w--;
              for (; 0 < u - w; )
                x = vf(x), u--;
              for (; w--; ) {
                if (t === x || null !== x && t === x.alternate)
                  break b;
                t = vf(t), x = vf(x);
              }
              t = null;
            }
          else
            t = null;
          null !== k2 && wf(g2, h2, k2, t, false), null !== n && null !== J && wf(g2, J, n, t, true);
        }
        if ("select" === (k2 = (h2 = d2 ? ue(d2) : window).nodeName && h2.nodeName.toLowerCase()) || "input" === k2 && "file" === h2.type)
          var na = ve;
        else if (me(h2))
          if (we)
            na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
        else
          (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
        switch (na && (na = na(a2, d2)) ? ne(g2, na, c, e2) : (xa && xa(a2, h2, d2), "focusout" === a2 && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value)), xa = d2 ? ue(d2) : window, a2) {
          case "focusin":
            (me(xa) || "true" === xa.contentEditable) && (Qe = xa, Re = d2, Se = null);
            break;
          case "focusout":
            Se = Re = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false, Ue(g2, c, e2);
            break;
          case "selectionchange":
            if (Pe)
              break;
          case "keydown":
          case "keyup":
            Ue(g2, c, e2);
        }
        var $a;
        if (ae)
          b: {
            switch (a2) {
              case "compositionstart":
                var ba = "onCompositionStart";
                break b;
              case "compositionend":
                ba = "onCompositionEnd";
                break b;
              case "compositionupdate":
                ba = "onCompositionUpdate";
                break b;
            }
            ba = void 0;
          }
        else
          ie ? ge(a2, c) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (ld = "value" in (kd = e2) ? kd.value : kd.textContent, ie = true)), 0 < (xa = oe(d2, ba)).length && (ba = new Ld(ba, a2, null, c, e2), g2.push({ event: ba, listeners: xa }), ($a || null !== ($a = he(c))) && (ba.data = $a))), ($a = ce ? function(a3, b2) {
          switch (a3) {
            case "compositionend":
              return he(b2);
            case "keypress":
              return 32 !== b2.which ? null : (fe = true, ee);
            case "textInput":
              return (a3 = b2.data) === ee && fe ? null : a3;
            default:
              return null;
          }
        }(a2, c) : function(a3, b2) {
          if (ie)
            return "compositionend" === a3 || !ae && ge(a3, b2) ? (a3 = nd(), md = ld = kd = null, ie = false, a3) : null;
          switch (a3) {
            case "paste":
            default:
              return null;
            case "keypress":
              if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
                if (b2.char && 1 < b2.char.length)
                  return b2.char;
                if (b2.which)
                  return String.fromCharCode(b2.which);
              }
              return null;
            case "compositionend":
              return de && "ko" !== b2.locale ? null : b2.data;
          }
        }(a2, c)) && 0 < (d2 = oe(d2, "onBeforeInput")).length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
      }
      se(g2, b);
    });
  }
  function tf(a2, b, c) {
    return { instance: a2, listener: b, currentTarget: c };
  }
  function oe(a2, b) {
    for (var c = b + "Capture", d = []; null !== a2; ) {
      var e = a2, f = e.stateNode;
      5 === e.tag && null !== f && (e = f, null != (f = Kb(a2, c)) && d.unshift(tf(a2, f, e)), null != (f = Kb(a2, b)) && d.push(tf(a2, f, e))), a2 = a2.return;
    }
    return d;
  }
  function vf(a2) {
    if (null === a2)
      return null;
    do {
      a2 = a2.return;
    } while (a2 && 5 !== a2.tag);
    return a2 || null;
  }
  function wf(a2, b, c, d, e) {
    for (var f = b._reactName, g = []; null !== c && c !== d; ) {
      var h = c, k = h.alternate, l = h.stateNode;
      if (null !== k && k === d)
        break;
      5 === h.tag && null !== l && (h = l, e ? null != (k = Kb(c, f)) && g.unshift(tf(c, k, h)) : e || null != (k = Kb(c, f)) && g.push(tf(c, k, h))), c = c.return;
    }
    0 !== g.length && a2.push({ event: b, listeners: g });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a2) {
    return ("string" == typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
  }
  function Af(a2, b, c) {
    if (b = zf(b), zf(a2) !== b && c)
      throw Error(p(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a2, b) {
    return "textarea" === a2 || "noscript" === a2 || "string" == typeof b.children || "number" == typeof b.children || "object" == typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" == typeof setTimeout ? setTimeout : void 0, Gf = "function" == typeof clearTimeout ? clearTimeout : void 0, Hf = "function" == typeof Promise ? Promise : void 0, Jf = "function" == typeof queueMicrotask ? queueMicrotask : void 0 !== Hf ? function(a2) {
    return Hf.resolve(null).then(a2).catch(If);
  } : Ff;
  function If(a2) {
    setTimeout(function() {
      throw a2;
    });
  }
  function Kf(a2, b) {
    var c = b, d = 0;
    do {
      var e = c.nextSibling;
      if (a2.removeChild(c), e && 8 === e.nodeType)
        if ("/$" === (c = e.data)) {
          if (0 === d)
            return a2.removeChild(e), void bd(b);
          d--;
        } else
          "$" !== c && "$?" !== c && "$!" !== c || d++;
      c = e;
    } while (c);
    bd(b);
  }
  function Lf(a2) {
    for (; null != a2; a2 = a2.nextSibling) {
      var b = a2.nodeType;
      if (1 === b || 3 === b)
        break;
      if (8 === b) {
        if ("$" === (b = a2.data) || "$!" === b || "$?" === b)
          break;
        if ("/$" === b)
          return null;
      }
    }
    return a2;
  }
  function Mf(a2) {
    a2 = a2.previousSibling;
    for (var b = 0; a2; ) {
      if (8 === a2.nodeType) {
        var c = a2.data;
        if ("$" === c || "$!" === c || "$?" === c) {
          if (0 === b)
            return a2;
          b--;
        } else
          "/$" === c && b++;
      }
      a2 = a2.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a2) {
    var b = a2[Of];
    if (b)
      return b;
    for (var c = a2.parentNode; c; ) {
      if (b = c[uf] || c[Of]) {
        if (c = b.alternate, null !== b.child || null !== c && null !== c.child)
          for (a2 = Mf(a2); null !== a2; ) {
            if (c = a2[Of])
              return c;
            a2 = Mf(a2);
          }
        return b;
      }
      c = (a2 = c).parentNode;
    }
    return null;
  }
  function Cb(a2) {
    return !(a2 = a2[Of] || a2[uf]) || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
  }
  function ue(a2) {
    if (5 === a2.tag || 6 === a2.tag)
      return a2.stateNode;
    throw Error(p(33));
  }
  function Db(a2) {
    return a2[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a2) {
    return { current: a2 };
  }
  function E(a2) {
    0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G(a2, b) {
    Tf++, Sf[Tf] = a2.current, a2.current = b;
  }
  var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a2, b) {
    var c = a2.type.contextTypes;
    if (!c)
      return Vf;
    var d = a2.stateNode;
    if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
      return d.__reactInternalMemoizedMaskedChildContext;
    var f, e = {};
    for (f in c)
      e[f] = b[f];
    return d && ((a2 = a2.stateNode).__reactInternalMemoizedUnmaskedChildContext = b, a2.__reactInternalMemoizedMaskedChildContext = e), e;
  }
  function Zf(a2) {
    return null != a2.childContextTypes;
  }
  function $f() {
    E(Wf), E(H);
  }
  function ag(a2, b, c) {
    if (H.current !== Vf)
      throw Error(p(168));
    G(H, b), G(Wf, c);
  }
  function bg(a2, b, c) {
    var d = a2.stateNode;
    if (b = b.childContextTypes, "function" != typeof d.getChildContext)
      return c;
    for (var e in d = d.getChildContext())
      if (!(e in b))
        throw Error(p(108, Ra(a2) || "Unknown", e));
    return A({}, c, d);
  }
  function cg(a2) {
    return a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf, Xf = H.current, G(H, a2), G(Wf, Wf.current), true;
  }
  function dg(a2, b, c) {
    var d = a2.stateNode;
    if (!d)
      throw Error(p(169));
    c ? (a2 = bg(a2, b, Xf), d.__reactInternalMemoizedMergedChildContext = a2, E(Wf), E(H), G(H, a2)) : E(Wf), G(Wf, c);
  }
  var eg = null, fg = false, gg = false;
  function hg(a2) {
    null === eg ? eg = [a2] : eg.push(a2);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a2 = 0, b = C;
      try {
        var c = eg;
        for (C = 1; a2 < c.length; a2++) {
          var d = c[a2];
          do {
            d = d(true);
          } while (null !== d);
        }
        eg = null, fg = false;
      } catch (e) {
        throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e;
      } finally {
        C = b, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a2, b) {
    kg[lg++] = ng, kg[lg++] = mg, mg = a2, ng = b;
  }
  function ug(a2, b, c) {
    og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, qg = a2;
    var d = rg;
    a2 = sg;
    var e = 32 - oc(d) - 1;
    d &= ~(1 << e), c += 1;
    var f = 32 - oc(b) + e;
    if (30 < f) {
      var g = e - e % 5;
      f = (d & (1 << g) - 1).toString(32), d >>= g, e -= g, rg = 1 << 32 - oc(b) + e | c << e | d, sg = f + a2;
    } else
      rg = 1 << f | c << e | d, sg = a2;
  }
  function vg(a2) {
    null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
  }
  function wg(a2) {
    for (; a2 === mg; )
      mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a2 === qg; )
      qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I = false, zg = null;
  function Ag(a2, b) {
    var c = Bg(5, null, null, 0);
    c.elementType = "DELETED", c.stateNode = b, c.return = a2, null === (b = a2.deletions) ? (a2.deletions = [c], a2.flags |= 16) : b.push(c);
  }
  function Cg(a2, b) {
    switch (a2.tag) {
      case 5:
        var c = a2.type;
        return null !== (b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b) && (a2.stateNode = b, xg = a2, yg = Lf(b.firstChild), true);
      case 6:
        return null !== (b = "" === a2.pendingProps || 3 !== b.nodeType ? null : b) && (a2.stateNode = b, xg = a2, yg = null, true);
      case 13:
        return null !== (b = 8 !== b.nodeType ? null : b) && (c = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, (c = Bg(18, null, null, 0)).stateNode = b, c.return = a2, a2.child = c, xg = a2, yg = null, true);
      default:
        return false;
    }
  }
  function Dg(a2) {
    return !(!(1 & a2.mode) || 128 & a2.flags);
  }
  function Eg(a2) {
    if (I) {
      var b = yg;
      if (b) {
        var c = b;
        if (!Cg(a2, b)) {
          if (Dg(a2))
            throw Error(p(418));
          b = Lf(c.nextSibling);
          var d = xg;
          b && Cg(a2, b) ? Ag(d, c) : (a2.flags = -4097 & a2.flags | 2, I = false, xg = a2);
        }
      } else {
        if (Dg(a2))
          throw Error(p(418));
        a2.flags = -4097 & a2.flags | 2, I = false, xg = a2;
      }
    }
  }
  function Fg(a2) {
    for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
      a2 = a2.return;
    xg = a2;
  }
  function Gg(a2) {
    if (a2 !== xg)
      return false;
    if (!I)
      return Fg(a2), I = true, false;
    var b;
    if ((b = 3 !== a2.tag) && !(b = 5 !== a2.tag) && (b = "head" !== (b = a2.type) && "body" !== b && !Ef(a2.type, a2.memoizedProps)), b && (b = yg)) {
      if (Dg(a2))
        throw Hg(), Error(p(418));
      for (; b; )
        Ag(a2, b), b = Lf(b.nextSibling);
    }
    if (Fg(a2), 13 === a2.tag) {
      if (!(a2 = null !== (a2 = a2.memoizedState) ? a2.dehydrated : null))
        throw Error(p(317));
      a: {
        for (a2 = a2.nextSibling, b = 0; a2; ) {
          if (8 === a2.nodeType) {
            var c = a2.data;
            if ("/$" === c) {
              if (0 === b) {
                yg = Lf(a2.nextSibling);
                break a;
              }
              b--;
            } else
              "$" !== c && "$!" !== c && "$?" !== c || b++;
          }
          a2 = a2.nextSibling;
        }
        yg = null;
      }
    } else
      yg = xg ? Lf(a2.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a2 = yg; a2; )
      a2 = Lf(a2.nextSibling);
  }
  function Ig() {
    yg = xg = null, I = false;
  }
  function Jg(a2) {
    null === zg ? zg = [a2] : zg.push(a2);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a2, b) {
    if (a2 && a2.defaultProps) {
      for (var c in b = A({}, b), a2 = a2.defaultProps)
        void 0 === b[c] && (b[c] = a2[c]);
      return b;
    }
    return b;
  }
  var Mg = Uf(null), Ng = null, Og = null, Pg = null;
  function Qg() {
    Pg = Og = Ng = null;
  }
  function Rg(a2) {
    var b = Mg.current;
    E(Mg), a2._currentValue = b;
  }
  function Sg(a2, b, c) {
    for (; null !== a2; ) {
      var d = a2.alternate;
      if ((a2.childLanes & b) !== b ? (a2.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b), a2 === c)
        break;
      a2 = a2.return;
    }
  }
  function Tg(a2, b) {
    Ng = a2, Pg = Og = null, null !== (a2 = a2.dependencies) && null !== a2.firstContext && (!!(a2.lanes & b) && (Ug = true), a2.firstContext = null);
  }
  function Vg(a2) {
    var b = a2._currentValue;
    if (Pg !== a2)
      if (a2 = { context: a2, memoizedValue: b, next: null }, null === Og) {
        if (null === Ng)
          throw Error(p(308));
        Og = a2, Ng.dependencies = { lanes: 0, firstContext: a2 };
      } else
        Og = Og.next = a2;
    return b;
  }
  var Wg = null;
  function Xg(a2) {
    null === Wg ? Wg = [a2] : Wg.push(a2);
  }
  function Yg(a2, b, c, d) {
    var e = b.interleaved;
    return null === e ? (c.next = c, Xg(b)) : (c.next = e.next, e.next = c), b.interleaved = c, Zg(a2, d);
  }
  function Zg(a2, b) {
    a2.lanes |= b;
    var c = a2.alternate;
    for (null !== c && (c.lanes |= b), c = a2, a2 = a2.return; null !== a2; )
      a2.childLanes |= b, null !== (c = a2.alternate) && (c.childLanes |= b), c = a2, a2 = a2.return;
    return 3 === c.tag ? c.stateNode : null;
  }
  var $g = false;
  function ah(a2) {
    a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function bh(a2, b) {
    a2 = a2.updateQueue, b.updateQueue === a2 && (b.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
  }
  function ch(a2, b) {
    return { eventTime: a2, lane: b, tag: 0, payload: null, callback: null, next: null };
  }
  function dh(a2, b, c) {
    var d = a2.updateQueue;
    if (null === d)
      return null;
    if (d = d.shared, 2 & K) {
      var e = d.pending;
      return null === e ? b.next = b : (b.next = e.next, e.next = b), d.pending = b, Zg(a2, c);
    }
    return null === (e = d.interleaved) ? (b.next = b, Xg(d)) : (b.next = e.next, e.next = b), d.interleaved = b, Zg(a2, c);
  }
  function eh(a2, b, c) {
    if (null !== (b = b.updateQueue) && (b = b.shared, 4194240 & c)) {
      var d = b.lanes;
      c |= d &= a2.pendingLanes, b.lanes = c, Cc(a2, c);
    }
  }
  function fh(a2, b) {
    var c = a2.updateQueue, d = a2.alternate;
    if (null !== d && c === (d = d.updateQueue)) {
      var e = null, f = null;
      if (null !== (c = c.firstBaseUpdate)) {
        do {
          var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
          null === f ? e = f = g : f = f.next = g, c = c.next;
        } while (null !== c);
        null === f ? e = f = b : f = f.next = b;
      } else
        e = f = b;
      return c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects }, void (a2.updateQueue = c);
    }
    null === (a2 = c.lastBaseUpdate) ? c.firstBaseUpdate = b : a2.next = b, c.lastBaseUpdate = b;
  }
  function gh(a2, b, c, d) {
    var e = a2.updateQueue;
    $g = false;
    var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
    if (null !== h) {
      e.shared.pending = null;
      var k = h, l = k.next;
      k.next = null, null === g ? f = l : g.next = l, g = k;
      var m = a2.alternate;
      null !== m && (h = (m = m.updateQueue).lastBaseUpdate) !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k);
    }
    if (null !== f) {
      var q = e.baseState;
      for (g = 0, m = l = k = null, h = f; ; ) {
        var r = h.lane, y = h.eventTime;
        if ((d & r) === r) {
          null !== m && (m = m.next = { eventTime: y, lane: 0, tag: h.tag, payload: h.payload, callback: h.callback, next: null });
          a: {
            var n = a2, t = h;
            switch (r = b, y = c, t.tag) {
              case 1:
                if ("function" == typeof (n = t.payload)) {
                  q = n.call(y, q, r);
                  break a;
                }
                q = n;
                break a;
              case 3:
                n.flags = -65537 & n.flags | 128;
              case 0:
                if (null == (r = "function" == typeof (n = t.payload) ? n.call(y, q, r) : n))
                  break a;
                q = A({}, q, r);
                break a;
              case 2:
                $g = true;
            }
          }
          null !== h.callback && 0 !== h.lane && (a2.flags |= 64, null === (r = e.effects) ? e.effects = [h] : r.push(h));
        } else
          y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
        if (null === (h = h.next)) {
          if (null === (h = e.shared.pending))
            break;
          h = (r = h).next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
        }
      }
      if (null === m && (k = q), e.baseState = k, e.firstBaseUpdate = l, e.lastBaseUpdate = m, null !== (b = e.shared.interleaved)) {
        e = b;
        do {
          g |= e.lane, e = e.next;
        } while (e !== b);
      } else
        null === f && (e.shared.lanes = 0);
      hh |= g, a2.lanes = g, a2.memoizedState = q;
    }
  }
  function ih(a2, b, c) {
    if (a2 = b.effects, b.effects = null, null !== a2)
      for (b = 0; b < a2.length; b++) {
        var d = a2[b], e = d.callback;
        if (null !== e) {
          if (d.callback = null, d = c, "function" != typeof e)
            throw Error(p(191, e));
          e.call(d);
        }
      }
  }
  var jh = new aa.Component().refs;
  function kh(a2, b, c, d) {
    c = null == (c = c(d, b = a2.memoizedState)) ? b : A({}, b, c), a2.memoizedState = c, 0 === a2.lanes && (a2.updateQueue.baseState = c);
  }
  var nh = { isMounted: function(a2) {
    return !!(a2 = a2._reactInternals) && Vb(a2) === a2;
  }, enqueueSetState: function(a2, b, c) {
    a2 = a2._reactInternals;
    var d = L(), e = lh(a2), f = ch(d, e);
    f.payload = b, null != c && (f.callback = c), null !== (b = dh(a2, f, e)) && (mh(b, a2, e, d), eh(b, a2, e));
  }, enqueueReplaceState: function(a2, b, c) {
    a2 = a2._reactInternals;
    var d = L(), e = lh(a2), f = ch(d, e);
    f.tag = 1, f.payload = b, null != c && (f.callback = c), null !== (b = dh(a2, f, e)) && (mh(b, a2, e, d), eh(b, a2, e));
  }, enqueueForceUpdate: function(a2, b) {
    a2 = a2._reactInternals;
    var c = L(), d = lh(a2), e = ch(c, d);
    e.tag = 2, null != b && (e.callback = b), null !== (b = dh(a2, e, d)) && (mh(b, a2, d, c), eh(b, a2, d));
  } };
  function oh(a2, b, c, d, e, f, g) {
    return "function" == typeof (a2 = a2.stateNode).shouldComponentUpdate ? a2.shouldComponentUpdate(d, f, g) : !(b.prototype && b.prototype.isPureReactComponent && Ie(c, d) && Ie(e, f));
  }
  function ph(a2, b, c) {
    var d = false, e = Vf, f = b.contextType;
    return "object" == typeof f && null !== f ? f = Vg(f) : (e = Zf(b) ? Xf : H.current, f = (d = null != (d = b.contextTypes)) ? Yf(a2, e) : Vf), b = new b(c, f), a2.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null, b.updater = nh, a2.stateNode = b, b._reactInternals = a2, d && ((a2 = a2.stateNode).__reactInternalMemoizedUnmaskedChildContext = e, a2.__reactInternalMemoizedMaskedChildContext = f), b;
  }
  function qh(a2, b, c, d) {
    a2 = b.state, "function" == typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d), "function" == typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d), b.state !== a2 && nh.enqueueReplaceState(b, b.state, null);
  }
  function rh(a2, b, c, d) {
    var e = a2.stateNode;
    e.props = c, e.state = a2.memoizedState, e.refs = jh, ah(a2);
    var f = b.contextType;
    "object" == typeof f && null !== f ? e.context = Vg(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a2, f)), e.state = a2.memoizedState, "function" == typeof (f = b.getDerivedStateFromProps) && (kh(a2, b, f, c), e.state = a2.memoizedState), "function" == typeof b.getDerivedStateFromProps || "function" == typeof e.getSnapshotBeforeUpdate || "function" != typeof e.UNSAFE_componentWillMount && "function" != typeof e.componentWillMount || (b = e.state, "function" == typeof e.componentWillMount && e.componentWillMount(), "function" == typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && nh.enqueueReplaceState(e, e.state, null), gh(a2, c, e, d), e.state = a2.memoizedState), "function" == typeof e.componentDidMount && (a2.flags |= 4194308);
  }
  function sh(a2, b, c) {
    if (null !== (a2 = c.ref) && "function" != typeof a2 && "object" != typeof a2) {
      if (c._owner) {
        if (c = c._owner) {
          if (1 !== c.tag)
            throw Error(p(309));
          var d = c.stateNode;
        }
        if (!d)
          throw Error(p(147, a2));
        var e = d, f = "" + a2;
        return null !== b && null !== b.ref && "function" == typeof b.ref && b.ref._stringRef === f ? b.ref : (b = function(a3) {
          var b2 = e.refs;
          b2 === jh && (b2 = e.refs = {}), null === a3 ? delete b2[f] : b2[f] = a3;
        }, b._stringRef = f, b);
      }
      if ("string" != typeof a2)
        throw Error(p(284));
      if (!c._owner)
        throw Error(p(290, a2));
    }
    return a2;
  }
  function th(a2, b) {
    throw a2 = Object.prototype.toString.call(b), Error(p(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b).join(", ") + "}" : a2));
  }
  function uh(a2) {
    return (0, a2._init)(a2._payload);
  }
  function vh(a2) {
    function b(b2, c2) {
      if (a2) {
        var d2 = b2.deletions;
        null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
      }
    }
    function c(c2, d2) {
      if (!a2)
        return null;
      for (; null !== d2; )
        b(c2, d2), d2 = d2.sibling;
      return null;
    }
    function d(a3, b2) {
      for (a3 = /* @__PURE__ */ new Map(); null !== b2; )
        null !== b2.key ? a3.set(b2.key, b2) : a3.set(b2.index, b2), b2 = b2.sibling;
      return a3;
    }
    function e(a3, b2) {
      return (a3 = wh(a3, b2)).index = 0, a3.sibling = null, a3;
    }
    function f(b2, c2, d2) {
      return b2.index = d2, a2 ? null !== (d2 = b2.alternate) ? (d2 = d2.index) < c2 ? (b2.flags |= 2, c2) : d2 : (b2.flags |= 2, c2) : (b2.flags |= 1048576, c2);
    }
    function g(b2) {
      return a2 && null === b2.alternate && (b2.flags |= 2), b2;
    }
    function h(a3, b2, c2, d2) {
      return null === b2 || 6 !== b2.tag ? ((b2 = xh(c2, a3.mode, d2)).return = a3, b2) : ((b2 = e(b2, c2)).return = a3, b2);
    }
    function k(a3, b2, c2, d2) {
      var f2 = c2.type;
      return f2 === ya ? m(a3, b2, c2.props.children, d2, c2.key) : null !== b2 && (b2.elementType === f2 || "object" == typeof f2 && null !== f2 && f2.$$typeof === Ha && uh(f2) === b2.type) ? ((d2 = e(b2, c2.props)).ref = sh(a3, b2, c2), d2.return = a3, d2) : ((d2 = yh(c2.type, c2.key, c2.props, null, a3.mode, d2)).ref = sh(a3, b2, c2), d2.return = a3, d2);
    }
    function l(a3, b2, c2, d2) {
      return null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation ? ((b2 = zh(c2, a3.mode, d2)).return = a3, b2) : ((b2 = e(b2, c2.children || [])).return = a3, b2);
    }
    function m(a3, b2, c2, d2, f2) {
      return null === b2 || 7 !== b2.tag ? ((b2 = Ah(c2, a3.mode, d2, f2)).return = a3, b2) : ((b2 = e(b2, c2)).return = a3, b2);
    }
    function q(a3, b2, c2) {
      if ("string" == typeof b2 && "" !== b2 || "number" == typeof b2)
        return (b2 = xh("" + b2, a3.mode, c2)).return = a3, b2;
      if ("object" == typeof b2 && null !== b2) {
        switch (b2.$$typeof) {
          case va:
            return (c2 = yh(b2.type, b2.key, b2.props, null, a3.mode, c2)).ref = sh(a3, null, b2), c2.return = a3, c2;
          case wa:
            return (b2 = zh(b2, a3.mode, c2)).return = a3, b2;
          case Ha:
            return q(a3, (0, b2._init)(b2._payload), c2);
        }
        if (eb(b2) || Ka(b2))
          return (b2 = Ah(b2, a3.mode, c2, null)).return = a3, b2;
        th(a3, b2);
      }
      return null;
    }
    function r(a3, b2, c2, d2) {
      var e2 = null !== b2 ? b2.key : null;
      if ("string" == typeof c2 && "" !== c2 || "number" == typeof c2)
        return null !== e2 ? null : h(a3, b2, "" + c2, d2);
      if ("object" == typeof c2 && null !== c2) {
        switch (c2.$$typeof) {
          case va:
            return c2.key === e2 ? k(a3, b2, c2, d2) : null;
          case wa:
            return c2.key === e2 ? l(a3, b2, c2, d2) : null;
          case Ha:
            return r(a3, b2, (e2 = c2._init)(c2._payload), d2);
        }
        if (eb(c2) || Ka(c2))
          return null !== e2 ? null : m(a3, b2, c2, d2, null);
        th(a3, c2);
      }
      return null;
    }
    function y(a3, b2, c2, d2, e2) {
      if ("string" == typeof d2 && "" !== d2 || "number" == typeof d2)
        return h(b2, a3 = a3.get(c2) || null, "" + d2, e2);
      if ("object" == typeof d2 && null !== d2) {
        switch (d2.$$typeof) {
          case va:
            return k(b2, a3 = a3.get(null === d2.key ? c2 : d2.key) || null, d2, e2);
          case wa:
            return l(b2, a3 = a3.get(null === d2.key ? c2 : d2.key) || null, d2, e2);
          case Ha:
            return y(a3, b2, c2, (0, d2._init)(d2._payload), e2);
        }
        if (eb(d2) || Ka(d2))
          return m(b2, a3 = a3.get(c2) || null, d2, e2, null);
        th(b2, d2);
      }
      return null;
    }
    function n(e2, g2, h2, k2) {
      for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
        u.index > w ? (x = u, u = null) : x = u.sibling;
        var n2 = r(e2, u, h2[w], k2);
        if (null === n2) {
          null === u && (u = x);
          break;
        }
        a2 && u && null === n2.alternate && b(e2, u), g2 = f(n2, g2, w), null === m2 ? l2 = n2 : m2.sibling = n2, m2 = n2, u = x;
      }
      if (w === h2.length)
        return c(e2, u), I && tg(e2, w), l2;
      if (null === u) {
        for (; w < h2.length; w++)
          null !== (u = q(e2, h2[w], k2)) && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
        return I && tg(e2, w), l2;
      }
      for (u = d(e2, u); w < h2.length; w++)
        null !== (x = y(u, e2, w, h2[w], k2)) && (a2 && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
      return a2 && u.forEach(function(a3) {
        return b(e2, a3);
      }), I && tg(e2, w), l2;
    }
    function t(e2, g2, h2, k2) {
      var l2 = Ka(h2);
      if ("function" != typeof l2)
        throw Error(p(150));
      if (null == (h2 = l2.call(h2)))
        throw Error(p(151));
      for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); null !== m2 && !n2.done; w++, n2 = h2.next()) {
        m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
        var t2 = r(e2, m2, n2.value, k2);
        if (null === t2) {
          null === m2 && (m2 = x);
          break;
        }
        a2 && m2 && null === t2.alternate && b(e2, m2), g2 = f(t2, g2, w), null === u ? l2 = t2 : u.sibling = t2, u = t2, m2 = x;
      }
      if (n2.done)
        return c(e2, m2), I && tg(e2, w), l2;
      if (null === m2) {
        for (; !n2.done; w++, n2 = h2.next())
          null !== (n2 = q(e2, n2.value, k2)) && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
        return I && tg(e2, w), l2;
      }
      for (m2 = d(e2, m2); !n2.done; w++, n2 = h2.next())
        null !== (n2 = y(m2, e2, w, n2.value, k2)) && (a2 && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
      return a2 && m2.forEach(function(a3) {
        return b(e2, a3);
      }), I && tg(e2, w), l2;
    }
    return function J(a3, d2, f2, h2) {
      if ("object" == typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children), "object" == typeof f2 && null !== f2) {
        switch (f2.$$typeof) {
          case va:
            a: {
              for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                if (l2.key === k2) {
                  if ((k2 = f2.type) === ya) {
                    if (7 === l2.tag) {
                      c(a3, l2.sibling), (d2 = e(l2, f2.props.children)).return = a3, a3 = d2;
                      break a;
                    }
                  } else if (l2.elementType === k2 || "object" == typeof k2 && null !== k2 && k2.$$typeof === Ha && uh(k2) === l2.type) {
                    c(a3, l2.sibling), (d2 = e(l2, f2.props)).ref = sh(a3, l2, f2), d2.return = a3, a3 = d2;
                    break a;
                  }
                  c(a3, l2);
                  break;
                }
                b(a3, l2), l2 = l2.sibling;
              }
              f2.type === ya ? ((d2 = Ah(f2.props.children, a3.mode, h2, f2.key)).return = a3, a3 = d2) : ((h2 = yh(f2.type, f2.key, f2.props, null, a3.mode, h2)).ref = sh(a3, d2, f2), h2.return = a3, a3 = h2);
            }
            return g(a3);
          case wa:
            a: {
              for (l2 = f2.key; null !== d2; ) {
                if (d2.key === l2) {
                  if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                    c(a3, d2.sibling), (d2 = e(d2, f2.children || [])).return = a3, a3 = d2;
                    break a;
                  }
                  c(a3, d2);
                  break;
                }
                b(a3, d2), d2 = d2.sibling;
              }
              (d2 = zh(f2, a3.mode, h2)).return = a3, a3 = d2;
            }
            return g(a3);
          case Ha:
            return J(a3, d2, (l2 = f2._init)(f2._payload), h2);
        }
        if (eb(f2))
          return n(a3, d2, f2, h2);
        if (Ka(f2))
          return t(a3, d2, f2, h2);
        th(a3, f2);
      }
      return "string" == typeof f2 && "" !== f2 || "number" == typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a3, d2.sibling), (d2 = e(d2, f2)).return = a3, a3 = d2) : (c(a3, d2), (d2 = xh(f2, a3.mode, h2)).return = a3, a3 = d2), g(a3)) : c(a3, d2);
    };
  }
  var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
  function Hh(a2) {
    if (a2 === Dh)
      throw Error(p(174));
    return a2;
  }
  function Ih(a2, b) {
    switch (G(Gh, b), G(Fh, a2), G(Eh, Dh), a2 = b.nodeType) {
      case 9:
      case 11:
        b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
        break;
      default:
        b = lb(b = (a2 = 8 === a2 ? b.parentNode : b).namespaceURI || null, a2 = a2.tagName);
    }
    E(Eh), G(Eh, b);
  }
  function Jh() {
    E(Eh), E(Fh), E(Gh);
  }
  function Kh(a2) {
    Hh(Gh.current);
    var b = Hh(Eh.current), c = lb(b, a2.type);
    b !== c && (G(Fh, a2), G(Eh, c));
  }
  function Lh(a2) {
    Fh.current === a2 && (E(Eh), E(Fh));
  }
  var M = Uf(0);
  function Mh(a2) {
    for (var b = a2; null !== b; ) {
      if (13 === b.tag) {
        var c = b.memoizedState;
        if (null !== c && (null === (c = c.dehydrated) || "$?" === c.data || "$!" === c.data))
          return b;
      } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
        if (128 & b.flags)
          return b;
      } else if (null !== b.child) {
        b.child.return = b, b = b.child;
        continue;
      }
      if (b === a2)
        break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a2)
          return null;
        b = b.return;
      }
      b.sibling.return = b.return, b = b.sibling;
    }
    return null;
  }
  var Nh = [];
  function Oh() {
    for (var a2 = 0; a2 < Nh.length; a2++)
      Nh[a2]._workInProgressVersionPrimary = null;
    Nh.length = 0;
  }
  var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
  function Q() {
    throw Error(p(321));
  }
  function Wh(a2, b) {
    if (null === b)
      return false;
    for (var c = 0; c < b.length && c < a2.length; c++)
      if (!He(a2[c], b[c]))
        return false;
    return true;
  }
  function Xh(a2, b, c, d, e, f) {
    if (Rh = f, N = b, b.memoizedState = null, b.updateQueue = null, b.lanes = 0, Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh, a2 = c(d, e), Th) {
      f = 0;
      do {
        if (Th = false, Uh = 0, 25 <= f)
          throw Error(p(301));
        f += 1, P = O = null, b.updateQueue = null, Ph.current = $h, a2 = c(d, e);
      } while (Th);
    }
    if (Ph.current = ai, b = null !== O && null !== O.next, Rh = 0, P = O = N = null, Sh = false, b)
      throw Error(p(300));
    return a2;
  }
  function bi() {
    var a2 = 0 !== Uh;
    return Uh = 0, a2;
  }
  function ci() {
    var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return null === P ? N.memoizedState = P = a2 : P = P.next = a2, P;
  }
  function di() {
    if (null === O) {
      var a2 = N.alternate;
      a2 = null !== a2 ? a2.memoizedState : null;
    } else
      a2 = O.next;
    var b = null === P ? N.memoizedState : P.next;
    if (null !== b)
      P = b, O = a2;
    else {
      if (null === a2)
        throw Error(p(310));
      a2 = { memoizedState: (O = a2).memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null }, null === P ? N.memoizedState = P = a2 : P = P.next = a2;
    }
    return P;
  }
  function ei(a2, b) {
    return "function" == typeof b ? b(a2) : b;
  }
  function fi(a2) {
    var b = di(), c = b.queue;
    if (null === c)
      throw Error(p(311));
    c.lastRenderedReducer = a2;
    var d = O, e = d.baseQueue, f = c.pending;
    if (null !== f) {
      if (null !== e) {
        var g = e.next;
        e.next = f.next, f.next = g;
      }
      d.baseQueue = e = f, c.pending = null;
    }
    if (null !== e) {
      f = e.next, d = d.baseState;
      var h = g = null, k = null, l = f;
      do {
        var m = l.lane;
        if ((Rh & m) === m)
          null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a2(d, l.action);
        else {
          var q = { lane: m, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null };
          null === k ? (h = k = q, g = d) : k = k.next = q, N.lanes |= m, hh |= m;
        }
        l = l.next;
      } while (null !== l && l !== f);
      null === k ? g = d : k.next = h, He(d, b.memoizedState) || (Ug = true), b.memoizedState = d, b.baseState = g, b.baseQueue = k, c.lastRenderedState = d;
    }
    if (null !== (a2 = c.interleaved)) {
      e = a2;
      do {
        f = e.lane, N.lanes |= f, hh |= f, e = e.next;
      } while (e !== a2);
    } else
      null === e && (c.lanes = 0);
    return [b.memoizedState, c.dispatch];
  }
  function gi(a2) {
    var b = di(), c = b.queue;
    if (null === c)
      throw Error(p(311));
    c.lastRenderedReducer = a2;
    var d = c.dispatch, e = c.pending, f = b.memoizedState;
    if (null !== e) {
      c.pending = null;
      var g = e = e.next;
      do {
        f = a2(f, g.action), g = g.next;
      } while (g !== e);
      He(f, b.memoizedState) || (Ug = true), b.memoizedState = f, null === b.baseQueue && (b.baseState = f), c.lastRenderedState = f;
    }
    return [f, d];
  }
  function hi() {
  }
  function ii(a2, b) {
    var c = N, d = di(), e = b(), f = !He(d.memoizedState, e);
    if (f && (d.memoizedState = e, Ug = true), d = d.queue, ji(ki.bind(null, c, d, a2), [a2]), d.getSnapshot !== b || f || null !== P && 1 & P.memoizedState.tag) {
      if (c.flags |= 2048, li(9, mi.bind(null, c, d, e, b), void 0, null), null === R)
        throw Error(p(349));
      30 & Rh || ni(c, b, e);
    }
    return e;
  }
  function ni(a2, b, c) {
    a2.flags |= 16384, a2 = { getSnapshot: b, value: c }, null === (b = N.updateQueue) ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.stores = [a2]) : null === (c = b.stores) ? b.stores = [a2] : c.push(a2);
  }
  function mi(a2, b, c, d) {
    b.value = c, b.getSnapshot = d, oi(b) && pi(a2);
  }
  function ki(a2, b, c) {
    return c(function() {
      oi(b) && pi(a2);
    });
  }
  function oi(a2) {
    var b = a2.getSnapshot;
    a2 = a2.value;
    try {
      var c = b();
      return !He(a2, c);
    } catch (d) {
      return true;
    }
  }
  function pi(a2) {
    var b = Zg(a2, 1);
    null !== b && mh(b, a2, 1, -1);
  }
  function qi(a2) {
    var b = ci();
    return "function" == typeof a2 && (a2 = a2()), b.memoizedState = b.baseState = a2, a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 }, b.queue = a2, a2 = a2.dispatch = ri.bind(null, N, a2), [b.memoizedState, a2];
  }
  function li(a2, b, c, d) {
    return a2 = { tag: a2, create: b, destroy: c, deps: d, next: null }, null === (b = N.updateQueue) ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.lastEffect = a2.next = a2) : null === (c = b.lastEffect) ? b.lastEffect = a2.next = a2 : (d = c.next, c.next = a2, a2.next = d, b.lastEffect = a2), a2;
  }
  function si() {
    return di().memoizedState;
  }
  function ti(a2, b, c, d) {
    var e = ci();
    N.flags |= a2, e.memoizedState = li(1 | b, c, void 0, void 0 === d ? null : d);
  }
  function ui(a2, b, c, d) {
    var e = di();
    d = void 0 === d ? null : d;
    var f = void 0;
    if (null !== O) {
      var g = O.memoizedState;
      if (f = g.destroy, null !== d && Wh(d, g.deps))
        return void (e.memoizedState = li(b, c, f, d));
    }
    N.flags |= a2, e.memoizedState = li(1 | b, c, f, d);
  }
  function vi(a2, b) {
    return ti(8390656, 8, a2, b);
  }
  function ji(a2, b) {
    return ui(2048, 8, a2, b);
  }
  function wi(a2, b) {
    return ui(4, 2, a2, b);
  }
  function xi(a2, b) {
    return ui(4, 4, a2, b);
  }
  function yi(a2, b) {
    return "function" == typeof b ? (a2 = a2(), b(a2), function() {
      b(null);
    }) : null != b ? (a2 = a2(), b.current = a2, function() {
      b.current = null;
    }) : void 0;
  }
  function zi(a2, b, c) {
    return c = null != c ? c.concat([a2]) : null, ui(4, 4, yi.bind(null, b, a2), c);
  }
  function Ai() {
  }
  function Bi(a2, b) {
    var c = di();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    return null !== d && null !== b && Wh(b, d[1]) ? d[0] : (c.memoizedState = [a2, b], a2);
  }
  function Ci(a2, b) {
    var c = di();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    return null !== d && null !== b && Wh(b, d[1]) ? d[0] : (a2 = a2(), c.memoizedState = [a2, b], a2);
  }
  function Di(a2, b, c) {
    return 21 & Rh ? (He(c, b) || (c = yc(), N.lanes |= c, hh |= c, a2.baseState = true), b) : (a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c);
  }
  function Ei(a2, b) {
    var c = C;
    C = 0 !== c && 4 > c ? c : 4, a2(true);
    var d = Qh.transition;
    Qh.transition = {};
    try {
      a2(false), b();
    } finally {
      C = c, Qh.transition = d;
    }
  }
  function Fi() {
    return di().memoizedState;
  }
  function Gi(a2, b, c) {
    var d = lh(a2);
    c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null }, Hi(a2) ? Ii(b, c) : null !== (c = Yg(a2, b, c, d)) && (mh(c, a2, d, L()), Ji(c, b, d));
  }
  function ri(a2, b, c) {
    var d = lh(a2), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
    if (Hi(a2))
      Ii(b, e);
    else {
      var f = a2.alternate;
      if (0 === a2.lanes && (null === f || 0 === f.lanes) && null !== (f = b.lastRenderedReducer))
        try {
          var g = b.lastRenderedState, h = f(g, c);
          if (e.hasEagerState = true, e.eagerState = h, He(h, g)) {
            var k = b.interleaved;
            return null === k ? (e.next = e, Xg(b)) : (e.next = k.next, k.next = e), void (b.interleaved = e);
          }
        } catch (l) {
        }
      null !== (c = Yg(a2, b, e, d)) && (mh(c, a2, d, e = L()), Ji(c, b, d));
    }
  }
  function Hi(a2) {
    var b = a2.alternate;
    return a2 === N || null !== b && b === N;
  }
  function Ii(a2, b) {
    Th = Sh = true;
    var c = a2.pending;
    null === c ? b.next = b : (b.next = c.next, c.next = b), a2.pending = b;
  }
  function Ji(a2, b, c) {
    if (4194240 & c) {
      var d = b.lanes;
      c |= d &= a2.pendingLanes, b.lanes = c, Cc(a2, c);
    }
  }
  var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b) {
    return ci().memoizedState = [a2, void 0 === b ? null : b], a2;
  }, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b, c) {
    return c = null != c ? c.concat([a2]) : null, ti(4194308, 4, yi.bind(null, b, a2), c);
  }, useLayoutEffect: function(a2, b) {
    return ti(4194308, 4, a2, b);
  }, useInsertionEffect: function(a2, b) {
    return ti(4, 2, a2, b);
  }, useMemo: function(a2, b) {
    var c = ci();
    return b = void 0 === b ? null : b, a2 = a2(), c.memoizedState = [a2, b], a2;
  }, useReducer: function(a2, b, c) {
    var d = ci();
    return b = void 0 !== c ? c(b) : b, d.memoizedState = d.baseState = b, a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b }, d.queue = a2, a2 = a2.dispatch = Gi.bind(null, N, a2), [d.memoizedState, a2];
  }, useRef: function(a2) {
    return a2 = { current: a2 }, ci().memoizedState = a2;
  }, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
    return ci().memoizedState = a2;
  }, useTransition: function() {
    var a2 = qi(false), b = a2[0];
    return a2 = Ei.bind(null, a2[1]), ci().memoizedState = a2, [b, a2];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a2, b, c) {
    var d = N, e = ci();
    if (I) {
      if (void 0 === c)
        throw Error(p(407));
      c = c();
    } else {
      if (c = b(), null === R)
        throw Error(p(349));
      30 & Rh || ni(d, b, c);
    }
    e.memoizedState = c;
    var f = { value: c, getSnapshot: b };
    return e.queue = f, vi(ki.bind(null, d, f, a2), [a2]), d.flags |= 2048, li(9, mi.bind(null, d, f, c, b), void 0, null), c;
  }, useId: function() {
    var a2 = ci(), b = R.identifierPrefix;
    if (I) {
      var c = sg;
      b = ":" + b + "R" + (c = (rg & ~(1 << 32 - oc(rg) - 1)).toString(32) + c), 0 < (c = Uh++) && (b += "H" + c.toString(32)), b += ":";
    } else
      b = ":" + b + "r" + (c = Vh++).toString(32) + ":";
    return a2.memoizedState = b;
  }, unstable_isNewReconciler: false }, Zh = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: fi, useRef: si, useState: function() {
    return fi(ei);
  }, useDebugValue: Ai, useDeferredValue: function(a2) {
    return Di(di(), O.memoizedState, a2);
  }, useTransition: function() {
    return [fi(ei)[0], di().memoizedState];
  }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false }, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
    return gi(ei);
  }, useDebugValue: Ai, useDeferredValue: function(a2) {
    var b = di();
    return null === O ? b.memoizedState = a2 : Di(b, O.memoizedState, a2);
  }, useTransition: function() {
    return [gi(ei)[0], di().memoizedState];
  }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
  function Ki(a2, b) {
    try {
      var c = "", d = b;
      do {
        c += Pa(d), d = d.return;
      } while (d);
      var e = c;
    } catch (f) {
      e = "\nError generating stack: " + f.message + "\n" + f.stack;
    }
    return { value: a2, source: b, stack: e, digest: null };
  }
  function Li(a2, b, c) {
    return { value: a2, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
  }
  function Mi(a2, b) {
    try {
      console.error(b.value);
    } catch (c) {
      setTimeout(function() {
        throw c;
      });
    }
  }
  var Ni = "function" == typeof WeakMap ? WeakMap : Map;
  function Oi(a2, b, c) {
    (c = ch(-1, c)).tag = 3, c.payload = { element: null };
    var d = b.value;
    return c.callback = function() {
      Pi || (Pi = true, Qi = d), Mi(0, b);
    }, c;
  }
  function Ri(a2, b, c) {
    (c = ch(-1, c)).tag = 3;
    var d = a2.type.getDerivedStateFromError;
    if ("function" == typeof d) {
      var e = b.value;
      c.payload = function() {
        return d(e);
      }, c.callback = function() {
        Mi(0, b);
      };
    }
    var f = a2.stateNode;
    return null !== f && "function" == typeof f.componentDidCatch && (c.callback = function() {
      Mi(0, b), "function" != typeof d && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
      var c2 = b.stack;
      this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
    }), c;
  }
  function Ti(a2, b, c) {
    var d = a2.pingCache;
    if (null === d) {
      d = a2.pingCache = new Ni();
      var e = /* @__PURE__ */ new Set();
      d.set(b, e);
    } else
      void 0 === (e = d.get(b)) && (e = /* @__PURE__ */ new Set(), d.set(b, e));
    e.has(c) || (e.add(c), a2 = Ui.bind(null, a2, b, c), b.then(a2, a2));
  }
  function Vi(a2) {
    do {
      var b;
      if ((b = 13 === a2.tag) && (b = null === (b = a2.memoizedState) || null !== b.dehydrated), b)
        return a2;
      a2 = a2.return;
    } while (null !== a2);
    return null;
  }
  function Wi(a2, b, c, d, e) {
    return 1 & a2.mode ? (a2.flags |= 65536, a2.lanes = e, a2) : (a2 === b ? a2.flags |= 65536 : (a2.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : ((b = ch(-1, 1)).tag = 2, dh(c, b, 1))), c.lanes |= 1), a2);
  }
  var Xi = ua.ReactCurrentOwner, Ug = false;
  function Yi(a2, b, c, d) {
    b.child = null === a2 ? Ch(b, null, c, d) : Bh(b, a2.child, c, d);
  }
  function Zi(a2, b, c, d, e) {
    c = c.render;
    var f = b.ref;
    return Tg(b, e), d = Xh(a2, b, c, d, f, e), c = bi(), null === a2 || Ug ? (I && c && vg(b), b.flags |= 1, Yi(a2, b, d, e), b.child) : (b.updateQueue = a2.updateQueue, b.flags &= -2053, a2.lanes &= ~e, $i(a2, b, e));
  }
  function aj(a2, b, c, d, e) {
    if (null === a2) {
      var f = c.type;
      return "function" != typeof f || bj(f) || void 0 !== f.defaultProps || null !== c.compare || void 0 !== c.defaultProps ? ((a2 = yh(c.type, null, d, b, b.mode, e)).ref = b.ref, a2.return = b, b.child = a2) : (b.tag = 15, b.type = f, cj(a2, b, f, d, e));
    }
    if (f = a2.child, !(a2.lanes & e)) {
      var g = f.memoizedProps;
      if ((c = null !== (c = c.compare) ? c : Ie)(g, d) && a2.ref === b.ref)
        return $i(a2, b, e);
    }
    return b.flags |= 1, (a2 = wh(f, d)).ref = b.ref, a2.return = b, b.child = a2;
  }
  function cj(a2, b, c, d, e) {
    if (null !== a2) {
      var f = a2.memoizedProps;
      if (Ie(f, d) && a2.ref === b.ref) {
        if (Ug = false, b.pendingProps = d = f, !(a2.lanes & e))
          return b.lanes = a2.lanes, $i(a2, b, e);
        131072 & a2.flags && (Ug = true);
      }
    }
    return dj(a2, b, c, d, e);
  }
  function ej(a2, b, c) {
    var d = b.pendingProps, e = d.children, f = null !== a2 ? a2.memoizedState : null;
    if ("hidden" === d.mode)
      if (1 & b.mode) {
        if (!(1073741824 & c))
          return a2 = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b.updateQueue = null, G(fj, gj), gj |= a2, null;
        b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, d = null !== f ? f.baseLanes : c, G(fj, gj), gj |= d;
      } else
        b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c;
    else
      null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(fj, gj), gj |= d;
    return Yi(a2, b, e, c), b.child;
  }
  function hj(a2, b) {
    var c = b.ref;
    (null === a2 && null !== c || null !== a2 && a2.ref !== c) && (b.flags |= 512, b.flags |= 2097152);
  }
  function dj(a2, b, c, d, e) {
    var f = Zf(c) ? Xf : H.current;
    return f = Yf(b, f), Tg(b, e), c = Xh(a2, b, c, d, f, e), d = bi(), null === a2 || Ug ? (I && d && vg(b), b.flags |= 1, Yi(a2, b, c, e), b.child) : (b.updateQueue = a2.updateQueue, b.flags &= -2053, a2.lanes &= ~e, $i(a2, b, e));
  }
  function ij(a2, b, c, d, e) {
    if (Zf(c)) {
      var f = true;
      cg(b);
    } else
      f = false;
    if (Tg(b, e), null === b.stateNode)
      jj(a2, b), ph(b, c, d), rh(b, c, d, e), d = true;
    else if (null === a2) {
      var g = b.stateNode, h = b.memoizedProps;
      g.props = h;
      var k = g.context, l = c.contextType;
      l = "object" == typeof l && null !== l ? Vg(l) : Yf(b, l = Zf(c) ? Xf : H.current);
      var m = c.getDerivedStateFromProps, q = "function" == typeof m || "function" == typeof g.getSnapshotBeforeUpdate;
      q || "function" != typeof g.UNSAFE_componentWillReceiveProps && "function" != typeof g.componentWillReceiveProps || (h !== d || k !== l) && qh(b, g, d, l), $g = false;
      var r = b.memoizedState;
      g.state = r, gh(b, d, g, e), k = b.memoizedState, h !== d || r !== k || Wf.current || $g ? ("function" == typeof m && (kh(b, c, m, d), k = b.memoizedState), (h = $g || oh(b, c, h, d, r, k, l)) ? (q || "function" != typeof g.UNSAFE_componentWillMount && "function" != typeof g.componentWillMount || ("function" == typeof g.componentWillMount && g.componentWillMount(), "function" == typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" == typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" == typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" == typeof g.componentDidMount && (b.flags |= 4194308), d = false);
    } else {
      g = b.stateNode, bh(a2, b), h = b.memoizedProps, l = b.type === b.elementType ? h : Lg(b.type, h), g.props = l, q = b.pendingProps, r = g.context, k = "object" == typeof (k = c.contextType) && null !== k ? Vg(k) : Yf(b, k = Zf(c) ? Xf : H.current);
      var y = c.getDerivedStateFromProps;
      (m = "function" == typeof y || "function" == typeof g.getSnapshotBeforeUpdate) || "function" != typeof g.UNSAFE_componentWillReceiveProps && "function" != typeof g.componentWillReceiveProps || (h !== q || r !== k) && qh(b, g, d, k), $g = false, r = b.memoizedState, g.state = r, gh(b, d, g, e);
      var n = b.memoizedState;
      h !== q || r !== n || Wf.current || $g ? ("function" == typeof y && (kh(b, c, y, d), n = b.memoizedState), (l = $g || oh(b, c, l, d, r, n, k) || false) ? (m || "function" != typeof g.UNSAFE_componentWillUpdate && "function" != typeof g.componentWillUpdate || ("function" == typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" == typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" == typeof g.componentDidUpdate && (b.flags |= 4), "function" == typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" != typeof g.componentDidUpdate || h === a2.memoizedProps && r === a2.memoizedState || (b.flags |= 4), "function" != typeof g.getSnapshotBeforeUpdate || h === a2.memoizedProps && r === a2.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" != typeof g.componentDidUpdate || h === a2.memoizedProps && r === a2.memoizedState || (b.flags |= 4), "function" != typeof g.getSnapshotBeforeUpdate || h === a2.memoizedProps && r === a2.memoizedState || (b.flags |= 1024), d = false);
    }
    return kj(a2, b, c, d, f, e);
  }
  function kj(a2, b, c, d, e, f) {
    hj(a2, b);
    var g = !!(128 & b.flags);
    if (!d && !g)
      return e && dg(b, c, false), $i(a2, b, f);
    d = b.stateNode, Xi.current = b;
    var h = g && "function" != typeof c.getDerivedStateFromError ? null : d.render();
    return b.flags |= 1, null !== a2 && g ? (b.child = Bh(b, a2.child, null, f), b.child = Bh(b, null, h, f)) : Yi(a2, b, h, f), b.memoizedState = d.state, e && dg(b, c, true), b.child;
  }
  function lj(a2) {
    var b = a2.stateNode;
    b.pendingContext ? ag(0, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(0, b.context, false), Ih(a2, b.containerInfo);
  }
  function mj(a2, b, c, d, e) {
    return Ig(), Jg(e), b.flags |= 256, Yi(a2, b, c, d), b.child;
  }
  var Aj, Bj, Cj, Dj, nj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function oj(a2) {
    return { baseLanes: a2, cachePool: null, transitions: null };
  }
  function pj(a2, b, c) {
    var h, d = b.pendingProps, e = M.current, f = false, g = !!(128 & b.flags);
    if ((h = g) || (h = (null === a2 || null !== a2.memoizedState) && !!(2 & e)), h ? (f = true, b.flags &= -129) : null !== a2 && null === a2.memoizedState || (e |= 1), G(M, 1 & e), null === a2)
      return Eg(b), null !== (a2 = b.memoizedState) && null !== (a2 = a2.dehydrated) ? (1 & b.mode ? "$!" === a2.data ? b.lanes = 8 : b.lanes = 1073741824 : b.lanes = 1, null) : (g = d.children, a2 = d.fallback, f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 1 & d || null === f ? f = qj(g, d, 0, null) : (f.childLanes = 0, f.pendingProps = g), a2 = Ah(a2, d, c, null), f.return = b, a2.return = b, f.sibling = a2, b.child = f, b.child.memoizedState = oj(c), b.memoizedState = nj, a2) : rj(b, g));
    if (null !== (e = a2.memoizedState) && null !== (h = e.dehydrated))
      return function(a3, b2, c2, d2, e2, f2, g2) {
        if (c2)
          return 256 & b2.flags ? (b2.flags &= -257, tj(a3, b2, g2, d2 = Li(Error(p(422))))) : null !== b2.memoizedState ? (b2.child = a3.child, b2.flags |= 128, null) : (f2 = d2.fallback, e2 = b2.mode, d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null), (f2 = Ah(f2, e2, g2, null)).flags |= 2, d2.return = b2, f2.return = b2, d2.sibling = f2, b2.child = d2, 1 & b2.mode && Bh(b2, a3.child, null, g2), b2.child.memoizedState = oj(g2), b2.memoizedState = nj, f2);
        if (!(1 & b2.mode))
          return tj(a3, b2, g2, null);
        if ("$!" === e2.data) {
          if (d2 = e2.nextSibling && e2.nextSibling.dataset)
            var h2 = d2.dgst;
          return d2 = h2, tj(a3, b2, g2, d2 = Li(f2 = Error(p(419)), d2, void 0));
        }
        if (h2 = !!(g2 & a3.childLanes), Ug || h2) {
          if (null !== (d2 = R)) {
            switch (g2 & -g2) {
              case 4:
                e2 = 2;
                break;
              case 16:
                e2 = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                e2 = 32;
                break;
              case 536870912:
                e2 = 268435456;
                break;
              default:
                e2 = 0;
            }
            0 !== (e2 = e2 & (d2.suspendedLanes | g2) ? 0 : e2) && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a3, e2), mh(d2, a3, e2, -1));
          }
          return uj(), tj(a3, b2, g2, d2 = Li(Error(p(421))));
        }
        return "$?" === e2.data ? (b2.flags |= 128, b2.child = a3.child, b2 = vj.bind(null, a3), e2._reactRetry = b2, null) : (a3 = f2.treeContext, yg = Lf(e2.nextSibling), xg = b2, I = true, zg = null, null !== a3 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a3.id, sg = a3.overflow, qg = b2), (b2 = rj(b2, d2.children)).flags |= 4096, b2);
      }(a2, b, g, d, h, e, c);
    if (f) {
      f = d.fallback, g = b.mode, h = (e = a2.child).sibling;
      var k = { mode: "hidden", children: d.children };
      return 1 & g || b.child === e ? (d = wh(e, k)).subtreeFlags = 14680064 & e.subtreeFlags : ((d = b.child).childLanes = 0, d.pendingProps = k, b.deletions = null), null !== h ? f = wh(h, f) : (f = Ah(f, g, c, null)).flags |= 2, f.return = b, d.return = b, d.sibling = f, b.child = d, d = f, f = b.child, g = null === (g = a2.child.memoizedState) ? oj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions }, f.memoizedState = g, f.childLanes = a2.childLanes & ~c, b.memoizedState = nj, d;
    }
    return a2 = (f = a2.child).sibling, d = wh(f, { mode: "visible", children: d.children }), !(1 & b.mode) && (d.lanes = c), d.return = b, d.sibling = null, null !== a2 && (null === (c = b.deletions) ? (b.deletions = [a2], b.flags |= 16) : c.push(a2)), b.child = d, b.memoizedState = null, d;
  }
  function rj(a2, b) {
    return (b = qj({ mode: "visible", children: b }, a2.mode, 0, null)).return = a2, a2.child = b;
  }
  function tj(a2, b, c, d) {
    return null !== d && Jg(d), Bh(b, a2.child, null, c), (a2 = rj(b, b.pendingProps.children)).flags |= 2, b.memoizedState = null, a2;
  }
  function wj(a2, b, c) {
    a2.lanes |= b;
    var d = a2.alternate;
    null !== d && (d.lanes |= b), Sg(a2.return, b, c);
  }
  function xj(a2, b, c, d, e) {
    var f = a2.memoizedState;
    null === f ? a2.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
  }
  function yj(a2, b, c) {
    var d = b.pendingProps, e = d.revealOrder, f = d.tail;
    if (Yi(a2, b, d.children, c), 2 & (d = M.current))
      d = 1 & d | 2, b.flags |= 128;
    else {
      if (null !== a2 && 128 & a2.flags)
        a:
          for (a2 = b.child; null !== a2; ) {
            if (13 === a2.tag)
              null !== a2.memoizedState && wj(a2, c, b);
            else if (19 === a2.tag)
              wj(a2, c, b);
            else if (null !== a2.child) {
              a2.child.return = a2, a2 = a2.child;
              continue;
            }
            if (a2 === b)
              break a;
            for (; null === a2.sibling; ) {
              if (null === a2.return || a2.return === b)
                break a;
              a2 = a2.return;
            }
            a2.sibling.return = a2.return, a2 = a2.sibling;
          }
      d &= 1;
    }
    if (G(M, d), 1 & b.mode)
      switch (e) {
        case "forwards":
          for (c = b.child, e = null; null !== c; )
            null !== (a2 = c.alternate) && null === Mh(a2) && (e = c), c = c.sibling;
          null === (c = e) ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null), xj(b, false, e, c, f);
          break;
        case "backwards":
          for (c = null, e = b.child, b.child = null; null !== e; ) {
            if (null !== (a2 = e.alternate) && null === Mh(a2)) {
              b.child = e;
              break;
            }
            a2 = e.sibling, e.sibling = c, c = e, e = a2;
          }
          xj(b, true, c, null, f);
          break;
        case "together":
          xj(b, false, null, null, void 0);
          break;
        default:
          b.memoizedState = null;
      }
    else
      b.memoizedState = null;
    return b.child;
  }
  function jj(a2, b) {
    !(1 & b.mode) && null !== a2 && (a2.alternate = null, b.alternate = null, b.flags |= 2);
  }
  function $i(a2, b, c) {
    if (null !== a2 && (b.dependencies = a2.dependencies), hh |= b.lanes, !(c & b.childLanes))
      return null;
    if (null !== a2 && b.child !== a2.child)
      throw Error(p(153));
    if (null !== b.child) {
      for (c = wh(a2 = b.child, a2.pendingProps), b.child = c, c.return = b; null !== a2.sibling; )
        a2 = a2.sibling, (c = c.sibling = wh(a2, a2.pendingProps)).return = b;
      c.sibling = null;
    }
    return b.child;
  }
  function Ej(a2, b) {
    if (!I)
      switch (a2.tailMode) {
        case "hidden":
          b = a2.tail;
          for (var c = null; null !== b; )
            null !== b.alternate && (c = b), b = b.sibling;
          null === c ? a2.tail = null : c.sibling = null;
          break;
        case "collapsed":
          c = a2.tail;
          for (var d = null; null !== c; )
            null !== c.alternate && (d = c), c = c.sibling;
          null === d ? b || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d.sibling = null;
      }
  }
  function S(a2) {
    var b = null !== a2.alternate && a2.alternate.child === a2.child, c = 0, d = 0;
    if (b)
      for (var e = a2.child; null !== e; )
        c |= e.lanes | e.childLanes, d |= 14680064 & e.subtreeFlags, d |= 14680064 & e.flags, e.return = a2, e = e.sibling;
    else
      for (e = a2.child; null !== e; )
        c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a2, e = e.sibling;
    return a2.subtreeFlags |= d, a2.childLanes = c, b;
  }
  function Fj(a2, b, c) {
    var d = b.pendingProps;
    switch (wg(b), b.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S(b), null;
      case 1:
      case 17:
        return Zf(b.type) && $f(), S(b), null;
      case 3:
        return d = b.stateNode, Jh(), E(Wf), E(H), Oh(), d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null), null !== a2 && null !== a2.child || (Gg(b) ? b.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && !(256 & b.flags) || (b.flags |= 1024, null !== zg && (Gj(zg), zg = null))), Bj(a2, b), S(b), null;
      case 5:
        Lh(b);
        var e = Hh(Gh.current);
        if (c = b.type, null !== a2 && null != b.stateNode)
          Cj(a2, b, c, d, e), a2.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        else {
          if (!d) {
            if (null === b.stateNode)
              throw Error(p(166));
            return S(b), null;
          }
          if (a2 = Hh(Eh.current), Gg(b)) {
            d = b.stateNode, c = b.type;
            var f = b.memoizedProps;
            switch (d[Of] = b, d[Pf] = f, a2 = !!(1 & b.mode), c) {
              case "dialog":
                D("cancel", d), D("close", d);
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", d);
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++)
                  D(lf[e], d);
                break;
              case "source":
                D("error", d);
                break;
              case "img":
              case "image":
              case "link":
                D("error", d), D("load", d);
                break;
              case "details":
                D("toggle", d);
                break;
              case "input":
                Za(d, f), D("invalid", d);
                break;
              case "select":
                d._wrapperState = { wasMultiple: !!f.multiple }, D("invalid", d);
                break;
              case "textarea":
                hb(d, f), D("invalid", d);
            }
            for (var g in ub(c, f), e = null, f)
              if (f.hasOwnProperty(g)) {
                var h = f[g];
                "children" === g ? "string" == typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a2), e = ["children", h]) : "number" == typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a2), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
              }
            switch (c) {
              case "input":
                Va(d), db(d, f, true);
                break;
              case "textarea":
                Va(d), jb(d);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" == typeof f.onClick && (d.onclick = Bf);
            }
            d = e, b.updateQueue = d, null !== d && (b.flags |= 4);
          } else {
            g = 9 === e.nodeType ? e : e.ownerDocument, "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c)), "http://www.w3.org/1999/xhtml" === a2 ? "script" === c ? ((a2 = g.createElement("div")).innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" == typeof d.is ? a2 = g.createElement(c, { is: d.is }) : (a2 = g.createElement(c), "select" === c && (g = a2, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a2 = g.createElementNS(a2, c), a2[Of] = b, a2[Pf] = d, Aj(a2, b, false, false), b.stateNode = a2;
            a: {
              switch (g = vb(c, d), c) {
                case "dialog":
                  D("cancel", a2), D("close", a2), e = d;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", a2), e = d;
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++)
                    D(lf[e], a2);
                  e = d;
                  break;
                case "source":
                  D("error", a2), e = d;
                  break;
                case "img":
                case "image":
                case "link":
                  D("error", a2), D("load", a2), e = d;
                  break;
                case "details":
                  D("toggle", a2), e = d;
                  break;
                case "input":
                  Za(a2, d), e = Ya(a2, d), D("invalid", a2);
                  break;
                case "option":
                default:
                  e = d;
                  break;
                case "select":
                  a2._wrapperState = { wasMultiple: !!d.multiple }, e = A({}, d, { value: void 0 }), D("invalid", a2);
                  break;
                case "textarea":
                  hb(a2, d), e = gb(a2, d), D("invalid", a2);
              }
              for (f in ub(c, e), h = e)
                if (h.hasOwnProperty(f)) {
                  var k = h[f];
                  "style" === f ? sb(a2, k) : "dangerouslySetInnerHTML" === f ? null != (k = k ? k.__html : void 0) && nb(a2, k) : "children" === f ? "string" == typeof k ? ("textarea" !== c || "" !== k) && ob(a2, k) : "number" == typeof k && ob(a2, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a2) : null != k && ta(a2, f, k, g));
                }
              switch (c) {
                case "input":
                  Va(a2), db(a2, d, false);
                  break;
                case "textarea":
                  Va(a2), jb(a2);
                  break;
                case "option":
                  null != d.value && a2.setAttribute("value", "" + Sa(d.value));
                  break;
                case "select":
                  a2.multiple = !!d.multiple, null != (f = d.value) ? fb(a2, !!d.multiple, f, false) : null != d.defaultValue && fb(a2, !!d.multiple, d.defaultValue, true);
                  break;
                default:
                  "function" == typeof e.onClick && (a2.onclick = Bf);
              }
              switch (c) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d = !!d.autoFocus;
                  break a;
                case "img":
                  d = true;
                  break a;
                default:
                  d = false;
              }
            }
            d && (b.flags |= 4);
          }
          null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        }
        return S(b), null;
      case 6:
        if (a2 && null != b.stateNode)
          Dj(a2, b, a2.memoizedProps, d);
        else {
          if ("string" != typeof d && null === b.stateNode)
            throw Error(p(166));
          if (c = Hh(Gh.current), Hh(Eh.current), Gg(b)) {
            if (d = b.stateNode, c = b.memoizedProps, d[Of] = b, (f = d.nodeValue !== c) && null !== (a2 = xg))
              switch (a2.tag) {
                case 3:
                  Af(d.nodeValue, c, !!(1 & a2.mode));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, !!(1 & a2.mode));
              }
            f && (b.flags |= 4);
          } else
            (d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d))[Of] = b, b.stateNode = d;
        }
        return S(b), null;
      case 13:
        if (E(M), d = b.memoizedState, null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
          if (I && null !== yg && 1 & b.mode && !(128 & b.flags))
            Hg(), Ig(), b.flags |= 98560, f = false;
          else if (f = Gg(b), null !== d && null !== d.dehydrated) {
            if (null === a2) {
              if (!f)
                throw Error(p(318));
              if (!(f = null !== (f = b.memoizedState) ? f.dehydrated : null))
                throw Error(p(317));
              f[Of] = b;
            } else
              Ig(), !(128 & b.flags) && (b.memoizedState = null), b.flags |= 4;
            S(b), f = false;
          } else
            null !== zg && (Gj(zg), zg = null), f = true;
          if (!f)
            return 65536 & b.flags ? b : null;
        }
        return 128 & b.flags ? (b.lanes = c, b) : ((d = null !== d) != (null !== a2 && null !== a2.memoizedState) && d && (b.child.flags |= 8192, 1 & b.mode && (null === a2 || 1 & M.current ? 0 === T && (T = 3) : uj())), null !== b.updateQueue && (b.flags |= 4), S(b), null);
      case 4:
        return Jh(), Bj(a2, b), null === a2 && sf(b.stateNode.containerInfo), S(b), null;
      case 10:
        return Rg(b.type._context), S(b), null;
      case 19:
        if (E(M), null === (f = b.memoizedState))
          return S(b), null;
        if (d = !!(128 & b.flags), null === (g = f.rendering))
          if (d)
            Ej(f, false);
          else {
            if (0 !== T || null !== a2 && 128 & a2.flags)
              for (a2 = b.child; null !== a2; ) {
                if (null !== (g = Mh(a2))) {
                  for (b.flags |= 128, Ej(f, false), null !== (d = g.updateQueue) && (b.updateQueue = d, b.flags |= 4), b.subtreeFlags = 0, d = c, c = b.child; null !== c; )
                    a2 = d, (f = c).flags &= 14680066, null === (g = f.alternate) ? (f.childLanes = 0, f.lanes = a2, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a2 = g.dependencies, f.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c = c.sibling;
                  return G(M, 1 & M.current | 2), b.child;
                }
                a2 = a2.sibling;
              }
            null !== f.tail && B() > Hj && (b.flags |= 128, d = true, Ej(f, false), b.lanes = 4194304);
          }
        else {
          if (!d)
            if (null !== (a2 = Mh(g))) {
              if (b.flags |= 128, d = true, null !== (c = a2.updateQueue) && (b.updateQueue = c, b.flags |= 4), Ej(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I)
                return S(b), null;
            } else
              2 * B() - f.renderingStartTime > Hj && 1073741824 !== c && (b.flags |= 128, d = true, Ej(f, false), b.lanes = 4194304);
          f.isBackwards ? (g.sibling = b.child, b.child = g) : (null !== (c = f.last) ? c.sibling = g : b.child = g, f.last = g);
        }
        return null !== f.tail ? (b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = M.current, G(M, d ? 1 & c | 2 : 1 & c), b) : (S(b), null);
      case 22:
      case 23:
        return Ij(), d = null !== b.memoizedState, null !== a2 && null !== a2.memoizedState !== d && (b.flags |= 8192), d && 1 & b.mode ? !!(1073741824 & gj) && (S(b), 6 & b.subtreeFlags && (b.flags |= 8192)) : S(b), null;
      case 24:
      case 25:
        return null;
    }
    throw Error(p(156, b.tag));
  }
  function Jj(a2, b) {
    switch (wg(b), b.tag) {
      case 1:
        return Zf(b.type) && $f(), 65536 & (a2 = b.flags) ? (b.flags = -65537 & a2 | 128, b) : null;
      case 3:
        return Jh(), E(Wf), E(H), Oh(), 65536 & (a2 = b.flags) && !(128 & a2) ? (b.flags = -65537 & a2 | 128, b) : null;
      case 5:
        return Lh(b), null;
      case 13:
        if (E(M), null !== (a2 = b.memoizedState) && null !== a2.dehydrated) {
          if (null === b.alternate)
            throw Error(p(340));
          Ig();
        }
        return 65536 & (a2 = b.flags) ? (b.flags = -65537 & a2 | 128, b) : null;
      case 19:
        return E(M), null;
      case 4:
        return Jh(), null;
      case 10:
        return Rg(b.type._context), null;
      case 22:
      case 23:
        return Ij(), null;
      default:
        return null;
    }
  }
  Aj = function(a2, b) {
    for (var c = b.child; null !== c; ) {
      if (5 === c.tag || 6 === c.tag)
        a2.appendChild(c.stateNode);
      else if (4 !== c.tag && null !== c.child) {
        c.child.return = c, c = c.child;
        continue;
      }
      if (c === b)
        break;
      for (; null === c.sibling; ) {
        if (null === c.return || c.return === b)
          return;
        c = c.return;
      }
      c.sibling.return = c.return, c = c.sibling;
    }
  }, Bj = function() {
  }, Cj = function(a2, b, c, d) {
    var e = a2.memoizedProps;
    if (e !== d) {
      a2 = b.stateNode, Hh(Eh.current);
      var g, f = null;
      switch (c) {
        case "input":
          e = Ya(a2, e), d = Ya(a2, d), f = [];
          break;
        case "select":
          e = A({}, e, { value: void 0 }), d = A({}, d, { value: void 0 }), f = [];
          break;
        case "textarea":
          e = gb(a2, e), d = gb(a2, d), f = [];
          break;
        default:
          "function" != typeof e.onClick && "function" == typeof d.onClick && (a2.onclick = Bf);
      }
      for (l in ub(c, d), c = null, e)
        if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l])
          if ("style" === l) {
            var h = e[l];
            for (g in h)
              h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
          } else
            "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
      for (l in d) {
        var k = d[l];
        if (h = null != e ? e[l] : void 0, d.hasOwnProperty(l) && k !== h && (null != k || null != h))
          if ("style" === l)
            if (h) {
              for (g in h)
                !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
              for (g in k)
                k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
            } else
              c || (f || (f = []), f.push(l, c)), c = k;
          else
            "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" != typeof k && "number" != typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a2), f || h === k || (f = [])) : (f = f || []).push(l, k));
      }
      c && (f = f || []).push("style", c);
      var l = f;
      (b.updateQueue = l) && (b.flags |= 4);
    }
  }, Dj = function(a2, b, c, d) {
    c !== d && (b.flags |= 4);
  };
  var Kj = false, U = false, Lj = "function" == typeof WeakSet ? WeakSet : Set, V = null;
  function Mj(a2, b) {
    var c = a2.ref;
    if (null !== c)
      if ("function" == typeof c)
        try {
          c(null);
        } catch (d) {
          W(a2, b, d);
        }
      else
        c.current = null;
  }
  function Nj(a2, b, c) {
    try {
      c();
    } catch (d) {
      W(a2, b, d);
    }
  }
  var Oj = false;
  function Qj(a2, b, c) {
    var d = b.updateQueue;
    if (null !== (d = null !== d ? d.lastEffect : null)) {
      var e = d = d.next;
      do {
        if ((e.tag & a2) === a2) {
          var f = e.destroy;
          e.destroy = void 0, void 0 !== f && Nj(b, c, f);
        }
        e = e.next;
      } while (e !== d);
    }
  }
  function Rj(a2, b) {
    if (null !== (b = null !== (b = b.updateQueue) ? b.lastEffect : null)) {
      var c = b = b.next;
      do {
        if ((c.tag & a2) === a2) {
          var d = c.create;
          c.destroy = d();
        }
        c = c.next;
      } while (c !== b);
    }
  }
  function Sj(a2) {
    var b = a2.ref;
    if (null !== b) {
      var c = a2.stateNode;
      a2.tag, a2 = c, "function" == typeof b ? b(a2) : b.current = a2;
    }
  }
  function Tj(a2) {
    var b = a2.alternate;
    null !== b && (a2.alternate = null, Tj(b)), a2.child = null, a2.deletions = null, a2.sibling = null, 5 === a2.tag && null !== (b = a2.stateNode) && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]), a2.stateNode = null, a2.return = null, a2.dependencies = null, a2.memoizedProps = null, a2.memoizedState = null, a2.pendingProps = null, a2.stateNode = null, a2.updateQueue = null;
  }
  function Uj(a2) {
    return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
  }
  function Vj(a2) {
    a:
      for (; ; ) {
        for (; null === a2.sibling; ) {
          if (null === a2.return || Uj(a2.return))
            return null;
          a2 = a2.return;
        }
        for (a2.sibling.return = a2.return, a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
          if (2 & a2.flags)
            continue a;
          if (null === a2.child || 4 === a2.tag)
            continue a;
          a2.child.return = a2, a2 = a2.child;
        }
        if (!(2 & a2.flags))
          return a2.stateNode;
      }
  }
  function Wj(a2, b, c) {
    var d = a2.tag;
    if (5 === d || 6 === d)
      a2 = a2.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a2, b) : c.insertBefore(a2, b) : (8 === c.nodeType ? (b = c.parentNode).insertBefore(a2, c) : (b = c).appendChild(a2), null != (c = c._reactRootContainer) || null !== b.onclick || (b.onclick = Bf));
    else if (4 !== d && null !== (a2 = a2.child))
      for (Wj(a2, b, c), a2 = a2.sibling; null !== a2; )
        Wj(a2, b, c), a2 = a2.sibling;
  }
  function Xj(a2, b, c) {
    var d = a2.tag;
    if (5 === d || 6 === d)
      a2 = a2.stateNode, b ? c.insertBefore(a2, b) : c.appendChild(a2);
    else if (4 !== d && null !== (a2 = a2.child))
      for (Xj(a2, b, c), a2 = a2.sibling; null !== a2; )
        Xj(a2, b, c), a2 = a2.sibling;
  }
  var X = null, Yj = false;
  function Zj(a2, b, c) {
    for (c = c.child; null !== c; )
      ak(a2, b, c), c = c.sibling;
  }
  function ak(a2, b, c) {
    if (lc && "function" == typeof lc.onCommitFiberUnmount)
      try {
        lc.onCommitFiberUnmount(kc, c);
      } catch (h) {
      }
    switch (c.tag) {
      case 5:
        U || Mj(c, b);
      case 6:
        var d = X, e = Yj;
        X = null, Zj(a2, b, c), Yj = e, null !== (X = d) && (Yj ? (a2 = X, c = c.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c) : a2.removeChild(c)) : X.removeChild(c.stateNode));
        break;
      case 18:
        null !== X && (Yj ? (a2 = X, c = c.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c) : 1 === a2.nodeType && Kf(a2, c), bd(a2)) : Kf(X, c.stateNode));
        break;
      case 4:
        d = X, e = Yj, X = c.stateNode.containerInfo, Yj = true, Zj(a2, b, c), X = d, Yj = e;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U && null !== (d = c.updateQueue) && null !== (d = d.lastEffect)) {
          e = d = d.next;
          do {
            var f = e, g = f.destroy;
            f = f.tag, void 0 !== g && (2 & f || 4 & f) && Nj(c, b, g), e = e.next;
          } while (e !== d);
        }
        Zj(a2, b, c);
        break;
      case 1:
        if (!U && (Mj(c, b), "function" == typeof (d = c.stateNode).componentWillUnmount))
          try {
            d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
          } catch (h) {
            W(c, b, h);
          }
        Zj(a2, b, c);
        break;
      case 21:
        Zj(a2, b, c);
        break;
      case 22:
        1 & c.mode ? (U = (d = U) || null !== c.memoizedState, Zj(a2, b, c), U = d) : Zj(a2, b, c);
        break;
      default:
        Zj(a2, b, c);
    }
  }
  function bk(a2) {
    var b = a2.updateQueue;
    if (null !== b) {
      a2.updateQueue = null;
      var c = a2.stateNode;
      null === c && (c = a2.stateNode = new Lj()), b.forEach(function(b2) {
        var d = ck.bind(null, a2, b2);
        c.has(b2) || (c.add(b2), b2.then(d, d));
      });
    }
  }
  function dk(a2, b) {
    var c = b.deletions;
    if (null !== c)
      for (var d = 0; d < c.length; d++) {
        var e = c[d];
        try {
          var f = a2, g = b, h = g;
          a:
            for (; null !== h; ) {
              switch (h.tag) {
                case 5:
                  X = h.stateNode, Yj = false;
                  break a;
                case 3:
                case 4:
                  X = h.stateNode.containerInfo, Yj = true;
                  break a;
              }
              h = h.return;
            }
          if (null === X)
            throw Error(p(160));
          ak(f, g, e), X = null, Yj = false;
          var k = e.alternate;
          null !== k && (k.return = null), e.return = null;
        } catch (l) {
          W(e, b, l);
        }
      }
    if (12854 & b.subtreeFlags)
      for (b = b.child; null !== b; )
        ek(b, a2), b = b.sibling;
  }
  function ek(a2, b) {
    var c = a2.alternate, d = a2.flags;
    switch (a2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (dk(b, a2), fk(a2), 4 & d) {
          try {
            Qj(3, a2, a2.return), Rj(3, a2);
          } catch (t) {
            W(a2, a2.return, t);
          }
          try {
            Qj(5, a2, a2.return);
          } catch (t) {
            W(a2, a2.return, t);
          }
        }
        break;
      case 1:
        dk(b, a2), fk(a2), 512 & d && null !== c && Mj(c, c.return);
        break;
      case 5:
        if (dk(b, a2), fk(a2), 512 & d && null !== c && Mj(c, c.return), 32 & a2.flags) {
          var e = a2.stateNode;
          try {
            ob(e, "");
          } catch (t) {
            W(a2, a2.return, t);
          }
        }
        if (4 & d && null != (e = a2.stateNode)) {
          var f = a2.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a2.type, k = a2.updateQueue;
          if (a2.updateQueue = null, null !== k)
            try {
              "input" === h && "radio" === f.type && null != f.name && ab(e, f), vb(h, g);
              var l = vb(h, f);
              for (g = 0; g < k.length; g += 2) {
                var m = k[g], q = k[g + 1];
                "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
              }
              switch (h) {
                case "input":
                  bb(e, f);
                  break;
                case "textarea":
                  ib(e, f);
                  break;
                case "select":
                  var r = e._wrapperState.wasMultiple;
                  e._wrapperState.wasMultiple = !!f.multiple;
                  var y = f.value;
                  null != y ? fb(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb(e, !!f.multiple, f.defaultValue, true) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
              }
              e[Pf] = f;
            } catch (t) {
              W(a2, a2.return, t);
            }
        }
        break;
      case 6:
        if (dk(b, a2), fk(a2), 4 & d) {
          if (null === a2.stateNode)
            throw Error(p(162));
          e = a2.stateNode, f = a2.memoizedProps;
          try {
            e.nodeValue = f;
          } catch (t) {
            W(a2, a2.return, t);
          }
        }
        break;
      case 3:
        if (dk(b, a2), fk(a2), 4 & d && null !== c && c.memoizedState.isDehydrated)
          try {
            bd(b.containerInfo);
          } catch (t) {
            W(a2, a2.return, t);
          }
        break;
      case 4:
      default:
        dk(b, a2), fk(a2);
        break;
      case 13:
        dk(b, a2), fk(a2), 8192 & (e = a2.child).flags && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (gk = B())), 4 & d && bk(a2);
        break;
      case 22:
        if (m = null !== c && null !== c.memoizedState, 1 & a2.mode ? (U = (l = U) || m, dk(b, a2), U = l) : dk(b, a2), fk(a2), 8192 & d) {
          if (l = null !== a2.memoizedState, (a2.stateNode.isHidden = l) && !m && 1 & a2.mode)
            for (V = a2, m = a2.child; null !== m; ) {
              for (q = V = m; null !== V; ) {
                switch (y = (r = V).child, r.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Qj(4, r, r.return);
                    break;
                  case 1:
                    Mj(r, r.return);
                    var n = r.stateNode;
                    if ("function" == typeof n.componentWillUnmount) {
                      d = r, c = r.return;
                      try {
                        b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                      } catch (t) {
                        W(d, c, t);
                      }
                    }
                    break;
                  case 5:
                    Mj(r, r.return);
                    break;
                  case 22:
                    if (null !== r.memoizedState) {
                      hk(q);
                      continue;
                    }
                }
                null !== y ? (y.return = r, V = y) : hk(q);
              }
              m = m.sibling;
            }
          a:
            for (m = null, q = a2; ; ) {
              if (5 === q.tag) {
                if (null === m) {
                  m = q;
                  try {
                    e = q.stateNode, l ? "function" == typeof (f = e.style).setProperty ? f.setProperty("display", "none", "important") : f.display = "none" : (h = q.stateNode, g = null != (k = q.memoizedProps.style) && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                  } catch (t) {
                    W(a2, a2.return, t);
                  }
                }
              } else if (6 === q.tag) {
                if (null === m)
                  try {
                    q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                  } catch (t) {
                    W(a2, a2.return, t);
                  }
              } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a2) && null !== q.child) {
                q.child.return = q, q = q.child;
                continue;
              }
              if (q === a2)
                break a;
              for (; null === q.sibling; ) {
                if (null === q.return || q.return === a2)
                  break a;
                m === q && (m = null), q = q.return;
              }
              m === q && (m = null), q.sibling.return = q.return, q = q.sibling;
            }
        }
        break;
      case 19:
        dk(b, a2), fk(a2), 4 & d && bk(a2);
      case 21:
    }
  }
  function fk(a2) {
    var b = a2.flags;
    if (2 & b) {
      try {
        a: {
          for (var c = a2.return; null !== c; ) {
            if (Uj(c)) {
              var d = c;
              break a;
            }
            c = c.return;
          }
          throw Error(p(160));
        }
        switch (d.tag) {
          case 5:
            var e = d.stateNode;
            32 & d.flags && (ob(e, ""), d.flags &= -33), Xj(a2, Vj(a2), e);
            break;
          case 3:
          case 4:
            var g = d.stateNode.containerInfo;
            Wj(a2, Vj(a2), g);
            break;
          default:
            throw Error(p(161));
        }
      } catch (k) {
        W(a2, a2.return, k);
      }
      a2.flags &= -3;
    }
    4096 & b && (a2.flags &= -4097);
  }
  function ik(a2, b, c) {
    V = a2, jk(a2);
  }
  function jk(a2, b, c) {
    for (var d = !!(1 & a2.mode); null !== V; ) {
      var e = V, f = e.child;
      if (22 === e.tag && d) {
        var g = null !== e.memoizedState || Kj;
        if (!g) {
          var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
          h = Kj;
          var l = U;
          if (Kj = g, (U = k) && !l)
            for (V = e; null !== V; )
              k = (g = V).child, 22 === g.tag && null !== g.memoizedState ? kk(e) : null !== k ? (k.return = g, V = k) : kk(e);
          for (; null !== f; )
            V = f, jk(f), f = f.sibling;
          V = e, Kj = h, U = l;
        }
        lk(a2);
      } else
        8772 & e.subtreeFlags && null !== f ? (f.return = e, V = f) : lk(a2);
    }
  }
  function lk(a2) {
    for (; null !== V; ) {
      var b = V;
      if (8772 & b.flags) {
        var c = b.alternate;
        try {
          if (8772 & b.flags)
            switch (b.tag) {
              case 0:
              case 11:
              case 15:
                U || Rj(5, b);
                break;
              case 1:
                var d = b.stateNode;
                if (4 & b.flags && !U)
                  if (null === c)
                    d.componentDidMount();
                  else {
                    var e = b.elementType === b.type ? c.memoizedProps : Lg(b.type, c.memoizedProps);
                    d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                  }
                var f = b.updateQueue;
                null !== f && ih(b, f, d);
                break;
              case 3:
                var g = b.updateQueue;
                if (null !== g) {
                  if (c = null, null !== b.child)
                    switch (b.child.tag) {
                      case 5:
                      case 1:
                        c = b.child.stateNode;
                    }
                  ih(b, g, c);
                }
                break;
              case 5:
                var h = b.stateNode;
                if (null === c && 4 & b.flags) {
                  c = h;
                  var k = b.memoizedProps;
                  switch (b.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      k.autoFocus && c.focus();
                      break;
                    case "img":
                      k.src && (c.src = k.src);
                  }
                }
                break;
              case 6:
              case 4:
              case 12:
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              case 13:
                if (null === b.memoizedState) {
                  var l = b.alternate;
                  if (null !== l) {
                    var m = l.memoizedState;
                    if (null !== m) {
                      var q = m.dehydrated;
                      null !== q && bd(q);
                    }
                  }
                }
                break;
              default:
                throw Error(p(163));
            }
          U || 512 & b.flags && Sj(b);
        } catch (r) {
          W(b, b.return, r);
        }
      }
      if (b === a2) {
        V = null;
        break;
      }
      if (null !== (c = b.sibling)) {
        c.return = b.return, V = c;
        break;
      }
      V = b.return;
    }
  }
  function hk(a2) {
    for (; null !== V; ) {
      var b = V;
      if (b === a2) {
        V = null;
        break;
      }
      var c = b.sibling;
      if (null !== c) {
        c.return = b.return, V = c;
        break;
      }
      V = b.return;
    }
  }
  function kk(a2) {
    for (; null !== V; ) {
      var b = V;
      try {
        switch (b.tag) {
          case 0:
          case 11:
          case 15:
            var c = b.return;
            try {
              Rj(4, b);
            } catch (k) {
              W(b, c, k);
            }
            break;
          case 1:
            var d = b.stateNode;
            if ("function" == typeof d.componentDidMount) {
              var e = b.return;
              try {
                d.componentDidMount();
              } catch (k) {
                W(b, e, k);
              }
            }
            var f = b.return;
            try {
              Sj(b);
            } catch (k) {
              W(b, f, k);
            }
            break;
          case 5:
            var g = b.return;
            try {
              Sj(b);
            } catch (k) {
              W(b, g, k);
            }
        }
      } catch (k) {
        W(b, b.return, k);
      }
      if (b === a2) {
        V = null;
        break;
      }
      var h = b.sibling;
      if (null !== h) {
        h.return = b.return, V = h;
        break;
      }
      V = b.return;
    }
  }
  var Wk, mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = 1 / 0, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
  function L() {
    return 6 & K ? B() : -1 !== Bk ? Bk : Bk = B();
  }
  function lh(a2) {
    return 1 & a2.mode ? 2 & K && 0 !== Z ? Z & -Z : null !== Kg.transition ? (0 === Ck && (Ck = yc()), Ck) : 0 !== (a2 = C) ? a2 : a2 = void 0 === (a2 = window.event) ? 16 : jd(a2.type) : 1;
  }
  function mh(a2, b, c, d) {
    if (50 < zk)
      throw zk = 0, Ak = null, Error(p(185));
    Ac(a2, c, d), 2 & K && a2 === R || (a2 === R && (!(2 & K) && (rk |= c), 4 === T && Dk(a2, Z)), Ek(a2, d), 1 === c && 0 === K && !(1 & b.mode) && (Hj = B() + 500, fg && jg()));
  }
  function Ek(a2, b) {
    var c = a2.callbackNode;
    !function(a3, b2) {
      for (var c2 = a3.suspendedLanes, d2 = a3.pingedLanes, e = a3.expirationTimes, f = a3.pendingLanes; 0 < f; ) {
        var g = 31 - oc(f), h = 1 << g, k = e[g];
        -1 === k ? h & c2 && !(h & d2) || (e[g] = vc(h, b2)) : k <= b2 && (a3.expiredLanes |= h), f &= ~h;
      }
    }(a2, b);
    var d = uc(a2, a2 === R ? Z : 0);
    if (0 === d)
      null !== c && bc(c), a2.callbackNode = null, a2.callbackPriority = 0;
    else if (b = d & -d, a2.callbackPriority !== b) {
      if (null != c && bc(c), 1 === b)
        0 === a2.tag ? function(a3) {
          fg = true, hg(a3);
        }(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
          !(6 & K) && jg();
        }), c = null;
      else {
        switch (Dc(d)) {
          case 1:
            c = fc;
            break;
          case 4:
            c = gc;
            break;
          case 16:
          default:
            c = hc;
            break;
          case 536870912:
            c = jc;
        }
        c = Gk(c, Hk.bind(null, a2));
      }
      a2.callbackPriority = b, a2.callbackNode = c;
    }
  }
  function Hk(a2, b) {
    if (Bk = -1, Ck = 0, 6 & K)
      throw Error(p(327));
    var c = a2.callbackNode;
    if (Ik() && a2.callbackNode !== c)
      return null;
    var d = uc(a2, a2 === R ? Z : 0);
    if (0 === d)
      return null;
    if (30 & d || d & a2.expiredLanes || b)
      b = Jk(a2, d);
    else {
      b = d;
      var e = K;
      K |= 2;
      var f = Kk();
      for (R === a2 && Z === b || (vk = null, Hj = B() + 500, Lk(a2, b)); ; )
        try {
          Mk();
          break;
        } catch (h) {
          Nk(a2, h);
        }
      Qg(), nk.current = f, K = e, null !== Y ? b = 0 : (R = null, Z = 0, b = T);
    }
    if (0 !== b) {
      if (2 === b && 0 !== (e = xc(a2)) && (d = e, b = Ok(a2, e)), 1 === b)
        throw c = qk, Lk(a2, 0), Dk(a2, d), Ek(a2, B()), c;
      if (6 === b)
        Dk(a2, d);
      else {
        if (e = a2.current.alternate, !(30 & d || function(a3) {
          for (var b2 = a3; ; ) {
            if (16384 & b2.flags) {
              var c2 = b2.updateQueue;
              if (null !== c2 && null !== (c2 = c2.stores))
                for (var d2 = 0; d2 < c2.length; d2++) {
                  var e2 = c2[d2], f2 = e2.getSnapshot;
                  e2 = e2.value;
                  try {
                    if (!He(f2(), e2))
                      return false;
                  } catch (g2) {
                    return false;
                  }
                }
            }
            if (c2 = b2.child, 16384 & b2.subtreeFlags && null !== c2)
              c2.return = b2, b2 = c2;
            else {
              if (b2 === a3)
                break;
              for (; null === b2.sibling; ) {
                if (null === b2.return || b2.return === a3)
                  return true;
                b2 = b2.return;
              }
              b2.sibling.return = b2.return, b2 = b2.sibling;
            }
          }
          return true;
        }(e) || (b = Jk(a2, d), 2 === b && (f = xc(a2), 0 !== f && (d = f, b = Ok(a2, f))), 1 !== b)))
          throw c = qk, Lk(a2, 0), Dk(a2, d), Ek(a2, B()), c;
        switch (a2.finishedWork = e, a2.finishedLanes = d, b) {
          case 0:
          case 1:
            throw Error(p(345));
          case 2:
          case 5:
            Qk(a2, uk, vk);
            break;
          case 3:
            if (Dk(a2, d), (130023424 & d) === d && 10 < (b = gk + 500 - B())) {
              if (0 !== uc(a2, 0))
                break;
              if (((e = a2.suspendedLanes) & d) !== d) {
                L(), a2.pingedLanes |= a2.suspendedLanes & e;
                break;
              }
              a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b);
              break;
            }
            Qk(a2, uk, vk);
            break;
          case 4:
            if (Dk(a2, d), (4194240 & d) === d)
              break;
            for (b = a2.eventTimes, e = -1; 0 < d; ) {
              var g = 31 - oc(d);
              f = 1 << g, (g = b[g]) > e && (e = g), d &= ~f;
            }
            if (d = e, 10 < (d = (120 > (d = B() - d) ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * mk(d / 1960)) - d)) {
              a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d);
              break;
            }
            Qk(a2, uk, vk);
            break;
          default:
            throw Error(p(329));
        }
      }
    }
    return Ek(a2, B()), a2.callbackNode === c ? Hk.bind(null, a2) : null;
  }
  function Ok(a2, b) {
    var c = tk;
    return a2.current.memoizedState.isDehydrated && (Lk(a2, b).flags |= 256), 2 !== (a2 = Jk(a2, b)) && (b = uk, uk = c, null !== b && Gj(b)), a2;
  }
  function Gj(a2) {
    null === uk ? uk = a2 : uk.push.apply(uk, a2);
  }
  function Dk(a2, b) {
    for (b &= ~sk, b &= ~rk, a2.suspendedLanes |= b, a2.pingedLanes &= ~b, a2 = a2.expirationTimes; 0 < b; ) {
      var c = 31 - oc(b), d = 1 << c;
      a2[c] = -1, b &= ~d;
    }
  }
  function Fk(a2) {
    if (6 & K)
      throw Error(p(327));
    Ik();
    var b = uc(a2, 0);
    if (!(1 & b))
      return Ek(a2, B()), null;
    var c = Jk(a2, b);
    if (0 !== a2.tag && 2 === c) {
      var d = xc(a2);
      0 !== d && (b = d, c = Ok(a2, d));
    }
    if (1 === c)
      throw c = qk, Lk(a2, 0), Dk(a2, b), Ek(a2, B()), c;
    if (6 === c)
      throw Error(p(345));
    return a2.finishedWork = a2.current.alternate, a2.finishedLanes = b, Qk(a2, uk, vk), Ek(a2, B()), null;
  }
  function Rk(a2, b) {
    var c = K;
    K |= 1;
    try {
      return a2(b);
    } finally {
      0 === (K = c) && (Hj = B() + 500, fg && jg());
    }
  }
  function Sk(a2) {
    null !== xk && 0 === xk.tag && !(6 & K) && Ik();
    var b = K;
    K |= 1;
    var c = pk.transition, d = C;
    try {
      if (pk.transition = null, C = 1, a2)
        return a2();
    } finally {
      C = d, pk.transition = c, !(6 & (K = b)) && jg();
    }
  }
  function Ij() {
    gj = fj.current, E(fj);
  }
  function Lk(a2, b) {
    a2.finishedWork = null, a2.finishedLanes = 0;
    var c = a2.timeoutHandle;
    if (-1 !== c && (a2.timeoutHandle = -1, Gf(c)), null !== Y)
      for (c = Y.return; null !== c; ) {
        var d = c;
        switch (wg(d), d.tag) {
          case 1:
            null != (d = d.type.childContextTypes) && $f();
            break;
          case 3:
            Jh(), E(Wf), E(H), Oh();
            break;
          case 5:
            Lh(d);
            break;
          case 4:
            Jh();
            break;
          case 13:
          case 19:
            E(M);
            break;
          case 10:
            Rg(d.type._context);
            break;
          case 22:
          case 23:
            Ij();
        }
        c = c.return;
      }
    if (R = a2, Y = a2 = wh(a2.current, null), Z = gj = b, T = 0, qk = null, sk = rk = hh = 0, uk = tk = null, null !== Wg) {
      for (b = 0; b < Wg.length; b++)
        if (null !== (d = (c = Wg[b]).interleaved)) {
          c.interleaved = null;
          var e = d.next, f = c.pending;
          if (null !== f) {
            var g = f.next;
            f.next = e, d.next = g;
          }
          c.pending = d;
        }
      Wg = null;
    }
    return a2;
  }
  function Nk(a2, b) {
    for (; ; ) {
      var c = Y;
      try {
        if (Qg(), Ph.current = ai, Sh) {
          for (var d = N.memoizedState; null !== d; ) {
            var e = d.queue;
            null !== e && (e.pending = null), d = d.next;
          }
          Sh = false;
        }
        if (Rh = 0, P = O = N = null, Th = false, Uh = 0, ok.current = null, null === c || null === c.return) {
          T = 1, qk = b, Y = null;
          break;
        }
        a: {
          var f = a2, g = c.return, h = c, k = b;
          if (b = Z, h.flags |= 32768, null !== k && "object" == typeof k && "function" == typeof k.then) {
            var l = k, m = h, q = m.tag;
            if (!(1 & m.mode || 0 !== q && 11 !== q && 15 !== q)) {
              var r = m.alternate;
              r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
            }
            var y = Vi(g);
            if (null !== y) {
              y.flags &= -257, Wi(y, g, h, 0, b), 1 & y.mode && Ti(f, l, b), k = l;
              var n = (b = y).updateQueue;
              if (null === n) {
                var t = /* @__PURE__ */ new Set();
                t.add(k), b.updateQueue = t;
              } else
                n.add(k);
              break a;
            }
            if (!(1 & b)) {
              Ti(f, l, b), uj();
              break a;
            }
            k = Error(p(426));
          } else if (I && 1 & h.mode) {
            var J = Vi(g);
            if (null !== J) {
              !(65536 & J.flags) && (J.flags |= 256), Wi(J, g, h, 0, b), Jg(Ki(k, h));
              break a;
            }
          }
          f = k = Ki(k, h), 4 !== T && (T = 2), null === tk ? tk = [f] : tk.push(f), f = g;
          do {
            switch (f.tag) {
              case 3:
                f.flags |= 65536, b &= -b, f.lanes |= b, fh(f, Oi(0, k, b));
                break a;
              case 1:
                h = k;
                var w = f.type, u = f.stateNode;
                if (!(128 & f.flags || "function" != typeof w.getDerivedStateFromError && (null === u || "function" != typeof u.componentDidCatch || null !== Si && Si.has(u)))) {
                  f.flags |= 65536, b &= -b, f.lanes |= b, fh(f, Ri(f, h, b));
                  break a;
                }
            }
            f = f.return;
          } while (null !== f);
        }
        Tk(c);
      } catch (na) {
        b = na, Y === c && null !== c && (Y = c = c.return);
        continue;
      }
      break;
    }
  }
  function Kk() {
    var a2 = nk.current;
    return nk.current = ai, null === a2 ? ai : a2;
  }
  function uj() {
    0 !== T && 3 !== T && 2 !== T || (T = 4), null === R || !(268435455 & hh) && !(268435455 & rk) || Dk(R, Z);
  }
  function Jk(a2, b) {
    var c = K;
    K |= 2;
    var d = Kk();
    for (R === a2 && Z === b || (vk = null, Lk(a2, b)); ; )
      try {
        Uk();
        break;
      } catch (e) {
        Nk(a2, e);
      }
    if (Qg(), K = c, nk.current = d, null !== Y)
      throw Error(p(261));
    return R = null, Z = 0, T;
  }
  function Uk() {
    for (; null !== Y; )
      Vk(Y);
  }
  function Mk() {
    for (; null !== Y && !cc(); )
      Vk(Y);
  }
  function Vk(a2) {
    var b = Wk(a2.alternate, a2, gj);
    a2.memoizedProps = a2.pendingProps, null === b ? Tk(a2) : Y = b, ok.current = null;
  }
  function Tk(a2) {
    var b = a2;
    do {
      var c = b.alternate;
      if (a2 = b.return, 32768 & b.flags) {
        if (null !== (c = Jj(c, b)))
          return c.flags &= 32767, void (Y = c);
        if (null === a2)
          return T = 6, void (Y = null);
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      } else if (null !== (c = Fj(c, b, gj)))
        return void (Y = c);
      if (null !== (b = b.sibling))
        return void (Y = b);
      Y = b = a2;
    } while (null !== b);
    0 === T && (T = 5);
  }
  function Qk(a2, b, c) {
    var d = C, e = pk.transition;
    try {
      pk.transition = null, C = 1, function(a3, b2, c2, d2) {
        do {
          Ik();
        } while (null !== xk);
        if (6 & K)
          throw Error(p(327));
        c2 = a3.finishedWork;
        var e2 = a3.finishedLanes;
        if (null === c2)
          return null;
        if (a3.finishedWork = null, a3.finishedLanes = 0, c2 === a3.current)
          throw Error(p(177));
        a3.callbackNode = null, a3.callbackPriority = 0;
        var f = c2.lanes | c2.childLanes;
        if (function(a4, b3) {
          var c3 = a4.pendingLanes & ~b3;
          a4.pendingLanes = b3, a4.suspendedLanes = 0, a4.pingedLanes = 0, a4.expiredLanes &= b3, a4.mutableReadLanes &= b3, a4.entangledLanes &= b3, b3 = a4.entanglements;
          var d3 = a4.eventTimes;
          for (a4 = a4.expirationTimes; 0 < c3; ) {
            var e3 = 31 - oc(c3), f2 = 1 << e3;
            b3[e3] = 0, d3[e3] = -1, a4[e3] = -1, c3 &= ~f2;
          }
        }(a3, f), a3 === R && (Y = R = null, Z = 0), !(2064 & c2.subtreeFlags) && !(2064 & c2.flags) || wk || (wk = true, Gk(hc, function() {
          return Ik(), null;
        })), f = !!(15990 & c2.flags), 15990 & c2.subtreeFlags || f) {
          f = pk.transition, pk.transition = null;
          var g = C;
          C = 1;
          var h = K;
          K |= 4, ok.current = null, function(a4, b3) {
            if (Cf = dd, Ne(a4 = Me())) {
              if ("selectionStart" in a4)
                var c3 = { start: a4.selectionStart, end: a4.selectionEnd };
              else
                a: {
                  var d3 = (c3 = (c3 = a4.ownerDocument) && c3.defaultView || window).getSelection && c3.getSelection();
                  if (d3 && 0 !== d3.rangeCount) {
                    c3 = d3.anchorNode;
                    var e3 = d3.anchorOffset, f2 = d3.focusNode;
                    d3 = d3.focusOffset;
                    try {
                      c3.nodeType, f2.nodeType;
                    } catch (F) {
                      c3 = null;
                      break a;
                    }
                    var g2 = 0, h2 = -1, k = -1, l = 0, m = 0, q = a4, r = null;
                    b:
                      for (; ; ) {
                        for (var y; q !== c3 || 0 !== e3 && 3 !== q.nodeType || (h2 = g2 + e3), q !== f2 || 0 !== d3 && 3 !== q.nodeType || (k = g2 + d3), 3 === q.nodeType && (g2 += q.nodeValue.length), null !== (y = q.firstChild); )
                          r = q, q = y;
                        for (; ; ) {
                          if (q === a4)
                            break b;
                          if (r === c3 && ++l === e3 && (h2 = g2), r === f2 && ++m === d3 && (k = g2), null !== (y = q.nextSibling))
                            break;
                          r = (q = r).parentNode;
                        }
                        q = y;
                      }
                    c3 = -1 === h2 || -1 === k ? null : { start: h2, end: k };
                  } else
                    c3 = null;
                }
              c3 = c3 || { start: 0, end: 0 };
            } else
              c3 = null;
            for (Df = { focusedElem: a4, selectionRange: c3 }, dd = false, V = b3; null !== V; )
              if (a4 = (b3 = V).child, 1028 & b3.subtreeFlags && null !== a4)
                a4.return = b3, V = a4;
              else
                for (; null !== V; ) {
                  b3 = V;
                  try {
                    var n = b3.alternate;
                    if (1024 & b3.flags)
                      switch (b3.tag) {
                        case 0:
                        case 11:
                        case 15:
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                          break;
                        case 1:
                          if (null !== n) {
                            var t = n.memoizedProps, J = n.memoizedState, x = b3.stateNode, w = x.getSnapshotBeforeUpdate(b3.elementType === b3.type ? t : Lg(b3.type, t), J);
                            x.__reactInternalSnapshotBeforeUpdate = w;
                          }
                          break;
                        case 3:
                          var u = b3.stateNode.containerInfo;
                          1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
                          break;
                        default:
                          throw Error(p(163));
                      }
                  } catch (F) {
                    W(b3, b3.return, F);
                  }
                  if (null !== (a4 = b3.sibling)) {
                    a4.return = b3.return, V = a4;
                    break;
                  }
                  V = b3.return;
                }
            n = Oj, Oj = false;
          }(a3, c2), ek(c2, a3), Oe(Df), dd = !!Cf, Df = Cf = null, a3.current = c2, ik(c2), dc(), K = h, C = g, pk.transition = f;
        } else
          a3.current = c2;
        if (wk && (wk = false, xk = a3, yk = e2), 0 === (f = a3.pendingLanes) && (Si = null), function(a4) {
          if (lc && "function" == typeof lc.onCommitFiberRoot)
            try {
              lc.onCommitFiberRoot(kc, a4, void 0, !(128 & ~a4.current.flags));
            } catch (b3) {
            }
        }(c2.stateNode), Ek(a3, B()), null !== b2)
          for (d2 = a3.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
            d2((e2 = b2[c2]).value, { componentStack: e2.stack, digest: e2.digest });
        if (Pi)
          throw Pi = false, a3 = Qi, Qi = null, a3;
        !!(1 & yk) && 0 !== a3.tag && Ik(), 1 & (f = a3.pendingLanes) ? a3 === Ak ? zk++ : (zk = 0, Ak = a3) : zk = 0, jg();
      }(a2, b, c, d);
    } finally {
      pk.transition = e, C = d;
    }
    return null;
  }
  function Ik() {
    if (null !== xk) {
      var a2 = Dc(yk), b = pk.transition, c = C;
      try {
        if (pk.transition = null, C = 16 > a2 ? 16 : a2, null === xk)
          var d = false;
        else {
          if (a2 = xk, xk = null, yk = 0, 6 & K)
            throw Error(p(331));
          var e = K;
          for (K |= 4, V = a2.current; null !== V; ) {
            var f = V, g = f.child;
            if (16 & V.flags) {
              var h = f.deletions;
              if (null !== h) {
                for (var k = 0; k < h.length; k++) {
                  var l = h[k];
                  for (V = l; null !== V; ) {
                    var m = V;
                    switch (m.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(8, m, f);
                    }
                    var q = m.child;
                    if (null !== q)
                      q.return = m, V = q;
                    else
                      for (; null !== V; ) {
                        var r = (m = V).sibling, y = m.return;
                        if (Tj(m), m === l) {
                          V = null;
                          break;
                        }
                        if (null !== r) {
                          r.return = y, V = r;
                          break;
                        }
                        V = y;
                      }
                  }
                }
                var n = f.alternate;
                if (null !== n) {
                  var t = n.child;
                  if (null !== t) {
                    n.child = null;
                    do {
                      var J = t.sibling;
                      t.sibling = null, t = J;
                    } while (null !== t);
                  }
                }
                V = f;
              }
            }
            if (2064 & f.subtreeFlags && null !== g)
              g.return = f, V = g;
            else
              b:
                for (; null !== V; ) {
                  if (2048 & (f = V).flags)
                    switch (f.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(9, f, f.return);
                    }
                  var x = f.sibling;
                  if (null !== x) {
                    x.return = f.return, V = x;
                    break b;
                  }
                  V = f.return;
                }
          }
          var w = a2.current;
          for (V = w; null !== V; ) {
            var u = (g = V).child;
            if (2064 & g.subtreeFlags && null !== u)
              u.return = g, V = u;
            else
              b:
                for (g = w; null !== V; ) {
                  if (2048 & (h = V).flags)
                    try {
                      switch (h.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Rj(9, h);
                      }
                    } catch (na) {
                      W(h, h.return, na);
                    }
                  if (h === g) {
                    V = null;
                    break b;
                  }
                  var F = h.sibling;
                  if (null !== F) {
                    F.return = h.return, V = F;
                    break b;
                  }
                  V = h.return;
                }
          }
          if (K = e, jg(), lc && "function" == typeof lc.onPostCommitFiberRoot)
            try {
              lc.onPostCommitFiberRoot(kc, a2);
            } catch (na) {
            }
          d = true;
        }
        return d;
      } finally {
        C = c, pk.transition = b;
      }
    }
    return false;
  }
  function Yk(a2, b, c) {
    a2 = dh(a2, b = Oi(0, b = Ki(c, b), 1), 1), b = L(), null !== a2 && (Ac(a2, 1, b), Ek(a2, b));
  }
  function W(a2, b, c) {
    if (3 === a2.tag)
      Yk(a2, a2, c);
    else
      for (; null !== b; ) {
        if (3 === b.tag) {
          Yk(b, a2, c);
          break;
        }
        if (1 === b.tag) {
          var d = b.stateNode;
          if ("function" == typeof b.type.getDerivedStateFromError || "function" == typeof d.componentDidCatch && (null === Si || !Si.has(d))) {
            b = dh(b, a2 = Ri(b, a2 = Ki(c, a2), 1), 1), a2 = L(), null !== b && (Ac(b, 1, a2), Ek(b, a2));
            break;
          }
        }
        b = b.return;
      }
  }
  function Ui(a2, b, c) {
    var d = a2.pingCache;
    null !== d && d.delete(b), b = L(), a2.pingedLanes |= a2.suspendedLanes & c, R === a2 && (Z & c) === c && (4 === T || 3 === T && (130023424 & Z) === Z && 500 > B() - gk ? Lk(a2, 0) : sk |= c), Ek(a2, b);
  }
  function Zk(a2, b) {
    0 === b && (1 & a2.mode ? (b = sc, !(130023424 & (sc <<= 1)) && (sc = 4194304)) : b = 1);
    var c = L();
    null !== (a2 = Zg(a2, b)) && (Ac(a2, b, c), Ek(a2, c));
  }
  function vj(a2) {
    var b = a2.memoizedState, c = 0;
    null !== b && (c = b.retryLane), Zk(a2, c);
  }
  function ck(a2, b) {
    var c = 0;
    switch (a2.tag) {
      case 13:
        var d = a2.stateNode, e = a2.memoizedState;
        null !== e && (c = e.retryLane);
        break;
      case 19:
        d = a2.stateNode;
        break;
      default:
        throw Error(p(314));
    }
    null !== d && d.delete(b), Zk(a2, c);
  }
  function Gk(a2, b) {
    return ac(a2, b);
  }
  function al(a2, b, c, d) {
    this.tag = a2, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = b, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = d, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Bg(a2, b, c, d) {
    return new al(a2, b, c, d);
  }
  function bj(a2) {
    return !(!(a2 = a2.prototype) || !a2.isReactComponent);
  }
  function wh(a2, b) {
    var c = a2.alternate;
    return null === c ? ((c = Bg(a2.tag, b, a2.key, a2.mode)).elementType = a2.elementType, c.type = a2.type, c.stateNode = a2.stateNode, c.alternate = a2, a2.alternate = c) : (c.pendingProps = b, c.type = a2.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = 14680064 & a2.flags, c.childLanes = a2.childLanes, c.lanes = a2.lanes, c.child = a2.child, c.memoizedProps = a2.memoizedProps, c.memoizedState = a2.memoizedState, c.updateQueue = a2.updateQueue, b = a2.dependencies, c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext }, c.sibling = a2.sibling, c.index = a2.index, c.ref = a2.ref, c;
  }
  function yh(a2, b, c, d, e, f) {
    var g = 2;
    if (d = a2, "function" == typeof a2)
      bj(a2) && (g = 1);
    else if ("string" == typeof a2)
      g = 5;
    else
      a:
        switch (a2) {
          case ya:
            return Ah(c.children, e, f, b);
          case za:
            g = 8, e |= 8;
            break;
          case Aa:
            return (a2 = Bg(12, c, b, 2 | e)).elementType = Aa, a2.lanes = f, a2;
          case Ea:
            return (a2 = Bg(13, c, b, e)).elementType = Ea, a2.lanes = f, a2;
          case Fa:
            return (a2 = Bg(19, c, b, e)).elementType = Fa, a2.lanes = f, a2;
          case Ia:
            return qj(c, e, f, b);
          default:
            if ("object" == typeof a2 && null !== a2)
              switch (a2.$$typeof) {
                case Ba:
                  g = 10;
                  break a;
                case Ca:
                  g = 9;
                  break a;
                case Da:
                  g = 11;
                  break a;
                case Ga:
                  g = 14;
                  break a;
                case Ha:
                  g = 16, d = null;
                  break a;
              }
            throw Error(p(130, null == a2 ? a2 : typeof a2, ""));
        }
    return (b = Bg(g, c, b, e)).elementType = a2, b.type = d, b.lanes = f, b;
  }
  function Ah(a2, b, c, d) {
    return (a2 = Bg(7, a2, d, b)).lanes = c, a2;
  }
  function qj(a2, b, c, d) {
    return (a2 = Bg(22, a2, d, b)).elementType = Ia, a2.lanes = c, a2.stateNode = { isHidden: false }, a2;
  }
  function xh(a2, b, c) {
    return (a2 = Bg(6, a2, null, b)).lanes = c, a2;
  }
  function zh(a2, b, c) {
    return (b = Bg(4, null !== a2.children ? a2.children : [], a2.key, b)).lanes = c, b.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation }, b;
  }
  function bl(a2, b, c, d, e) {
    this.tag = b, this.containerInfo = a2, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = zc(0), this.expirationTimes = zc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = zc(0), this.identifierPrefix = d, this.onRecoverableError = e, this.mutableSourceEagerHydrationData = null;
  }
  function cl(a2, b, c, d, e, f, g, h, k) {
    return a2 = new bl(a2, b, c, h, k), 1 === b ? (b = 1, true === f && (b |= 8)) : b = 0, f = Bg(3, null, null, b), a2.current = f, f.stateNode = a2, f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null }, ah(f), a2;
  }
  function el(a2) {
    if (!a2)
      return Vf;
    a: {
      if (Vb(a2 = a2._reactInternals) !== a2 || 1 !== a2.tag)
        throw Error(p(170));
      var b = a2;
      do {
        switch (b.tag) {
          case 3:
            b = b.stateNode.context;
            break a;
          case 1:
            if (Zf(b.type)) {
              b = b.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b = b.return;
      } while (null !== b);
      throw Error(p(171));
    }
    if (1 === a2.tag) {
      var c = a2.type;
      if (Zf(c))
        return bg(a2, c, b);
    }
    return b;
  }
  function fl(a2, b, c, d, e, f, g, h, k) {
    return (a2 = cl(c, d, true, a2, 0, f, 0, h, k)).context = el(null), c = a2.current, (f = ch(d = L(), e = lh(c))).callback = null != b ? b : null, dh(c, f, e), a2.current.lanes = e, Ac(a2, e, d), Ek(a2, d), a2;
  }
  function gl(a2, b, c, d) {
    var e = b.current, f = L(), g = lh(e);
    return c = el(c), null === b.context ? b.context = c : b.pendingContext = c, (b = ch(f, g)).payload = { element: a2 }, null !== (d = void 0 === d ? null : d) && (b.callback = d), null !== (a2 = dh(e, b, g)) && (mh(a2, e, g, f), eh(a2, e, g)), g;
  }
  function hl(a2) {
    return (a2 = a2.current).child ? (a2.child.tag, a2.child.stateNode) : null;
  }
  function il(a2, b) {
    if (null !== (a2 = a2.memoizedState) && null !== a2.dehydrated) {
      var c = a2.retryLane;
      a2.retryLane = 0 !== c && c < b ? c : b;
    }
  }
  function jl(a2, b) {
    il(a2, b), (a2 = a2.alternate) && il(a2, b);
  }
  Wk = function(a2, b, c) {
    if (null !== a2)
      if (a2.memoizedProps !== b.pendingProps || Wf.current)
        Ug = true;
      else {
        if (!(a2.lanes & c || 128 & b.flags))
          return Ug = false, function(a3, b2, c2) {
            switch (b2.tag) {
              case 3:
                lj(b2), Ig();
                break;
              case 5:
                Kh(b2);
                break;
              case 1:
                Zf(b2.type) && cg(b2);
                break;
              case 4:
                Ih(b2, b2.stateNode.containerInfo);
                break;
              case 10:
                var d2 = b2.type._context, e2 = b2.memoizedProps.value;
                G(Mg, d2._currentValue), d2._currentValue = e2;
                break;
              case 13:
                if (null !== (d2 = b2.memoizedState))
                  return null !== d2.dehydrated ? (G(M, 1 & M.current), b2.flags |= 128, null) : c2 & b2.child.childLanes ? pj(a3, b2, c2) : (G(M, 1 & M.current), null !== (a3 = $i(a3, b2, c2)) ? a3.sibling : null);
                G(M, 1 & M.current);
                break;
              case 19:
                if (d2 = !!(c2 & b2.childLanes), 128 & a3.flags) {
                  if (d2)
                    return yj(a3, b2, c2);
                  b2.flags |= 128;
                }
                if (null !== (e2 = b2.memoizedState) && (e2.rendering = null, e2.tail = null, e2.lastEffect = null), G(M, M.current), d2)
                  break;
                return null;
              case 22:
              case 23:
                return b2.lanes = 0, ej(a3, b2, c2);
            }
            return $i(a3, b2, c2);
          }(a2, b, c);
        Ug = !!(131072 & a2.flags);
      }
    else
      Ug = false, I && 1048576 & b.flags && ug(b, ng, b.index);
    switch (b.lanes = 0, b.tag) {
      case 2:
        var d = b.type;
        jj(a2, b), a2 = b.pendingProps;
        var e = Yf(b, H.current);
        Tg(b, c), e = Xh(null, b, d, a2, e, c);
        var f = bi();
        return b.flags |= 1, "object" == typeof e && null !== e && "function" == typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, ah(b), e.updater = nh, b.stateNode = e, e._reactInternals = b, rh(b, d, a2, c), b = kj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Yi(null, b, e, c), b = b.child), b;
      case 16:
        d = b.elementType;
        a: {
          switch (jj(a2, b), a2 = b.pendingProps, d = (e = d._init)(d._payload), b.type = d, e = b.tag = function(a3) {
            if ("function" == typeof a3)
              return bj(a3) ? 1 : 0;
            if (null != a3) {
              if ((a3 = a3.$$typeof) === Da)
                return 11;
              if (a3 === Ga)
                return 14;
            }
            return 2;
          }(d), a2 = Lg(d, a2), e) {
            case 0:
              b = dj(null, b, d, a2, c);
              break a;
            case 1:
              b = ij(null, b, d, a2, c);
              break a;
            case 11:
              b = Zi(null, b, d, a2, c);
              break a;
            case 14:
              b = aj(null, b, d, Lg(d.type, a2), c);
              break a;
          }
          throw Error(p(306, d, ""));
        }
        return b;
      case 0:
        return d = b.type, e = b.pendingProps, dj(a2, b, d, e = b.elementType === d ? e : Lg(d, e), c);
      case 1:
        return d = b.type, e = b.pendingProps, ij(a2, b, d, e = b.elementType === d ? e : Lg(d, e), c);
      case 3:
        a: {
          if (lj(b), null === a2)
            throw Error(p(387));
          d = b.pendingProps, e = (f = b.memoizedState).element, bh(a2, b), gh(b, d, null, c);
          var g = b.memoizedState;
          if (d = g.element, f.isDehydrated) {
            if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, 256 & b.flags) {
              b = mj(a2, b, d, c, e = Ki(Error(p(423)), b));
              break a;
            }
            if (d !== e) {
              b = mj(a2, b, d, c, e = Ki(Error(p(424)), b));
              break a;
            }
            for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Ch(b, null, d, c), b.child = c; c; )
              c.flags = -3 & c.flags | 4096, c = c.sibling;
          } else {
            if (Ig(), d === e) {
              b = $i(a2, b, c);
              break a;
            }
            Yi(a2, b, d, c);
          }
          b = b.child;
        }
        return b;
      case 5:
        return Kh(b), null === a2 && Eg(b), d = b.type, e = b.pendingProps, f = null !== a2 ? a2.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), hj(a2, b), Yi(a2, b, g, c), b.child;
      case 6:
        return null === a2 && Eg(b), null;
      case 13:
        return pj(a2, b, c);
      case 4:
        return Ih(b, b.stateNode.containerInfo), d = b.pendingProps, null === a2 ? b.child = Bh(b, null, d, c) : Yi(a2, b, d, c), b.child;
      case 11:
        return d = b.type, e = b.pendingProps, Zi(a2, b, d, e = b.elementType === d ? e : Lg(d, e), c);
      case 7:
        return Yi(a2, b, b.pendingProps, c), b.child;
      case 8:
      case 12:
        return Yi(a2, b, b.pendingProps.children, c), b.child;
      case 10:
        a: {
          if (d = b.type._context, e = b.pendingProps, f = b.memoizedProps, g = e.value, G(Mg, d._currentValue), d._currentValue = g, null !== f)
            if (He(f.value, g)) {
              if (f.children === e.children && !Wf.current) {
                b = $i(a2, b, c);
                break a;
              }
            } else
              for (null !== (f = b.child) && (f.return = b); null !== f; ) {
                var h = f.dependencies;
                if (null !== h) {
                  g = f.child;
                  for (var k = h.firstContext; null !== k; ) {
                    if (k.context === d) {
                      if (1 === f.tag) {
                        (k = ch(-1, c & -c)).tag = 2;
                        var l = f.updateQueue;
                        if (null !== l) {
                          var m = (l = l.shared).pending;
                          null === m ? k.next = k : (k.next = m.next, m.next = k), l.pending = k;
                        }
                      }
                      f.lanes |= c, null !== (k = f.alternate) && (k.lanes |= c), Sg(f.return, c, b), h.lanes |= c;
                      break;
                    }
                    k = k.next;
                  }
                } else if (10 === f.tag)
                  g = f.type === b.type ? null : f.child;
                else if (18 === f.tag) {
                  if (null === (g = f.return))
                    throw Error(p(341));
                  g.lanes |= c, null !== (h = g.alternate) && (h.lanes |= c), Sg(g, c, b), g = f.sibling;
                } else
                  g = f.child;
                if (null !== g)
                  g.return = f;
                else
                  for (g = f; null !== g; ) {
                    if (g === b) {
                      g = null;
                      break;
                    }
                    if (null !== (f = g.sibling)) {
                      f.return = g.return, g = f;
                      break;
                    }
                    g = g.return;
                  }
                f = g;
              }
          Yi(a2, b, e.children, c), b = b.child;
        }
        return b;
      case 9:
        return e = b.type, d = b.pendingProps.children, Tg(b, c), d = d(e = Vg(e)), b.flags |= 1, Yi(a2, b, d, c), b.child;
      case 14:
        return e = Lg(d = b.type, b.pendingProps), aj(a2, b, d, e = Lg(d.type, e), c);
      case 15:
        return cj(a2, b, b.type, b.pendingProps, c);
      case 17:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), jj(a2, b), b.tag = 1, Zf(d) ? (a2 = true, cg(b)) : a2 = false, Tg(b, c), ph(b, d, e), rh(b, d, e, c), kj(null, b, d, true, a2, c);
      case 19:
        return yj(a2, b, c);
      case 22:
        return ej(a2, b, c);
    }
    throw Error(p(156, b.tag));
  };
  var ll = "function" == typeof reportError ? reportError : function(a2) {
    console.error(a2);
  };
  function ml(a2) {
    this._internalRoot = a2;
  }
  function nl(a2) {
    this._internalRoot = a2;
  }
  function ol(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
  }
  function pl(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
  }
  function ql() {
  }
  function sl(a2, b, c, d, e) {
    var f = c._reactRootContainer;
    if (f) {
      var g = f;
      if ("function" == typeof e) {
        var h = e;
        e = function() {
          var a3 = hl(g);
          h.call(a3);
        };
      }
      gl(b, g, a2, e);
    } else
      g = function(a3, b2, c2, d2, e2) {
        if (e2) {
          if ("function" == typeof d2) {
            var f2 = d2;
            d2 = function() {
              var a4 = hl(g2);
              f2.call(a4);
            };
          }
          var g2 = fl(b2, d2, a3, 0, null, false, 0, "", ql);
          return a3._reactRootContainer = g2, a3[uf] = g2.current, sf(8 === a3.nodeType ? a3.parentNode : a3), Sk(), g2;
        }
        for (; e2 = a3.lastChild; )
          a3.removeChild(e2);
        if ("function" == typeof d2) {
          var h2 = d2;
          d2 = function() {
            var a4 = hl(k);
            h2.call(a4);
          };
        }
        var k = cl(a3, 0, false, null, 0, false, 0, "", ql);
        return a3._reactRootContainer = k, a3[uf] = k.current, sf(8 === a3.nodeType ? a3.parentNode : a3), Sk(function() {
          gl(b2, k, c2, d2);
        }), k;
      }(c, b, a2, e, d);
    return hl(g);
  }
  nl.prototype.render = ml.prototype.render = function(a2) {
    var b = this._internalRoot;
    if (null === b)
      throw Error(p(409));
    gl(a2, b, null, null);
  }, nl.prototype.unmount = ml.prototype.unmount = function() {
    var a2 = this._internalRoot;
    if (null !== a2) {
      this._internalRoot = null;
      var b = a2.containerInfo;
      Sk(function() {
        gl(null, a2, null, null);
      }), b[uf] = null;
    }
  }, nl.prototype.unstable_scheduleHydration = function(a2) {
    if (a2) {
      var b = Hc();
      a2 = { blockedOn: null, target: a2, priority: b };
      for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++)
        ;
      Qc.splice(c, 0, a2), 0 === c && Vc(a2);
    }
  }, Ec = function(a2) {
    switch (a2.tag) {
      case 3:
        var b = a2.stateNode;
        if (b.current.memoizedState.isDehydrated) {
          var c = tc(b.pendingLanes);
          0 !== c && (Cc(b, 1 | c), Ek(b, B()), !(6 & K) && (Hj = B() + 500, jg()));
        }
        break;
      case 13:
        Sk(function() {
          var b2 = Zg(a2, 1);
          if (null !== b2) {
            var c2 = L();
            mh(b2, a2, 1, c2);
          }
        }), jl(a2, 1);
    }
  }, Fc = function(a2) {
    if (13 === a2.tag) {
      var b = Zg(a2, 134217728);
      null !== b && mh(b, a2, 134217728, L()), jl(a2, 134217728);
    }
  }, Gc = function(a2) {
    if (13 === a2.tag) {
      var b = lh(a2), c = Zg(a2, b);
      null !== c && mh(c, a2, b, L()), jl(a2, b);
    }
  }, Hc = function() {
    return C;
  }, Ic = function(a2, b) {
    var c = C;
    try {
      return C = a2, b();
    } finally {
      C = c;
    }
  }, yb = function(a2, b, c) {
    switch (b) {
      case "input":
        if (bb(a2, c), b = c.name, "radio" === c.type && null != b) {
          for (c = a2; c.parentNode; )
            c = c.parentNode;
          for (c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]'), b = 0; b < c.length; b++) {
            var d = c[b];
            if (d !== a2 && d.form === a2.form) {
              var e = Db(d);
              if (!e)
                throw Error(p(90));
              Wa(d), bb(d, e);
            }
          }
        }
        break;
      case "textarea":
        ib(a2, c);
        break;
      case "select":
        null != (b = c.value) && fb(a2, !!c.multiple, b, false);
    }
  }, Gb = Rk, Hb = Sk;
  var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
    return null === (a2 = Zb(a2)) ? null : a2.stateNode;
  }, findFiberByHostInstance: ul.findFiberByHostInstance || function() {
    return null;
  }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!wl.isDisabled && wl.supportsFiber)
      try {
        kc = wl.inject(vl), lc = wl;
      } catch (a2) {
      }
  }
  return reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl, reactDom_production_min.createPortal = function(a2, b) {
    var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!ol(b))
      throw Error(p(200));
    return function(a3, b2, c2) {
      var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d ? null : "" + d, children: a3, containerInfo: b2, implementation: c2 };
    }(a2, b, null, c);
  }, reactDom_production_min.createRoot = function(a2, b) {
    if (!ol(a2))
      throw Error(p(299));
    var c = false, d = "", e = ll;
    return null != b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError)), b = cl(a2, 1, false, null, 0, c, 0, d, e), a2[uf] = b.current, sf(8 === a2.nodeType ? a2.parentNode : a2), new ml(b);
  }, reactDom_production_min.findDOMNode = function(a2) {
    if (null == a2)
      return null;
    if (1 === a2.nodeType)
      return a2;
    var b = a2._reactInternals;
    if (void 0 === b) {
      if ("function" == typeof a2.render)
        throw Error(p(188));
      throw a2 = Object.keys(a2).join(","), Error(p(268, a2));
    }
    return null === (a2 = Zb(b)) ? null : a2.stateNode;
  }, reactDom_production_min.flushSync = function(a2) {
    return Sk(a2);
  }, reactDom_production_min.hydrate = function(a2, b, c) {
    if (!pl(b))
      throw Error(p(200));
    return sl(null, a2, b, true, c);
  }, reactDom_production_min.hydrateRoot = function(a2, b, c) {
    if (!ol(a2))
      throw Error(p(405));
    var d = null != c && c.hydratedSources || null, e = false, f = "", g = ll;
    if (null != c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError)), b = fl(b, null, a2, 1, null != c ? c : null, e, 0, f, g), a2[uf] = b.current, sf(a2), d)
      for (a2 = 0; a2 < d.length; a2++)
        e = (e = (c = d[a2])._getVersion)(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(c, e);
    return new nl(b);
  }, reactDom_production_min.render = function(a2, b, c) {
    if (!pl(b))
      throw Error(p(200));
    return sl(null, a2, b, false, c);
  }, reactDom_production_min.unmountComponentAtNode = function(a2) {
    if (!pl(a2))
      throw Error(p(40));
    return !!a2._reactRootContainer && (Sk(function() {
      sl(null, null, a2, false, function() {
        a2._reactRootContainer = null, a2[uf] = null;
      });
    }), true);
  }, reactDom_production_min.unstable_batchedUpdates = Rk, reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b, c, d) {
    if (!pl(c))
      throw Error(p(200));
    if (null == a2 || void 0 === a2._reactInternals)
      throw Error(p(38));
    return sl(a2, b, c, false, d);
  }, reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608", reactDom_production_min;
}();
var reactDomExports = reactDom.exports;

var jsxRuntime$2 = {exports: {}};

var reactJsxRuntime_development = {};

var jsxs_1;
var jsx_1;
var Fragment$1;
"use strict";
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
if (true) {
  (function() {
    "use strict";
    var React = reactExports;
    var REACT_ELEMENT_TYPE = Symbol.for("react.element");
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
    var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
    var REACT_MEMO_TYPE = Symbol.for("react.memo");
    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = "@@iterator";
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== "object") {
        return null;
      }
      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
      if (typeof maybeIterator === "function") {
        return maybeIterator;
      }
      return null;
    }
    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function error(format) {
      {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          printWarning("error", format, args);
        }
      }
    }
    function printWarning(level, format, args) {
      {
        var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame2.getStackAddendum();
        if (stack !== "") {
          format += "%s";
          args = args.concat([stack]);
        }
        var argsWithFormat = args.map(function(item) {
          return String(item);
        });
        argsWithFormat.unshift("Warning: " + format);
        Function.prototype.apply.call(console[level], console, argsWithFormat);
      }
    }
    var enableScopeAPI = false;
    var enableCacheElement = false;
    var enableTransitionTracing = false;
    var enableLegacyHidden = false;
    var enableDebugTracing = false;
    var REACT_MODULE_REFERENCE;
    {
      REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
    }
    function isValidElementType(type) {
      if (typeof type === "string" || typeof type === "function") {
        return true;
      }
      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
        return true;
      }
      if (typeof type === "object" && type !== null) {
        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
          return true;
        }
      }
      return false;
    }
    function getWrappedName(outerType, innerType, wrapperName) {
      var displayName = outerType.displayName;
      if (displayName) {
        return displayName;
      }
      var functionName = innerType.displayName || innerType.name || "";
      return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
    }
    function getContextName(type) {
      return type.displayName || "Context";
    }
    function getComponentNameFromType(type) {
      if (type == null) {
        return null;
      }
      {
        if (typeof type.tag === "number") {
          error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
        }
      }
      if (typeof type === "function") {
        return type.displayName || type.name || null;
      }
      if (typeof type === "string") {
        return type;
      }
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
      }
      if (typeof type === "object") {
        switch (type.$$typeof) {
          case REACT_CONTEXT_TYPE:
            var context = type;
            return getContextName(context) + ".Consumer";
          case REACT_PROVIDER_TYPE:
            var provider = type;
            return getContextName(provider._context) + ".Provider";
          case REACT_FORWARD_REF_TYPE:
            return getWrappedName(type, type.render, "ForwardRef");
          case REACT_MEMO_TYPE:
            var outerName = type.displayName || null;
            if (outerName !== null) {
              return outerName;
            }
            return getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE: {
            var lazyComponent = type;
            var payload = lazyComponent._payload;
            var init = lazyComponent._init;
            try {
              return getComponentNameFromType(init(payload));
            } catch (x) {
              return null;
            }
          }
        }
      }
      return null;
    }
    var assign = Object.assign;
    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;
    function disabledLog() {
    }
    disabledLog.__reactDisabledLog = true;
    function disableLogs() {
      {
        if (disabledDepth === 0) {
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd;
          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          };
          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
        }
        disabledDepth++;
      }
    }
    function reenableLogs() {
      {
        disabledDepth--;
        if (disabledDepth === 0) {
          var props = {
            configurable: true,
            enumerable: true,
            writable: true
          };
          Object.defineProperties(console, {
            log: assign({}, props, {
              value: prevLog
            }),
            info: assign({}, props, {
              value: prevInfo
            }),
            warn: assign({}, props, {
              value: prevWarn
            }),
            error: assign({}, props, {
              value: prevError
            }),
            group: assign({}, props, {
              value: prevGroup
            }),
            groupCollapsed: assign({}, props, {
              value: prevGroupCollapsed
            }),
            groupEnd: assign({}, props, {
              value: prevGroupEnd
            })
          });
        }
        if (disabledDepth < 0) {
          error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
    }
    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
      {
        if (prefix === void 0) {
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
          }
        }
        return "\n" + prefix + name;
      }
    }
    var reentry = false;
    var componentFrameCache;
    {
      var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
      componentFrameCache = new PossiblyWeakMap();
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) {
        return "";
      }
      {
        var frame = componentFrameCache.get(fn);
        if (frame !== void 0) {
          return frame;
        }
      }
      var control;
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var previousDispatcher;
      {
        previousDispatcher = ReactCurrentDispatcher.current;
        ReactCurrentDispatcher.current = null;
        disableLogs();
      }
      try {
        if (construct) {
          var Fake = function() {
            throw Error();
          };
          Object.defineProperty(Fake.prototype, "props", {
            set: function() {
              throw Error();
            }
          });
          if (typeof Reflect === "object" && Reflect.construct) {
            try {
              Reflect.construct(Fake, []);
            } catch (x) {
              control = x;
            }
            Reflect.construct(fn, [], Fake);
          } else {
            try {
              Fake.call();
            } catch (x) {
              control = x;
            }
            fn.call(Fake.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (x) {
            control = x;
          }
          fn();
        }
      } catch (sample) {
        if (sample && control && typeof sample.stack === "string") {
          var sampleLines = sample.stack.split("\n");
          var controlLines = control.stack.split("\n");
          var s = sampleLines.length - 1;
          var c = controlLines.length - 1;
          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
            c--;
          }
          for (; s >= 1 && c >= 0; s--, c--) {
            if (sampleLines[s] !== controlLines[c]) {
              if (s !== 1 || c !== 1) {
                do {
                  s--;
                  c--;
                  if (c < 0 || sampleLines[s] !== controlLines[c]) {
                    var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                    if (fn.displayName && _frame.includes("<anonymous>")) {
                      _frame = _frame.replace("<anonymous>", fn.displayName);
                    }
                    {
                      if (typeof fn === "function") {
                        componentFrameCache.set(fn, _frame);
                      }
                    }
                    return _frame;
                  }
                } while (s >= 1 && c >= 0);
              }
              break;
            }
          }
        }
      } finally {
        reentry = false;
        {
          ReactCurrentDispatcher.current = previousDispatcher;
          reenableLogs();
        }
        Error.prepareStackTrace = previousPrepareStackTrace;
      }
      var name = fn ? fn.displayName || fn.name : "";
      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
      {
        if (typeof fn === "function") {
          componentFrameCache.set(fn, syntheticFrame);
        }
      }
      return syntheticFrame;
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
      {
        return describeNativeComponentFrame(fn, false);
      }
    }
    function shouldConstruct(Component) {
      var prototype = Component.prototype;
      return !!(prototype && prototype.isReactComponent);
    }
    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
      if (type == null) {
        return "";
      }
      if (typeof type === "function") {
        {
          return describeNativeComponentFrame(type, shouldConstruct(type));
        }
      }
      if (typeof type === "string") {
        return describeBuiltInComponentFrame(type);
      }
      switch (type) {
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame("Suspense");
        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame("SuspenseList");
      }
      if (typeof type === "object") {
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            return describeFunctionComponentFrame(type.render);
          case REACT_MEMO_TYPE:
            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
          case REACT_LAZY_TYPE: {
            var lazyComponent = type;
            var payload = lazyComponent._payload;
            var init = lazyComponent._init;
            try {
              return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
            } catch (x) {
            }
          }
        }
      }
      return "";
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var loggedTypeFailures = {};
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement(element) {
      {
        if (element) {
          var owner = element._owner;
          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack);
        } else {
          ReactDebugCurrentFrame.setExtraStackFrame(null);
        }
      }
    }
    function checkPropTypes(typeSpecs, values, location, componentName, element) {
      {
        var has = Function.call.bind(hasOwnProperty);
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                err.name = "Invariant Violation";
                throw err;
              }
              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ex) {
              error$1 = ex;
            }
            if (error$1 && !(error$1 instanceof Error)) {
              setCurrentlyValidatingElement(element);
              error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
              setCurrentlyValidatingElement(null);
            }
            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
              loggedTypeFailures[error$1.message] = true;
              setCurrentlyValidatingElement(element);
              error("Failed %s type: %s", location, error$1.message);
              setCurrentlyValidatingElement(null);
            }
          }
        }
      }
    }
    var isArrayImpl = Array.isArray;
    function isArray(a) {
      return isArrayImpl(a);
    }
    function typeName(value) {
      {
        var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        return type;
      }
    }
    function willCoercionThrow(value) {
      {
        try {
          testStringCoercion(value);
          return false;
        } catch (e) {
          return true;
        }
      }
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      {
        if (willCoercionThrow(value)) {
          error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
          return testStringCoercion(value);
        }
      }
    }
    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };
    var specialPropKeyWarningShown;
    var specialPropRefWarningShown;
    var didWarnAboutStringRefs;
    {
      didWarnAboutStringRefs = {};
    }
    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, "ref")) {
          var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== void 0;
    }
    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== void 0;
    }
    function warnIfStringRefCannotBeAutoConverted(config, self) {
      {
        if (typeof config.ref === "string" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
          if (!didWarnAboutStringRefs[componentName]) {
            error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
            didWarnAboutStringRefs[componentName] = true;
          }
        }
      }
    }
    function defineKeyPropWarningGetter(props, displayName) {
      {
        var warnAboutAccessingKey = function() {
          if (!specialPropKeyWarningShown) {
            specialPropKeyWarningShown = true;
            error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
          }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
    }
    function defineRefPropWarningGetter(props, displayName) {
      {
        var warnAboutAccessingRef = function() {
          if (!specialPropRefWarningShown) {
            specialPropRefWarningShown = true;
            error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
          }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, "ref", {
          get: warnAboutAccessingRef,
          configurable: true
        });
      }
    }
    var ReactElement = function(type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,
        // Built-in properties that belong on the element
        type,
        key,
        ref,
        props,
        // Record the component responsible for creating this element.
        _owner: owner
      };
      {
        element._store = {};
        Object.defineProperty(element._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        });
        Object.defineProperty(element, "_self", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        });
        Object.defineProperty(element, "_source", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });
        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }
      return element;
    };
    function jsxDEV(type, config, maybeKey, source, self) {
      {
        var propName;
        var props = {};
        var key = null;
        var ref = null;
        if (maybeKey !== void 0) {
          {
            checkKeyStringCoercion(maybeKey);
          }
          key = "" + maybeKey;
        }
        if (hasValidKey(config)) {
          {
            checkKeyStringCoercion(config.key);
          }
          key = "" + config.key;
        }
        if (hasValidRef(config)) {
          ref = config.ref;
          warnIfStringRefCannotBeAutoConverted(config, self);
        }
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;
          for (propName in defaultProps) {
            if (props[propName] === void 0) {
              props[propName] = defaultProps[propName];
            }
          }
        }
        if (key || ref) {
          var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
          if (key) {
            defineKeyPropWarningGetter(props, displayName);
          }
          if (ref) {
            defineRefPropWarningGetter(props, displayName);
          }
        }
        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
      }
    }
    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement$1(element) {
      {
        if (element) {
          var owner = element._owner;
          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else {
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
        }
      }
    }
    var propTypesMisspellWarningShown;
    {
      propTypesMisspellWarningShown = false;
    }
    function isValidElement(object) {
      {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
    }
    function getDeclarationErrorAddendum() {
      {
        if (ReactCurrentOwner$1.current) {
          var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
          if (name) {
            return "\n\nCheck the render method of `" + name + "`.";
          }
        }
        return "";
      }
    }
    function getSourceInfoErrorAddendum(source) {
      {
        if (source !== void 0) {
          var fileName = source.fileName.replace(/^.*[\\\/]/, "");
          var lineNumber = source.lineNumber;
          return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
        }
        return "";
      }
    }
    var ownerHasKeyUseWarning = {};
    function getCurrentComponentErrorInfo(parentType) {
      {
        var info = getDeclarationErrorAddendum();
        if (!info) {
          var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
          if (parentName) {
            info = "\n\nCheck the top-level render call using <" + parentName + ">.";
          }
        }
        return info;
      }
    }
    function validateExplicitKey(element, parentType) {
      {
        if (!element._store || element._store.validated || element.key != null) {
          return;
        }
        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
        var childOwner = "";
        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
          childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
        }
        setCurrentlyValidatingElement$1(element);
        error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
        setCurrentlyValidatingElement$1(null);
      }
    }
    function validateChildKeys(node, parentType) {
      {
        if (typeof node !== "object") {
          return;
        }
        if (isArray(node)) {
          for (var i = 0; i < node.length; i++) {
            var child = node[i];
            if (isValidElement(child)) {
              validateExplicitKey(child, parentType);
            }
          }
        } else if (isValidElement(node)) {
          if (node._store) {
            node._store.validated = true;
          }
        } else if (node) {
          var iteratorFn = getIteratorFn(node);
          if (typeof iteratorFn === "function") {
            if (iteratorFn !== node.entries) {
              var iterator = iteratorFn.call(node);
              var step;
              while (!(step = iterator.next()).done) {
                if (isValidElement(step.value)) {
                  validateExplicitKey(step.value, parentType);
                }
              }
            }
          }
        }
      }
    }
    function validatePropTypes(element) {
      {
        var type = element.type;
        if (type === null || type === void 0 || typeof type === "string") {
          return;
        }
        var propTypes;
        if (typeof type === "function") {
          propTypes = type.propTypes;
        } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        type.$$typeof === REACT_MEMO_TYPE)) {
          propTypes = type.propTypes;
        } else {
          return;
        }
        if (propTypes) {
          var name = getComponentNameFromType(type);
          checkPropTypes(propTypes, element.props, "prop", name, element);
        } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
          propTypesMisspellWarningShown = true;
          var _name = getComponentNameFromType(type);
          error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
        }
        if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
          error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
    }
    function validateFragmentProps(fragment) {
      {
        var keys = Object.keys(fragment.props);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (key !== "children" && key !== "key") {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
            setCurrentlyValidatingElement$1(null);
            break;
          }
        }
        if (fragment.ref !== null) {
          setCurrentlyValidatingElement$1(fragment);
          error("Invalid attribute `ref` supplied to `React.Fragment`.");
          setCurrentlyValidatingElement$1(null);
        }
      }
    }
    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
      {
        var validType = isValidElementType(type);
        if (!validType) {
          var info = "";
          if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          }
          var sourceInfo = getSourceInfoErrorAddendum(source);
          if (sourceInfo) {
            info += sourceInfo;
          } else {
            info += getDeclarationErrorAddendum();
          }
          var typeString;
          if (type === null) {
            typeString = "null";
          } else if (isArray(type)) {
            typeString = "array";
          } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
            typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
            info = " Did you accidentally export a JSX literal instead of a component?";
          } else {
            typeString = typeof type;
          }
          error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
        }
        var element = jsxDEV(type, props, key, source, self);
        if (element == null) {
          return element;
        }
        if (validType) {
          var children = props.children;
          if (children !== void 0) {
            if (isStaticChildren) {
              if (isArray(children)) {
                for (var i = 0; i < children.length; i++) {
                  validateChildKeys(children[i], type);
                }
                if (Object.freeze) {
                  Object.freeze(children);
                }
              } else {
                error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              }
            } else {
              validateChildKeys(children, type);
            }
          }
        }
        if (type === REACT_FRAGMENT_TYPE) {
          validateFragmentProps(element);
        } else {
          validatePropTypes(element);
        }
        return element;
      }
    }
    function jsxWithValidationStatic(type, props, key) {
      {
        return jsxWithValidation(type, props, key, true);
      }
    }
    function jsxWithValidationDynamic(type, props, key) {
      {
        return jsxWithValidation(type, props, key, false);
      }
    }
    var jsx = jsxWithValidationDynamic;
    var jsxs = jsxWithValidationStatic;
    Fragment$1 = reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
    jsx_1 = reactJsxRuntime_development.jsx = jsx;
    jsxs_1 = reactJsxRuntime_development.jsxs = jsxs;
  })();
}

var jsxRuntime = jsxRuntime$2.exports;

"use strict";
if (false) {
  module.exports = require("./cjs/react-jsx-runtime.production.min.js");
} else {
  jsxRuntime$2.exports = reactJsxRuntime_development;
}

var jsxRuntimeExports = jsxRuntime$2.exports;
var jsxRuntime$1 = /*@__PURE__*/getDefaultExportFromCjs(jsxRuntimeExports);

const logLevels = ["trace", "debug", "info", "warn", "error", "critical"], LogNode = { Auth: "Auth", AppCenter: "AppCenter", Client: "Client", OTA: "OTA", SelectiveSync: "SelectiveSync", Nanoflow: "Nanoflow", NanoflowDebugger: "NanoflowDebugger", Database: "Database", FileSystem: "FileSystem", Navigation: "Navigation", Network: "Network", Startup: "Startup", Synchronization: "Synchronization" };
class LogManager {
  constructor() {
    this.logHandlers = [], this.loggers = /* @__PURE__ */ new Map(), this.delayedLogs = [], this.processLog = (level, node, ...args) => {
      this.shouldProcessLog(level, node, ...args) && this.logHandlers.forEach((handler) => handler(level, node, ...args));
    }, this.processLogDebounced = (level, node, ...args) => {
      this.shouldProcessLog(level, node, ...args) && (this.delayTimer && clearTimeout(this.delayTimer), this.delayedLogs.push({ level, node, args }), this.delayTimer = setTimeout(() => {
        this.delayedLogs.forEach((delayedLog) => {
          this.logHandlers.forEach((handler) => handler(delayedLog.level, delayedLog.node, ...delayedLog.args));
        }), this.delayedLogs = [];
      }, 500));
    };
  }
  addHandler(handler) {
    this.logHandlers.push(handler);
  }
  removeHandler(handler) {
    const indexToDelete = this.logHandlers.indexOf(handler);
    -1 !== indexToDelete && this.logHandlers.splice(indexToDelete, 1);
  }
  getLogFilter() {
    return this.filter;
  }
  setLogFilter(logFilter) {
    this.filter = logFilter;
  }
  getLogger(node = LogNode.Client) {
    if (!this.loggers.has(node)) {
      if (!Object.prototype.hasOwnProperty.call(LogNode, node)) {
        const defaultLogger = this.getLogger();
        return defaultLogger.warn(`Invalid log node requested: "${node}". Returning a logger with default node instead.`), defaultLogger;
      }
      const createLogger = (logsProcessor) => Object.assign({}, ...logLevels.map((level) => ({ [level]: (...args) => {
        logsProcessor("warn" === level ? "warning" : level, node, ...args);
      } })), { log: (level, ...args) => {
        logsProcessor(level, node, ...args);
      } }), logger = { ...createLogger(this.processLog), debounced: createLogger(this.processLogDebounced) };
      this.loggers.set(node, logger);
    }
    return this.loggers.get(node);
  }
  shouldProcessLog(level, node, ...args) {
    return void 0 === this.filter || this.filter(level, node, ...args);
  }
  static get() {
    return LogManager.instance || (LogManager.instance = new LogManager()), LogManager.instance;
  }
}
function logUnhandledErrors() {
  if ("function" == typeof window.addEventListener) {
    const defaultLogger = LogManager.get().getLogger();
    window.addEventListener("error", (event) => defaultLogger.error(event.error ?? event.message)), window.addEventListener("unhandledrejection", (event) => defaultLogger.error(event.reason));
  }
}
function registerConsoleLogsListener() {
  LogManager.get().addHandler(function() {
    const originalLog = {};
    return ["debug", "info", "log", "warn", "error"].forEach((clientLevel) => {
      originalLog[clientLevel] = console[clientLevel];
      const runtimeLevel = function(clientLevel2) {
        switch (clientLevel2) {
          case "warn":
            return "warning";
          case "log":
            return "debug";
          default:
            return clientLevel2;
        }
      }(clientLevel);
      console[clientLevel] = (...args) => LogManager.get().getLogger().log(runtimeLevel, ...args);
    }), (runtimeLevel, node, ...args) => {
      const clientLevel = function(runtimeLevel2) {
        switch (runtimeLevel2) {
          case "trace":
            return "debug";
          case "critical":
            return "error";
          case "warning":
            return "warn";
          default:
            return runtimeLevel2;
        }
      }(runtimeLevel);
      if (void 0 === clientLevel)
        return;
      const [firstArg, ...rest] = args, argsToPass = "string" == typeof firstArg ? [`[${node}] ${firstArg}`, ...rest] : [`[${node}]`, ...args];
      originalLog[clientLevel].call(console, ...argsToPass);
    };
  }());
}
const defaultLogFilter = (_level, _node, ...args) => !args.some((a) => "string" == typeof a && a.includes("setstate-in-render"));

var deepEqual = getDefaultExportFromCjs$1(function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && "object" == typeof a && "object" == typeof b) {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys;
    if (Array.isArray(a)) {
      if ((length = a.length) != b.length)
        return false;
      for (i = length; 0 != i--; )
        if (!equal(a[i], b[i]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    if ((length = (keys = Object.keys(a)).length) !== Object.keys(b).length)
      return false;
    for (i = length; 0 != i--; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    for (i = length; 0 != i--; ) {
      var key = keys[i];
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a != a && b != b;
});

let handler;
function setErrorHandler(errorHandler) {
  handler = errorHandler;
}
function handleError(e) {
  handler(e);
}
const LOADING$1 = { status: "loading" };
function loading() {
  return LOADING$1;
}
const UNAVAILABLE$1 = { status: "unavailable" };
function unavailable() {
  return UNAVAILABLE$1;
}
function available(value) {
  return { status: "available", value };
}
function getOrElseL(value, def) {
  return "available" === value.status ? value.value : def;
}
function getOrCrashL(value) {
  return "available" === value.status ? value.value : crash();
}
function mapL(loadable, action2) {
  return flatMapL(loadable, (v) => available(action2(v)));
}
function flatMapL(loadable, action2) {
  return "available" === loadable.status ? action2(loadable.value) : loadable;
}
const mobxComputed = Symbol("mobxComputed");
function fromMxSubscription$(name, store, subscription) {
  let handle;
  const currentCallbacks = [], priority = getSubscriptionPriority(store), atom = createAtom(name, () => {
    handle = subscribe$1({ tag: name, ...subscription, priority, callback: () => new Promise((resolve) => {
      handle ? (currentCallbacks.push(resolve), atom.reportChanged()) : resolve();
    }) });
  }, () => {
    ensure(handle).unsubscribe(), handle = void 0, loadedCallback();
  }), loadedCallback = () => {
    currentCallbacks.splice(0).forEach((c) => c());
  };
  return [asDependable(name, () => atom.reportObserved()), loadedCallback];
}
function fromTimer$(name, time) {
  let handle;
  const atom = createAtom(name, () => {
    handle = setInterval(() => atom.reportChanged(), time);
  }, () => {
    clearInterval(ensure(handle)), handle = void 0;
  });
  return asDependable(name, () => atom.reportObserved());
}
function fromConstant$(value) {
  return asDependable(`Constant value ${value}`, () => value);
}
function fromRequest$(name, factory) {
  const factoryComputation = computed(() => (assertInObservingContext(), factory()), { name });
  let lastRequest, lastRequestResult;
  return fromComputation$(`Handle response of ${lowerCaseFirst(name)}`, () => {
    const thisRequest = factoryComputation.get();
    if ("status" in thisRequest)
      return lastRequest = void 0, lastRequestResult = void 0, thisRequest;
    if (thisRequest === lastRequest)
      return ensure(lastRequestResult).get();
    const loadingState = Array.isArray(thisRequest) ? thisRequest[0] : loading(), requestResult = observable.box(loadingState, { deep: false });
    return (Array.isArray(thisRequest) ? thisRequest[1] : thisRequest).then(action((r) => requestResult.set(r)), action((err) => {
      handleError(err), requestResult.set(unavailable());
    })), lastRequest = thisRequest, lastRequestResult = requestResult, lastRequestResult.get();
  });
}
function fromComputation$(name, getValue) {
  const computation = computed(getValue, { name });
  return asDependable(name, () => computation.get(), computation);
}
function fromComputationWithDeepEquality$(name, getValue) {
  const computation = computed(getValue, { name, equals: deepEqual });
  return asDependable(name, () => computation.get(), computation);
}
function useValue(name, initialValue) {
  const box = observable.box(initialValue, { deep: false, name: `Box for ${name}` });
  return [asDependable(name, () => box.get()), (value) => box.set(value)];
}
function getPreviousValue$(value$) {
  let lastSeenValue;
  return asDependable(`Previous value of ${lowerCaseFirst(value$.name)}`, () => {
    const toReturn = lastSeenValue;
    return lastSeenValue = value$.dependOn(), toReturn;
  });
}
function fromMutableComputation$(name, getValue) {
  const underlyingComputed = computed(getValue, { name });
  return { ...asDependable(name, () => underlyingComputed.get(), underlyingComputed), muted: function(actionToExecute) {
    if (underlyingComputed.dependenciesState !== IDerivationState.UP_TO_DATE)
      actionToExecute();
    else {
      const originalGet = underlyingComputed.get.bind(underlyingComputed);
      underlyingComputed.onBecomeStale = () => {
        underlyingComputed.get = () => {
          underlyingComputed.dependenciesState = IDerivationState.STALE;
          try {
            return originalGet();
          } finally {
            underlyingComputed.dependenciesState = IDerivationState.UP_TO_DATE, delete underlyingComputed.get;
          }
        }, scheduleSideEffect(() => underlyingComputed.observing.forEach((o) => {
          o.get && o.get(), o.lowestObserverState = IDerivationState.UP_TO_DATE;
        }));
      };
      try {
        actionToExecute();
      } finally {
        delete underlyingComputed.onBecomeStale, underlyingComputed.dependenciesState = IDerivationState.UP_TO_DATE;
      }
    }
  } };
}
function withSideEffect$(name, value$, onChange, onBecomeUnused, onBecomeUsed) {
  assertNotInObservingContext();
  const computation = computed(() => value$.dependOn(), { name: `Computation for ${lowerCaseFirst(name)}` });
  let disposer;
  const atom = createAtom(name, () => {
    onBecomeUsed && runInAction(onBecomeUsed), onChange && (disposer = computation.observe(action(({ newValue, oldValue }) => onChange(newValue, oldValue)), true));
  }, () => {
    disposer && disposer(), onBecomeUnused && runInAction(onBecomeUnused);
  });
  return asDependable(name, () => (atom.reportObserved(), computation.get()), computation);
}
function runSideEffect(dependable, onChange, runImmediately = false) {
  const dispose = reaction(() => dependable.dependOn(), (value) => onChange(value, dispose), { fireImmediately: runImmediately });
  return dispose;
}
function dependOnSubscription(subscription, store) {
  assertInObservingContext();
  const currentDerivation = getGlobalState().trackingDerivation;
  if (!currentDerivation)
    throw new AssertionError();
  const subscriptionHandlers = currentDerivation.__subscriptionHandlers ?? (currentDerivation.__subscriptionHandlers = /* @__PURE__ */ new Map()), subscriptionKey = JSON.stringify(subscription);
  let subscriptionHandler = subscriptionHandlers.get(subscriptionKey);
  const priority = getSubscriptionPriority(store);
  if (subscriptionHandler)
    subscriptionHandler.priority !== priority && crash();
  else {
    const box = observable.box(tuple(void 0), { deep: false, name: `Store for validation subscription ${subscriptionKey}` });
    let handle, atom;
    atom = createAtom(subscriptionKey, "val" in subscription ? () => {
      handle = subscribe$1({ ...subscription, priority, callback: (val) => (box.set([val]), new Promise((resolve) => store.addUpdateCallback(resolve))), sync: true });
    } : () => {
      handle = subscribe$1({ ...subscription, priority, callback: () => (box.set([void 0]), new Promise((resolve) => store.addUpdateCallback(resolve))), sync: true });
    }, () => {
      ensure(handle).unsubscribe(), handle = void 0;
    }), subscriptionHandler = { name: subscriptionKey, atom, box, priority }, subscriptionHandlers.set(subscriptionKey, subscriptionHandler);
  }
  return subscriptionHandler.atom.reportObserved(), subscriptionHandler.box.get();
}
function getSubscriptionPriority(store) {
  return store.getSubscriptionPriority();
}
function useDependency(name, onBecomeUnused, onBecomeUsed) {
  const atom = createAtom(name, onBecomeUsed, onBecomeUnused);
  return tuple(asDependable(name, () => {
    atom.reportObserved(), atom.isBeingObserved || (onBecomeUsed?.(), onBecomeUnused?.());
  }), () => atom.reportChanged());
}
function readUntracked(value$) {
  const previousAllowUntracked = allowUntracked;
  allowUntracked = true;
  try {
    const computation = value$[mobxComputed];
    return computation && computation.dependenciesState !== IDerivationState.NOT_TRACKING ? computation.value : untracked(() => value$.dependOn());
  } finally {
    allowUntracked = previousAllowUntracked;
  }
}
function scheduleSideEffect(actionToExecute) {
  new Reaction(`Run side effect ${actionToExecute.name}`, actionToExecute).schedule();
}
function asDependable(name, dependOn, computedValue) {
  return assertNotInObservingContext(), { name, dependOn: () => (assertInObservingContext(), dependOn()), ...computedValue ? { [mobxComputed]: computedValue } : {} };
}
function isDependable(value) {
  return null != value && "object" == typeof value && "dependOn" in value;
}
function assertNotInObservingContext() {
  if (isInObservingContext())
    throw new AssertionError();
}
let allowUntracked = false;
function assertInObservingContext() {
  if (!isInObservingContext() && !allowUntracked)
    throw new AssertionError();
}
function isInObservingContext() {
  return null != getGlobalState().trackingDerivation;
}
function useDependableValue(value$) {
  useEnsureConstantValues(value$);
  const [value, setValue] = reactExports.useState(() => readUntracked(value$));
  return reactExports.useEffect(() => reaction(() => value$.dependOn(), setValue, { name: `Copy '${value$.name}' to state`, fireImmediately: false }), []), value;
}

const randomStr = Array(3).fill(null).map(() => Math.floor(20 * Math.random())).map((num) => "abcdefghijklmnopqrst"[num]).join("");
let counter = 0;
function newId(prefix = "id") {
  return `${prefix}_${randomStr}_${counter++}`;
}

/*
 *  big.js v6.1.1
 *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.
 *  Copyright (c) 2021 Michael Mclaughlin
 *  https://github.com/MikeMcl/big.js/LICENCE.md
 */


/************************************** EDITABLE DEFAULTS *****************************************/


  // The default values below must be integers within the stated ranges.

  /*
   * The maximum number of decimal places (DP) of the results of operations involving division:
   * div and sqrt, and pow with negative exponents.
   */
var DP = 20,          // 0 to MAX_DP

  /*
   * The rounding mode (RM) used when rounding to the above decimal places.
   *
   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)
   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)
   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)
   *  3  Away from zero.                                  (ROUND_UP)
   */
  RM = 1,             // 0, 1, 2 or 3

  // The maximum value of DP and Big.DP.
  MAX_DP = 1E6,       // 0 to 1000000

  // The maximum magnitude of the exponent argument to the pow method.
  MAX_POWER = 1E6,    // 1 to 1000000

  /*
   * The negative exponent (NE) at and beneath which toString returns exponential notation.
   * (JavaScript numbers: -7)
   * -1000000 is the minimum recommended exponent value of a Big.
   */
  NE = -7,            // 0 to -1000000

  /*
   * The positive exponent (PE) at and above which toString returns exponential notation.
   * (JavaScript numbers: 21)
   * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.
   */
  PE = 21,            // 0 to 1000000

  /*
   * When true, an error will be thrown if a primitive number is passed to the Big constructor,
   * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a
   * primitive number without a loss of precision.
   */
  STRICT = false,     // true or false


/**************************************************************************************************/


  // Error messages.
  NAME = '[big.js] ',
  INVALID = NAME + 'Invalid ',
  INVALID_DP = INVALID + 'decimal places',
  INVALID_RM = INVALID + 'rounding mode',
  DIV_BY_ZERO = NAME + 'Division by zero',

  // The shared prototype object.
  P = {},
  UNDEFINED = void 0,
  NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;


/*
 * Create and return a Big constructor.
 */
function _Big_() {

  /*
   * The Big constructor and exported function.
   * Create and return a new instance of a Big number object.
   *
   * n {number|string|Big} A numeric value.
   */
  function Big(n) {
    var x = this;

    // Enable constructor usage without new.
    if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);

    // Duplicate.
    if (n instanceof Big) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      if (typeof n !== 'string') {
        if (Big.strict === true) {
          throw TypeError(INVALID + 'number');
        }

        // Minus zero?
        n = n === 0 && 1 / n < 0 ? '-0' : String(n);
      }

      parse$1(x, n);
    }

    // Retain a reference to this Big constructor.
    // Shadow Big.prototype.constructor which points to Object.
    x.constructor = Big;
  }

  Big.prototype = P;
  Big.DP = DP;
  Big.RM = RM;
  Big.NE = NE;
  Big.PE = PE;
  Big.strict = STRICT;
  Big.roundDown = 0;
  Big.roundHalfUp = 1;
  Big.roundHalfEven = 2;
  Big.roundUp = 3;

  return Big;
}


/*
 * Parse the number or string value passed to a Big constructor.
 *
 * x {Big} A Big number instance.
 * n {number|string} A numeric value.
 */
function parse$1(x, n) {
  var e, i, nl;

  if (!NUMERIC.test(n)) {
    throw Error(INVALID + 'number');
  }

  // Determine sign.
  x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;

  // Decimal point?
  if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');

  // Exponential form?
  if ((i = n.search(/e/i)) > 0) {

    // Determine exponent.
    if (e < 0) e = i;
    e += +n.slice(i + 1);
    n = n.substring(0, i);
  } else if (e < 0) {

    // Integer.
    e = n.length;
  }

  nl = n.length;

  // Determine leading zeros.
  for (i = 0; i < nl && n.charAt(i) == '0';) ++i;

  if (i == nl) {

    // Zero.
    x.c = [x.e = 0];
  } else {

    // Determine trailing zeros.
    for (; nl > 0 && n.charAt(--nl) == '0';);
    x.e = e - i - 1;
    x.c = [];

    // Convert string to array of digits without leading/trailing zeros.
    for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);
  }

  return x;
}


/*
 * Round Big x to a maximum of sd significant digits using rounding mode rm.
 *
 * x {Big} The Big to round.
 * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.
 * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 * [more] {boolean} Whether the result of division was truncated.
 */
function round(x, sd, rm, more) {
  var xc = x.c;

  if (rm === UNDEFINED) rm = x.constructor.RM;
  if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
    throw Error(INVALID_RM);
  }

  if (sd < 1) {
    more =
      rm === 3 && (more || !!xc[0]) || sd === 0 && (
      rm === 1 && xc[0] >= 5 ||
      rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED))
    );

    xc.length = 1;

    if (more) {

      // 1, 0.1, 0.01, 0.001, 0.0001 etc.
      x.e = x.e - sd + 1;
      xc[0] = 1;
    } else {

      // Zero.
      xc[0] = x.e = 0;
    }
  } else if (sd < xc.length) {

    // xc[sd] is the digit after the digit that may be rounded up.
    more =
      rm === 1 && xc[sd] >= 5 ||
      rm === 2 && (xc[sd] > 5 || xc[sd] === 5 &&
        (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) ||
      rm === 3 && (more || !!xc[0]);

    // Remove any digits after the required precision.
    xc.length = sd--;

    // Round up?
    if (more) {

      // Rounding up may mean the previous digit has to be rounded up.
      for (; ++xc[sd] > 9;) {
        xc[sd] = 0;
        if (!sd--) {
          ++x.e;
          xc.unshift(1);
        }
      }
    }

    // Remove trailing zeros.
    for (sd = xc.length; !xc[--sd];) xc.pop();
  }

  return x;
}


/*
 * Return a string representing the value of Big x in normal or exponential notation.
 * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
 */
function stringify(x, doExponential, isNonzero) {
  var e = x.e,
    s = x.c.join(''),
    n = s.length;

  // Exponential notation?
  if (doExponential) {
    s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;

  // Normal notation.
  } else if (e < 0) {
    for (; ++e;) s = '0' + s;
    s = '0.' + s;
  } else if (e > 0) {
    if (++e > n) {
      for (e -= n; e--;) s += '0';
    } else if (e < n) {
      s = s.slice(0, e) + '.' + s.slice(e);
    }
  } else if (n > 1) {
    s = s.charAt(0) + '.' + s.slice(1);
  }

  return x.s < 0 && isNonzero ? '-' + s : s;
}


// Prototype/instance methods


/*
 * Return a new Big whose value is the absolute value of this Big.
 */
P.abs = function () {
  var x = new this.constructor(this);
  x.s = 1;
  return x;
};


/*
 * Return 1 if the value of this Big is greater than the value of Big y,
 *       -1 if the value of this Big is less than the value of Big y, or
 *        0 if they have the same value.
 */
P.cmp = function (y) {
  var isneg,
    x = this,
    xc = x.c,
    yc = (y = new x.constructor(y)).c,
    i = x.s,
    j = y.s,
    k = x.e,
    l = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;

  // Signs differ?
  if (i != j) return i;

  isneg = i < 0;

  // Compare exponents.
  if (k != l) return k > l ^ isneg ? 1 : -1;

  j = (k = xc.length) < (l = yc.length) ? k : l;

  // Compare digit by digit.
  for (i = -1; ++i < j;) {
    if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
  }

  // Compare lengths.
  return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};


/*
 * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
 * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.div = function (y) {
  var x = this,
    Big = x.constructor,
    a = x.c,                  // dividend
    b = (y = new Big(y)).c,   // divisor
    k = x.s == y.s ? 1 : -1,
    dp = Big.DP;

  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }

  // Divisor is zero?
  if (!b[0]) {
    throw Error(DIV_BY_ZERO);
  }

  // Dividend is 0? Return +-0.
  if (!a[0]) {
    y.s = k;
    y.c = [y.e = 0];
    return y;
  }

  var bl, bt, n, cmp, ri,
    bz = b.slice(),
    ai = bl = b.length,
    al = a.length,
    r = a.slice(0, bl),   // remainder
    rl = r.length,
    q = y,                // quotient
    qc = q.c = [],
    qi = 0,
    p = dp + (q.e = x.e - y.e) + 1;    // precision of the result

  q.s = k;
  k = p < 0 ? 0 : p;

  // Create version of divisor with leading zero.
  bz.unshift(0);

  // Add zeros to make remainder as long as divisor.
  for (; rl++ < bl;) r.push(0);

  do {

    // n is how many times the divisor goes into current remainder.
    for (n = 0; n < 10; n++) {

      // Compare divisor and remainder.
      if (bl != (rl = r.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri = -1, cmp = 0; ++ri < bl;) {
          if (b[ri] != r[ri]) {
            cmp = b[ri] > r[ri] ? 1 : -1;
            break;
          }
        }
      }

      // If divisor < remainder, subtract divisor from remainder.
      if (cmp < 0) {

        // Remainder can't be more than 1 digit longer than divisor.
        // Equalise lengths using divisor with extra leading zero?
        for (bt = rl == bl ? b : bz; rl;) {
          if (r[--rl] < bt[rl]) {
            ri = rl;
            for (; ri && !r[--ri];) r[ri] = 9;
            --r[ri];
            r[rl] += 10;
          }
          r[rl] -= bt[rl];
        }

        for (; !r[0];) r.shift();
      } else {
        break;
      }
    }

    // Add the digit n to the result array.
    qc[qi++] = cmp ? n : ++n;

    // Update the remainder.
    if (r[0] && cmp) r[rl] = a[ai] || 0;
    else r = [a[ai]];

  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);

  // Leading zero? Do not remove if result is simply zero (qi == 1).
  if (!qc[0] && qi != 1) {

    // There can't be more than one zero.
    qc.shift();
    q.e--;
    p--;
  }

  // Round?
  if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);

  return q;
};


/*
 * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
 */
P.eq = function (y) {
  return this.cmp(y) === 0;
};


/*
 * Return true if the value of this Big is greater than the value of Big y, otherwise return
 * false.
 */
P.gt = function (y) {
  return this.cmp(y) > 0;
};


/*
 * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
 * return false.
 */
P.gte = function (y) {
  return this.cmp(y) > -1;
};


/*
 * Return true if the value of this Big is less than the value of Big y, otherwise return false.
 */
P.lt = function (y) {
  return this.cmp(y) < 0;
};


/*
 * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
 * return false.
 */
P.lte = function (y) {
  return this.cmp(y) < 1;
};


/*
 * Return a new Big whose value is the value of this Big minus the value of Big y.
 */
P.minus = P.sub = function (y) {
  var i, j, t, xlty,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  // Signs differ?
  if (a != b) {
    y.s = -b;
    return x.plus(y);
  }

  var xc = x.c.slice(),
    xe = x.e,
    yc = y.c,
    ye = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) {
    if (yc[0]) {
      y.s = -b;
    } else if (xc[0]) {
      y = new Big(x);
    } else {
      y.s = 1;
    }
    return y;
  }

  // Determine which is the bigger number. Prepend zeros to equalise exponents.
  if (a = xe - ye) {

    if (xlty = a < 0) {
      a = -a;
      t = xc;
    } else {
      ye = xe;
      t = yc;
    }

    t.reverse();
    for (b = a; b--;) t.push(0);
    t.reverse();
  } else {

    // Exponents equal. Check digit by digit.
    j = ((xlty = xc.length < yc.length) ? xc : yc).length;

    for (a = b = 0; b < j; b++) {
      if (xc[b] != yc[b]) {
        xlty = xc[b] < yc[b];
        break;
      }
    }
  }

  // x < y? Point xc to the array of the bigger number.
  if (xlty) {
    t = xc;
    xc = yc;
    yc = t;
    y.s = -y.s;
  }

  /*
   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
   * needs to start at yc.length.
   */
  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;

  // Subtract yc from xc.
  for (b = i; j > a;) {
    if (xc[--j] < yc[j]) {
      for (i = j; i && !xc[--i];) xc[i] = 9;
      --xc[i];
      xc[j] += 10;
    }

    xc[j] -= yc[j];
  }

  // Remove trailing zeros.
  for (; xc[--b] === 0;) xc.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xc[0] === 0;) {
    xc.shift();
    --ye;
  }

  if (!xc[0]) {

    // n - n = +0
    y.s = 1;

    // Result must be zero.
    xc = [ye = 0];
  }

  y.c = xc;
  y.e = ye;

  return y;
};


/*
 * Return a new Big whose value is the value of this Big modulo the value of Big y.
 */
P.mod = function (y) {
  var ygtx,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  if (!y.c[0]) {
    throw Error(DIV_BY_ZERO);
  }

  x.s = y.s = 1;
  ygtx = y.cmp(x) == 1;
  x.s = a;
  y.s = b;

  if (ygtx) return new Big(x);

  a = Big.DP;
  b = Big.RM;
  Big.DP = Big.RM = 0;
  x = x.div(y);
  Big.DP = a;
  Big.RM = b;

  return this.minus(x.times(y));
};


/*
 * Return a new Big whose value is the value of this Big plus the value of Big y.
 */
P.plus = P.add = function (y) {
  var e, k, t,
    x = this,
    Big = x.constructor;

  y = new Big(y);

  // Signs differ?
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }

  var xe = x.e,
    xc = x.c,
    ye = y.e,
    yc = y.c;

  // Either zero?
  if (!xc[0] || !yc[0]) {
    if (!yc[0]) {
      if (xc[0]) {
        y = new Big(x);
      } else {
        y.s = x.s;
      }
    }
    return y;
  }

  xc = xc.slice();

  // Prepend zeros to equalise exponents.
  // Note: reverse faster than unshifts.
  if (e = xe - ye) {
    if (e > 0) {
      ye = xe;
      t = yc;
    } else {
      e = -e;
      t = xc;
    }

    t.reverse();
    for (; e--;) t.push(0);
    t.reverse();
  }

  // Point xc to the longer array.
  if (xc.length - yc.length < 0) {
    t = yc;
    yc = xc;
    xc = t;
  }

  e = yc.length;

  // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
  for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;

  // No need to check for zero, as +x + +y != 0 && -x + -y != 0

  if (k) {
    xc.unshift(k);
    ++ye;
  }

  // Remove trailing zeros.
  for (e = xc.length; xc[--e] === 0;) xc.pop();

  y.c = xc;
  y.e = ye;

  return y;
};


/*
 * Return a Big whose value is the value of this Big raised to the power n.
 * If n is negative, round to a maximum of Big.DP decimal places using rounding
 * mode Big.RM.
 *
 * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
 */
P.pow = function (n) {
  var x = this,
    one = new x.constructor('1'),
    y = one,
    isneg = n < 0;

  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {
    throw Error(INVALID + 'exponent');
  }

  if (isneg) n = -n;

  for (;;) {
    if (n & 1) y = y.times(x);
    n >>= 1;
    if (!n) break;
    x = x.times(x);
  }

  return isneg ? one.div(y) : y;
};


/*
 * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd
 * significant digits using rounding mode rm, or Big.RM if rm is not specified.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.prec = function (sd, rm) {
  if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
    throw Error(INVALID + 'precision');
  }
  return round(new this.constructor(this), sd, rm);
};


/*
 * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places
 * using rounding mode rm, or Big.RM if rm is not specified.
 * If dp is negative, round to an integer which is a multiple of 10**-dp.
 * If dp is not specified, round to 0 decimal places.
 *
 * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.round = function (dp, rm) {
  if (dp === UNDEFINED) dp = 0;
  else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }
  return round(new this.constructor(this), dp + this.e + 1, rm);
};


/*
 * Return a new Big whose value is the square root of the value of this Big, rounded, if
 * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.sqrt = function () {
  var r, c, t,
    x = this,
    Big = x.constructor,
    s = x.s,
    e = x.e,
    half = new Big('0.5');

  // Zero?
  if (!x.c[0]) return new Big(x);

  // Negative?
  if (s < 0) {
    throw Error(NAME + 'No square root');
  }

  // Estimate.
  s = Math.sqrt(x + '');

  // Math.sqrt underflow/overflow?
  // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
  if (s === 0 || s === 1 / 0) {
    c = x.c.join('');
    if (!(c.length + e & 1)) c += '0';
    s = Math.sqrt(c);
    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
    r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);
  } else {
    r = new Big(s + '');
  }

  e = r.e + (Big.DP += 4);

  // Newton-Raphson iteration.
  do {
    t = r;
    r = half.times(t.plus(x.div(t)));
  } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));

  return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);
};


/*
 * Return a new Big whose value is the value of this Big times the value of Big y.
 */
P.times = P.mul = function (y) {
  var c,
    x = this,
    Big = x.constructor,
    xc = x.c,
    yc = (y = new Big(y)).c,
    a = xc.length,
    b = yc.length,
    i = x.e,
    j = y.e;

  // Determine sign of result.
  y.s = x.s == y.s ? 1 : -1;

  // Return signed 0 if either 0.
  if (!xc[0] || !yc[0]) {
    y.c = [y.e = 0];
    return y;
  }

  // Initialise exponent of result as x.e + y.e.
  y.e = i + j;

  // If array xc has fewer digits than yc, swap xc and yc, and lengths.
  if (a < b) {
    c = xc;
    xc = yc;
    yc = c;
    j = a;
    a = b;
    b = j;
  }

  // Initialise coefficient array of result with zeros.
  for (c = new Array(j = a + b); j--;) c[j] = 0;

  // Multiply.

  // i is initially xc.length.
  for (i = b; i--;) {
    b = 0;

    // a is yc.length.
    for (j = a + i; j > i;) {

      // Current sum of products at this digit position, plus carry.
      b = c[j] + yc[i] * xc[j - i - 1] + b;
      c[j--] = b % 10;

      // carry
      b = b / 10 | 0;
    }

    c[j] = b;
  }

  // Increment result exponent if there is a final carry, otherwise remove leading zero.
  if (b) ++y.e;
  else c.shift();

  // Remove trailing zeros.
  for (i = c.length; !c[--i];) c.pop();
  y.c = c;

  return y;
};


/*
 * Return a string representing the value of this Big in exponential notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.toExponential = function (dp, rm) {
  var x = this,
    n = x.c[0];

  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), ++dp, rm);
    for (; x.c.length < dp;) x.c.push(0);
  }

  return stringify(x, true, !!n);
};


/*
 * Return a string representing the value of this Big in normal notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 */
P.toFixed = function (dp, rm) {
  var x = this,
    n = x.c[0];

  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), dp + x.e + 1, rm);

    // x.e may have changed if the value is rounded up.
    for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);
  }

  return stringify(x, false, !!n);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Omit the sign for negative zero.
 */
P.toJSON = P.toString = function () {
  var x = this,
    Big = x.constructor;
  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);
};


/*
 * Return the value of this Big as a primitve number.
 */
P.toNumber = function () {
  var n = Number(stringify(this, true, true));
  if (this.constructor.strict === true && !this.eq(n.toString())) {
    throw Error(NAME + 'Imprecise conversion');
  }
  return n;
};


/*
 * Return a string representing the value of this Big rounded to sd significant digits using
 * rounding mode rm, or Big.RM if rm is not specified.
 * Use exponential notation if sd is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.toPrecision = function (sd, rm) {
  var x = this,
    Big = x.constructor,
    n = x.c[0];

  if (sd !== UNDEFINED) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID + 'precision');
    }
    x = round(new Big(x), sd, rm);
    for (; x.c.length < sd;) x.c.push(0);
  }

  return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Include the sign for negative zero.
 */
P.valueOf = function () {
  var x = this,
    Big = x.constructor;
  if (Big.strict === true) {
    throw Error(NAME + 'valueOf disallowed');
  }
  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);
};


// Export


var Big = _Big_();

function buildLocalizeFn(args2) {
  return function(dirtyIndex, options) {
    var valuesArray;
    if ("formatting" === (null != options && options.context ? String(options.context) : "standalone") && args2.formattingValues) {
      var defaultWidth = args2.defaultFormattingWidth || args2.defaultWidth, width = null != options && options.width ? String(options.width) : defaultWidth;
      valuesArray = args2.formattingValues[width] || args2.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args2.defaultWidth, _width = null != options && options.width ? String(options.width) : args2.defaultWidth;
      valuesArray = args2.values[_width] || args2.values[_defaultWidth];
    }
    return valuesArray[args2.argumentCallback ? args2.argumentCallback(dirtyIndex) : dirtyIndex];
  };
}
function buildMatchFn(args2) {
  return function(string) {
    var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, width = options.width, matchPattern2 = width && args2.matchPatterns[width] || args2.matchPatterns[args2.defaultMatchWidth], matchResult = string.match(matchPattern2);
    if (!matchResult)
      return null;
    var value, matchedString = matchResult[0], parsePatterns2 = width && args2.parsePatterns[width] || args2.parsePatterns[args2.defaultParseWidth], key = Array.isArray(parsePatterns2) ? function(array, predicate) {
      for (var key2 = 0; key2 < array.length; key2++)
        if (predicate(array[key2]))
          return key2;
      return;
    }(parsePatterns2, function(pattern) {
      return pattern.test(matchedString);
    }) : function(object, predicate) {
      for (var key2 in object)
        if (object.hasOwnProperty(key2) && predicate(object[key2]))
          return key2;
      return;
    }(parsePatterns2, function(pattern) {
      return pattern.test(matchedString);
    });
    return value = args2.valueCallback ? args2.valueCallback(key) : key, { value: value = options.valueCallback ? options.valueCallback(value) : value, rest: string.slice(matchedString.length) };
  };
}
function buildFormatLongFn(args2) {
  return function() {
    var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, width = options.width ? String(options.width) : args2.defaultWidth;
    return args2.formats[width] || args2.formats[args2.defaultWidth];
  };
}
var args, formatDistanceLocale = { lessThanXSeconds: { one: "less than a second", other: "less than {{count}} seconds" }, xSeconds: { one: "1 second", other: "{{count}} seconds" }, halfAMinute: "half a minute", lessThanXMinutes: { one: "less than a minute", other: "less than {{count}} minutes" }, xMinutes: { one: "1 minute", other: "{{count}} minutes" }, aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" }, xHours: { one: "1 hour", other: "{{count}} hours" }, xDays: { one: "1 day", other: "{{count}} days" }, aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" }, xWeeks: { one: "1 week", other: "{{count}} weeks" }, aboutXMonths: { one: "about 1 month", other: "about {{count}} months" }, xMonths: { one: "1 month", other: "{{count}} months" }, aboutXYears: { one: "about 1 year", other: "about {{count}} years" }, xYears: { one: "1 year", other: "{{count}} years" }, overXYears: { one: "over 1 year", other: "over {{count}} years" }, almostXYears: { one: "almost 1 year", other: "almost {{count}} years" } }, formatLong = { date: buildFormatLongFn({ formats: { full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy" }, defaultWidth: "full" }), time: buildFormatLongFn({ formats: { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" }, defaultWidth: "full" }), dateTime: buildFormatLongFn({ formats: { full: "{{date}} 'at' {{time}}", long: "{{date}} 'at' {{time}}", medium: "{{date}}, {{time}}", short: "{{date}}, {{time}}" }, defaultWidth: "full" }) }, formatRelativeLocale = { lastWeek: "'last' eeee 'at' p", yesterday: "'yesterday at' p", today: "'today at' p", tomorrow: "'tomorrow at' p", nextWeek: "eeee 'at' p", other: "P" }, locale = { code: "en-US", formatDistance: function(token, count, options) {
  var result, tokenValue = formatDistanceLocale[token];
  return result = "string" == typeof tokenValue ? tokenValue : 1 === count ? tokenValue.one : tokenValue.other.replace("{{count}}", count.toString()), null != options && options.addSuffix ? options.comparison && options.comparison > 0 ? "in " + result : result + " ago" : result;
}, formatLong, formatRelative: function(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
}, localize: { ordinalNumber: function(dirtyNumber, _options) {
  var number = Number(dirtyNumber), rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10)
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  return number + "th";
}, era: buildLocalizeFn({ values: { narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"] }, defaultWidth: "wide" }), quarter: buildLocalizeFn({ values: { narrow: ["1", "2", "3", "4"], abbreviated: ["Q1", "Q2", "Q3", "Q4"], wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"] }, defaultWidth: "wide", argumentCallback: function(quarter) {
  return quarter - 1;
} }), month: buildLocalizeFn({ values: { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, defaultWidth: "wide" }), day: buildLocalizeFn({ values: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, defaultWidth: "wide" }), dayPeriod: buildLocalizeFn({ values: { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" } }, defaultWidth: "wide", formattingValues: { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" } }, defaultFormattingWidth: "wide" }) }, match: { ordinalNumber: (args = { matchPattern: /^(\d+)(th|st|nd|rd)?/i, parsePattern: /\d+/i, valueCallback: function(value) {
  return parseInt(value, 10);
} }, function(string) {
  var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, matchResult = string.match(args.matchPattern);
  if (!matchResult)
    return null;
  var matchedString = matchResult[0], parseResult = string.match(args.parsePattern);
  if (!parseResult)
    return null;
  var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
  return { value: value = options.valueCallback ? options.valueCallback(value) : value, rest: string.slice(matchedString.length) };
}), era: buildMatchFn({ matchPatterns: { narrow: /^(b|a)/i, abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i, wide: /^(before christ|before common era|anno domini|common era)/i }, defaultMatchWidth: "wide", parsePatterns: { any: [/^b/i, /^(a|c)/i] }, defaultParseWidth: "any" }), quarter: buildMatchFn({ matchPatterns: { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i }, defaultMatchWidth: "wide", parsePatterns: { any: [/1/i, /2/i, /3/i, /4/i] }, defaultParseWidth: "any", valueCallback: function(index) {
  return index + 1;
} }), month: buildMatchFn({ matchPatterns: { narrow: /^[jfmasond]/i, abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i, wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i }, defaultMatchWidth: "wide", parsePatterns: { narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i], any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i] }, defaultParseWidth: "any" }), day: buildMatchFn({ matchPatterns: { narrow: /^[smtwf]/i, short: /^(su|mo|tu|we|th|fr|sa)/i, abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i, wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i }, defaultMatchWidth: "wide", parsePatterns: { narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i], any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] }, defaultParseWidth: "any" }), dayPeriod: buildMatchFn({ matchPatterns: { narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i, any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i }, defaultMatchWidth: "any", parsePatterns: { any: { am: /^a/i, pm: /^p/i, midnight: /^mi/i, noon: /^no/i, morning: /morning/i, afternoon: /afternoon/i, evening: /evening/i, night: /night/i } }, defaultParseWidth: "any" }) }, options: { weekStartsOn: 0, firstWeekContainsDate: 1 } };
function matchPattern(values) {
  return new RegExp(`^(${values.map(escape$1).join("|")})`, "i");
}
function parsePatterns(values) {
  return values.map((value) => new RegExp(`^${escape$1(value)}`, "i"));
}
function escape$1(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
let localeConfig, dateFnsLocale;
function startupLocalization(config, roundingMode) {
  const code = config.code.toLowerCase().replace("_", "-");
  localeConfig = { ...config, code }, dateFnsLocale = function({ dates, firstDayOfWeek, minimalDaysInFirstWeek }) {
    const eraValues = { wide: dates.eras }, monthValues = { narrow: dates.shortMonths, abbreviated: dates.shortMonths, wide: dates.months }, dayValues = { narrow: dates.shortWeekdays, short: dates.shortWeekdays, abbreviated: dates.shortWeekdays, wide: dates.weekdays }, dayPeriodValues = { wide: { am: dates.dayPeriods[0], pm: dates.dayPeriods[1] } }, matchEraPatterns = { any: matchPattern(dates.eras) }, parseEraPatterns = { any: parsePatterns(dates.eras) }, matchMonthPatterns = { narrow: matchPattern(dates.shortMonths), abbreviated: matchPattern(dates.shortMonths), wide: matchPattern(dates.months) }, parseMonthPatterns = { narrow: parsePatterns(dates.shortMonths), abbreviated: parsePatterns(dates.shortMonths), wide: parsePatterns(dates.months) }, matchDayPatterns = { narrow: matchPattern(dates.shortWeekdays), short: matchPattern(dates.shortWeekdays), abbreviated: matchPattern(dates.shortWeekdays), wide: matchPattern(dates.weekdays) }, parseDayPatterns = { narrow: parsePatterns(dates.shortWeekdays), short: parsePatterns(dates.shortWeekdays), abbreviated: parsePatterns(dates.shortWeekdays), wide: parsePatterns(dates.weekdays) }, matchDayPeriodPatterns = { any: matchPattern(dates.dayPeriods) }, parseDayPeriodPatterns = { any: { am: ensure(parsePatterns(dates.dayPeriods)[0]), pm: ensure(parsePatterns(dates.dayPeriods)[1]) } };
    return { ...locale, options: { weekStartsOn: firstDayOfWeek, firstWeekContainsDate: minimalDaysInFirstWeek }, localize: { ...locale.localize, era: buildLocalizeFn({ values: eraValues, defaultWidth: "wide" }), month: buildLocalizeFn({ values: monthValues, defaultWidth: "wide" }), day: buildLocalizeFn({ values: dayValues, defaultWidth: "wide" }), dayPeriod: buildLocalizeFn({ values: dayPeriodValues, defaultWidth: "wide" }) }, match: { ...locale.match, era: buildMatchFn({ matchPatterns: matchEraPatterns, defaultMatchWidth: "any", parsePatterns: parseEraPatterns, defaultParseWidth: "any" }), month: buildMatchFn({ matchPatterns: matchMonthPatterns, defaultMatchWidth: "wide", parsePatterns: parseMonthPatterns, defaultParseWidth: "wide" }), day: buildMatchFn({ matchPatterns: matchDayPatterns, defaultMatchWidth: "wide", parsePatterns: parseDayPatterns, defaultParseWidth: "wide" }), dayPeriod: buildMatchFn({ matchPatterns: matchDayPeriodPatterns, defaultMatchWidth: "any", parsePatterns: parseDayPeriodPatterns, defaultParseWidth: "any" }) } };
  }(localeConfig), Big.RM = "HALF_UP" === roundingMode ? Big.roundHalfUp : Big.roundHalfEven;
}
function getLocale() {
  if (!localeConfig)
    throw new Error("Locale not initialized");
  return localeConfig;
}
function getDateFnsLocale() {
  if (!dateFnsLocale)
    throw new Error("DateFns locale not initialized");
  return dateFnsLocale;
}

let languageIndex = 0, translations = {};
function selectTranslation(translationTexts) {
  return translationTexts[languageIndex];
}
function updateActiveLanguageIndex(languageCodes, activeLanguageCode) {
  const activeLanguageIndex = languageCodes.indexOf(activeLanguageCode);
  languageIndex = activeLanguageIndex > -1 ? activeLanguageIndex : 0;
}
function setSystemTexts(systemTexts) {
  translations = systemTexts;
}
function translate(namespace, messageKey, ...args) {
  const translation = translations[`${namespace}.${messageKey}`];
  if (!translation)
    return "[No translation]";
  return ensure(selectTranslation(translation)).replace(/\{(\d+)\}/g, (match, n) => args[n - 1] ?? match);
}
function translateLoginMessage(messageKey) {
  let message = translate("mendix.signin", messageKey);
  return "[No translation]" === message && window.i18nMap && (message = window.i18nMap[messageKey]), message;
}

var queryString$1 = {}, strictUriEncode = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`), singleMatcher = new RegExp("(%[a-f0-9]{2})|([^%]+?)", "gi"), multiMatcher = new RegExp("(%[a-f0-9]{2})+", "gi");
function decodeComponents(components, split) {
  try {
    return [decodeURIComponent(components.join(""))];
  } catch (err) {
  }
  if (1 === components.length)
    return components;
  split = split || 1;
  var left = components.slice(0, split), right = components.slice(split);
  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode(input) {
  try {
    return decodeURIComponent(input);
  } catch (err) {
    for (var tokens = input.match(singleMatcher) || [], i = 1; i < tokens.length; i++)
      tokens = (input = decodeComponents(tokens, i).join("")).match(singleMatcher) || [];
    return input;
  }
}
var decodeUriComponent = function(encodedURI) {
  if ("string" != typeof encodedURI)
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  try {
    return encodedURI = encodedURI.replace(/\+/g, " "), decodeURIComponent(encodedURI);
  } catch (err) {
    return function(input) {
      for (var replaceMap = { "%FE%FF": "\uFFFD\uFFFD", "%FF%FE": "\uFFFD\uFFFD" }, match = multiMatcher.exec(input); match; ) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err2) {
          var result = decode(match[0]);
          result !== match[0] && (replaceMap[match[0]] = result);
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      for (var entries = Object.keys(replaceMap), i = 0; i < entries.length; i++) {
        var key = entries[i];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }(encodedURI);
  }
}, splitOnFirst = (string, separator) => {
  if ("string" != typeof string || "string" != typeof separator)
    throw new TypeError("Expected the arguments to be of type `string`");
  if ("" === separator)
    return [string];
  const separatorIndex = string.indexOf(separator);
  return -1 === separatorIndex ? [string] : [string.slice(0, separatorIndex), string.slice(separatorIndex + separator.length)];
}, filterObj = function(obj, predicate) {
  for (var ret = {}, keys = Object.keys(obj), isArr = Array.isArray(predicate), i = 0; i < keys.length; i++) {
    var key = keys[i], val = obj[key];
    (isArr ? -1 !== predicate.indexOf(key) : predicate(key, val, obj)) && (ret[key] = val);
  }
  return ret;
};
!function(exports) {
  const strictUriEncode$1 = strictUriEncode, decodeComponent = decodeUriComponent, splitOnFirst$1 = splitOnFirst, filterObject = filterObj, encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
  function validateArrayFormatSeparator(value) {
    if ("string" != typeof value || 1 !== value.length)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function encode(value, options) {
    return options.encode ? options.strict ? strictUriEncode$1(value) : encodeURIComponent(value) : value;
  }
  function decode2(value, options) {
    return options.decode ? decodeComponent(value) : value;
  }
  function keysSorter(input) {
    return Array.isArray(input) ? input.sort() : "object" == typeof input ? keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]) : input;
  }
  function removeHash(input) {
    const hashStart = input.indexOf("#");
    return -1 !== hashStart && (input = input.slice(0, hashStart)), input;
  }
  function extract(input) {
    const queryStart = (input = removeHash(input)).indexOf("?");
    return -1 === queryStart ? "" : input.slice(queryStart + 1);
  }
  function parseValue(value, options) {
    return options.parseNumbers && !Number.isNaN(Number(value)) && "string" == typeof value && "" !== value.trim() ? value = Number(value) : !options.parseBooleans || null === value || "true" !== value.toLowerCase() && "false" !== value.toLowerCase() || (value = "true" === value.toLowerCase()), value;
  }
  function parse(query, options) {
    validateArrayFormatSeparator((options = Object.assign({ decode: true, sort: true, arrayFormat: "none", arrayFormatSeparator: ",", parseNumbers: false, parseBooleans: false }, options)).arrayFormatSeparator);
    const formatter = function(options2) {
      let result;
      switch (options2.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key), key = key.replace(/\[\d*\]$/, ""), result ? (void 0 === accumulator[key] && (accumulator[key] = {}), accumulator[key][result[1]] = value) : accumulator[key] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key), key = key.replace(/\[\]$/, ""), result ? void 0 !== accumulator[key] ? accumulator[key] = [].concat(accumulator[key], value) : accumulator[key] = [value] : accumulator[key] = value;
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key), key = key.replace(/:list$/, ""), result ? void 0 !== accumulator[key] ? accumulator[key] = [].concat(accumulator[key], value) : accumulator[key] = [value] : accumulator[key] = value;
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = "string" == typeof value && value.includes(options2.arrayFormatSeparator), isEncodedArray = "string" == typeof value && !isArray && decode2(value, options2).includes(options2.arrayFormatSeparator);
            value = isEncodedArray ? decode2(value, options2) : value;
            const newValue = isArray || isEncodedArray ? value.split(options2.arrayFormatSeparator).map((item) => decode2(item, options2)) : null === value ? value : decode2(value, options2);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray = /(\[\])$/.test(key);
            if (key = key.replace(/\[\]$/, ""), !isArray)
              return void (accumulator[key] = value ? decode2(value, options2) : value);
            const arrayValue = null === value ? [] : value.split(options2.arrayFormatSeparator).map((item) => decode2(item, options2));
            void 0 !== accumulator[key] ? accumulator[key] = [].concat(accumulator[key], arrayValue) : accumulator[key] = arrayValue;
          };
        default:
          return (key, value, accumulator) => {
            void 0 !== accumulator[key] ? accumulator[key] = [].concat(accumulator[key], value) : accumulator[key] = value;
          };
      }
    }(options), ret = /* @__PURE__ */ Object.create(null);
    if ("string" != typeof query)
      return ret;
    if (!(query = query.trim().replace(/^[?#&]/, "")))
      return ret;
    for (const param of query.split("&")) {
      if ("" === param)
        continue;
      let [key, value] = splitOnFirst$1(options.decode ? param.replace(/\+/g, " ") : param, "=");
      value = void 0 === value ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode2(value, options), formatter(decode2(key, options), value, ret);
    }
    for (const key of Object.keys(ret)) {
      const value = ret[key];
      if ("object" == typeof value && null !== value)
        for (const k of Object.keys(value))
          value[k] = parseValue(value[k], options);
      else
        ret[key] = parseValue(value, options);
    }
    return false === options.sort ? ret : (true === options.sort ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
      const value = ret[key];
      return Boolean(value) && "object" == typeof value && !Array.isArray(value) ? result[key] = keysSorter(value) : result[key] = value, result;
    }, /* @__PURE__ */ Object.create(null));
  }
  exports.extract = extract, exports.parse = parse, exports.stringify = (object, options) => {
    if (!object)
      return "";
    validateArrayFormatSeparator((options = Object.assign({ encode: true, strict: true, arrayFormat: "none", arrayFormatSeparator: "," }, options)).arrayFormatSeparator);
    const shouldFilter = (key) => options.skipNull && null == object[key] || options.skipEmptyString && "" === object[key], formatter = function(options2) {
      switch (options2.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            return void 0 === value || options2.skipNull && null === value || options2.skipEmptyString && "" === value ? result : null === value ? [...result, [encode(key, options2), "[", index, "]"].join("")] : [...result, [encode(key, options2), "[", encode(index, options2), "]=", encode(value, options2)].join("")];
          };
        case "bracket":
          return (key) => (result, value) => void 0 === value || options2.skipNull && null === value || options2.skipEmptyString && "" === value ? result : null === value ? [...result, [encode(key, options2), "[]"].join("")] : [...result, [encode(key, options2), "[]=", encode(value, options2)].join("")];
        case "colon-list-separator":
          return (key) => (result, value) => void 0 === value || options2.skipNull && null === value || options2.skipEmptyString && "" === value ? result : null === value ? [...result, [encode(key, options2), ":list="].join("")] : [...result, [encode(key, options2), ":list=", encode(value, options2)].join("")];
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = "bracket-separator" === options2.arrayFormat ? "[]=" : "=";
          return (key) => (result, value) => void 0 === value || options2.skipNull && null === value || options2.skipEmptyString && "" === value ? result : (value = null === value ? "" : value, 0 === result.length ? [[encode(key, options2), keyValueSep, encode(value, options2)].join("")] : [[result, encode(value, options2)].join(options2.arrayFormatSeparator)]);
        }
        default:
          return (key) => (result, value) => void 0 === value || options2.skipNull && null === value || options2.skipEmptyString && "" === value ? result : null === value ? [...result, encode(key, options2)] : [...result, [encode(key, options2), "=", encode(value, options2)].join("")];
      }
    }(options), objectCopy = {};
    for (const key of Object.keys(object))
      shouldFilter(key) || (objectCopy[key] = object[key]);
    const keys = Object.keys(objectCopy);
    return false !== options.sort && keys.sort(options.sort), keys.map((key) => {
      const value = object[key];
      return void 0 === value ? "" : null === value ? encode(key, options) : Array.isArray(value) ? 0 === value.length && "bracket-separator" === options.arrayFormat ? encode(key, options) + "[]" : value.reduce(formatter(key), []).join("&") : encode(key, options) + "=" + encode(value, options);
    }).filter((x) => x.length > 0).join("&");
  }, exports.parseUrl = (url, options) => {
    options = Object.assign({ decode: true }, options);
    const [url_, hash] = splitOnFirst$1(url, "#");
    return Object.assign({ url: url_.split("?")[0] || "", query: parse(extract(url), options) }, options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode2(hash, options) } : {});
  }, exports.stringifyUrl = (object, options) => {
    options = Object.assign({ encode: true, strict: true, [encodeFragmentIdentifier]: true }, options);
    const url = removeHash(object.url).split("?")[0] || "", queryFromUrl = exports.extract(object.url), parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false }), query = Object.assign(parsedQueryFromUrl, object.query);
    let queryString2 = exports.stringify(query, options);
    queryString2 && (queryString2 = `?${queryString2}`);
    let hash = function(url2) {
      let hash2 = "";
      const hashStart = url2.indexOf("#");
      return -1 !== hashStart && (hash2 = url2.slice(hashStart)), hash2;
    }(object.url);
    return object.fragmentIdentifier && (hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`), `${url}${queryString2}${hash}`;
  }, exports.pick = (input, filter, options) => {
    options = Object.assign({ parseFragmentIdentifier: true, [encodeFragmentIdentifier]: false }, options);
    const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
    return exports.stringifyUrl({ url, query: filterObject(query, filter), fragmentIdentifier }, options);
  }, exports.exclude = (input, filter, options) => {
    const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
    return exports.pick(input, exclusionFilter, options);
  };
}(queryString$1);
var queryString = getDefaultExportFromCjs$1(queryString$1);
class Stopwatch {
  constructor() {
    this.startedAt = 0, this.reset();
  }
  measure() {
    const delta = performance.now() - this.startedAt;
    return { ms: delta, toString: () => delta.toFixed(1) };
  }
  reset() {
    this.startedAt = performance.now();
  }
}
class HandledError extends Error {
  constructor(message) {
    super(message), Object.setPrototypeOf(this, HandledError.prototype);
  }
}
class ConnectionError extends HandledError {
  constructor(message) {
    super(message), Object.setPrototypeOf(this, ConnectionError.prototype);
  }
}
class DescribedError extends HandledError {
  constructor(message) {
    super(message), Object.setPrototypeOf(this, DescribedError.prototype);
  }
}
class DescribedServerError extends DescribedError {
  constructor(message) {
    super(message), Object.setPrototypeOf(this, DescribedServerError.prototype);
  }
}
let middlewares = [];
function registerMiddleware(middleware) {
  return middlewares.push(middleware), () => {
    const index = middlewares.indexOf(middleware);
    -1 !== index && middlewares.splice(index, 1);
  };
}
async function applyMiddleware(request, actual) {
  return async function doProcess(index, req) {
    if (index === middlewares.length)
      return actual(req);
    return ensure(middlewares[index])(req, (r) => doProcess(index + 1, r));
  }(0, request);
}
class ResponseTypeError extends Error {
}
class ServerError extends Error {
  constructor(status, message) {
    super(message ?? "Internal server error"), this.status = status, Object.setPrototypeOf(this, ServerError.prototype);
  }
}
class UnauthorizedError extends ServerError {
  constructor(status) {
    super(status), Object.setPrototypeOf(this, UnauthorizedError.prototype);
  }
}
class ValidationError extends Error {
  constructor(original = {}) {
    super(), this.original = original, Object.setPrototypeOf(this, ValidationError.prototype);
  }
}
const logger$4 = LogManager.get().getLogger(LogNode.Network).debounced;
async function get(url, handleAs) {
  logger$4.trace(`Starting GET ${url}`);
  const stopwatch = new Stopwatch(), request = { url, init: { method: "get", headers: new Headers(), cache: "force-cache", credentials: "include" } }, response = await applyMiddleware(request, doFetch);
  if (logger$4.trace(`Finished GET ${url} in ${stopwatch.measure()} milliseconds. Response code ${response.status}.`), !response.ok)
    throw new ServerError(response.status, response.statusText);
  switch (handleAs) {
    case "text":
      return response.text();
    case "json":
      return ensureJsonResponse(response);
    case "blob":
      return response.blob();
  }
}
async function doFetch(outgoingRequest) {
  let response;
  outgoingRequest.init.body = isJson(outgoingRequest.body) ? JSON.stringify(outgoingRequest.body) : outgoingRequest.body;
  try {
    response = await window.fetch(outgoingRequest.url, outgoingRequest.init);
  } catch (e) {
    throw new ConnectionError(e instanceof Error ? e.message : String(e));
  }
  switch (response.status) {
    case 200:
      return response;
    case 400:
    case 401:
    case 402:
    case 403:
    case 460:
      throw new UnauthorizedError(response.status);
    case 502:
    case 504:
      throw new ServerError(response.status, response.statusText);
    case 551:
      throw new ValidationError(await response.json());
    case 560:
      const description = await getXasErrorDescription(response);
      throw description ? new DescribedServerError(description) : new ServerError(response.status);
    case 12029:
      throw new ConnectionError("No connection");
    default:
      throw new ServerError(response.status, await getXasErrorDescription(response));
  }
}
async function getXasErrorDescription(response) {
  const json = await ensureJsonResponse(response);
  return json && "description" in json ? json.description : void 0;
}
async function ensureJsonResponse(response) {
  const textContent = await response.text();
  try {
    return JSON.parse(textContent);
  } catch {
    throw new ResponseTypeError(`Expected response body to be JSON. Instead received: "${textContent}"`);
  }
}
const post = function(postFn) {
  const networkLogger = LogManager.get().getLogger(LogNode.Network);
  return async function(url, data) {
    const xasAction = "object" == typeof (payload = data) && null !== payload && "action" in payload && "string" == typeof payload.action ? data.action : void 0;
    var payload;
    void 0 !== xasAction ? networkLogger.trace(`Starting runtime action: ${xasAction}`) : networkLogger.trace(`Starting POST ${url}`);
    const stopwatch = new Stopwatch(), response = await postFn(url, data);
    return void 0 !== xasAction ? networkLogger.trace(`Finished runtime action "${xasAction}" in ${stopwatch.measure()} milliseconds.`) : networkLogger.trace(`Finished POST ${url} in ${stopwatch.measure()} milliseconds.`), response;
  };
}(async function(url, data) {
  const request = { url, body: data, init: { method: "post", headers: new Headers({ Accept: "application/json", ...isJson(data) ? { "Content-Type": "application/json" } : {} }), redirect: "error", credentials: "include" } };
  return ensureJsonResponse(await applyMiddleware(request, doFetch));
});
async function retrieveByIds(guids, schema) {
  return post(xasUrl(), { action: "retrieve_by_ids", params: { ids: guids, schema } });
}
async function retrieveByPath$1(guid, path, entity, direction, changes, objects) {
  return post(xasUrl(), { action: "retrieve_by_path", params: { id: guid, path, entity, direction }, changes, objects });
}
async function retrieveByXPath$1(xpath, schema = {}, wantCount = false) {
  return post(xasUrl(), { action: "retrieve_by_xpath", params: { xpath, schema, count: wantCount } });
}
async function retrieve(operationId, args, options, changes, objects) {
  return post(xasUrl(), { action: "runtimeOperation", operationId, params: args, options, changes, objects });
}
async function executeAction(params, context, changes, objects, asyncId) {
  return post(xasUrl(), { action: "executeaction", params: { ...params, asyncid: asyncId }, changes, objects, context: context.getGuids() });
}
async function pollBackgroundJob(asyncId) {
  return post(xasUrl(), { action: "poll_background_job", params: { asyncid: asyncId } });
}
async function instantiate(entity, changes, objects) {
  return post(xasUrl(), { action: "instantiate", params: { objecttype: entity }, changes, objects });
}
async function validate$1(changes, objects) {
  return post(xasUrl(), { action: "validate", params: {}, changes, objects });
}
async function commit$1(guids, context, changes, objects) {
  return post(xasUrl(), { action: "commit", params: { guids }, changes, objects, context: context.getGuids() });
}
async function rollback$1(guids, changes, objects) {
  return post(xasUrl(), { action: "rollback", params: { guids }, changes, objects });
}
async function _delete(guids, changes, objects) {
  return post(xasUrl(), { action: "delete", params: { guids }, changes, objects });
}
async function runtimeOperation(operationId, args, changes, objects, validationGuids, asyncId) {
  return post(xasUrl(), { action: "runtimeOperation", operationId, params: args, asyncid: asyncId, validationGuids, changes, objects });
}
async function login$2(username, password, useAuthToken) {
  return post(xasUrl(), { action: "login", params: { username, password, useAuthToken } });
}
async function getSessionData(params) {
  return post(xasUrl(), { action: "get_session_data", params: { ...params, version: 2 } });
}
async function logout$1() {
  return post(xasUrl(), { action: "logout", params: {} });
}
async function keepalive() {
  return post(xasUrl(), { action: "keepalive", params: {} });
}
async function _export(params, changes, objects, asyncId) {
  await post(xasUrl(), { action: "export", params: { ...params, asyncid: asyncId }, changes, objects });
}
async function synchronizeObjects(changes, fileGuidMapping, returnObjects, deletes, extraGuidsToRetrieve, incompatibleChanges) {
  return post(xasUrl(), { action: "synchronize_objects", changes, fileGuidMapping, returnObjects, deletes, extraGuidsToRetrieve: extraGuidsToRetrieve ?? [], incompatibleChanges: incompatibleChanges ?? [] });
}
async function createGuids(entities) {
  return post(xasUrl(), { action: "create_guids", params: { entities } });
}
async function upload(guid, name, params, blob, changes, objects) {
  const url = mx.remoteUrl + "file?" + queryString$1.stringify({ ...params, guid }), formData = new FormData();
  return formData.append("data", JSON.stringify({ changes, objects })), name ? formData.append("blob", blob, name) : formData.append("blob", blob), post(url, formData);
}
async function getOTAInfo(platform, url = xasUrl(), nativeDependencies, nativeBinaryVersion) {
  return post(url, { action: "get_ota_info", params: { platform, nativeDependencies, nativeBinaryVersion } });
}
async function sendBatchedLogs(id, logs, url = xasUrl()) {
  return post(url, { action: "log_batched_client_logs", params: { id, logs } });
}
async function getClientLogLevels(url = xasUrl()) {
  return post(url, { action: "get_client_log_levels" });
}
function xasUrl(url = mx.remoteUrl) {
  return url + "xas/";
}
var DayOfWeek;
!function(DayOfWeek2) {
  DayOfWeek2[DayOfWeek2.Sunday = 0] = "Sunday", DayOfWeek2[DayOfWeek2.Monday = 1] = "Monday", DayOfWeek2[DayOfWeek2.Tuesday = 2] = "Tuesday", DayOfWeek2[DayOfWeek2.Wednesday = 3] = "Wednesday", DayOfWeek2[DayOfWeek2.Thursday = 4] = "Thursday", DayOfWeek2[DayOfWeek2.Friday = 5] = "Friday", DayOfWeek2[DayOfWeek2.Saturday = 6] = "Saturday";
}(DayOfWeek || (DayOfWeek = {}));

async function withFinally(promise, finallyFun) {
  return promise.then((d) => (finallyFun(), d), (e) => (finallyFun(), Promise.reject(e)));
}
async function never() {
  return new Promise(() => {
  });
}
async function wait(timeout = 0) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, timeout);
  });
}
async function methodToPromise(subject, functionName, ...args) {
  return new Promise((resolve, reject) => subject[functionName](...args, resolve, reject));
}
let asyncIdCounter = (/* @__PURE__ */ new Date()).getTime();
async function executeAsync(action, maxFailures = 0) {
  const asyncId = asyncIdCounter++;
  await action(asyncId);
  let remainingFailures = maxFailures, delay = 500;
  for (; ; ) {
    try {
      const result = await pollBackgroundJob(asyncId);
      if (result.response.finished)
        return result;
    } catch (e) {
      if (remainingFailures-- <= 0)
        throw e;
    }
    await wait(delay), delay = Math.min(delay + 500, 8e3);
  }
}
const microflowInfo = {};
function getMicroflowInfo(operationId) {
  return microflowInfo[operationId];
}
let globalData, globalOnlineData, globalOfflineData;
function getData() {
  return ensure(globalData);
}
function onlineData() {
  return ensure(globalOnlineData);
}
function offlineData() {
  return ensure(globalOfflineData);
}
function initializeCore(sessionData, languageCodes, microflows, newOnlineData, newOfflineData) {
  startupLocalization(sessionData.locale, sessionData.uiconfig.roundingmode), updateActiveLanguageIndex(languageCodes, sessionData.locale.code), function(microflows2 = {}) {
    for (const [key, operationIds] of Object.entries(microflows2))
      for (const operationId of operationIds.split(",")) {
        const mfData = JSON.parse(key);
        microflowInfo[operationId] = { parameters: mfData.p }, mfData.a && (microflowInfo[operationId].followedAssociations = mfData.a.map(([association, fromEntity]) => ({ association, fromEntity })));
      }
  }(microflows), globalOnlineData = newOnlineData, globalOfflineData = newOfflineData;
}
function setData(s) {
  globalData = s;
}

function createChange(json) {
  const meta = ensure(getEntityMeta(json.objectType)), changeEntries = Object.entries(json.attributes).filter(([attrKey, attr]) => meta.attributes[attrKey]?.isSyncable && !attr.readonly).map(([attrKey, attr]) => ({ [attrKey]: { value: attr.value } }));
  return Object.assign({}, ...changeEntries);
}
const SYNC_DURATION_WARNING_THRESHOLD = 6e4;
function createOfflineGuid() {
  return "GUID:" + newId();
}
function isRuntimeGuid(internalGuid) {
  return !internalGuid.startsWith("GUID:");
}
const indexMxObjectJsonsByGuid = indexByKey((obj) => obj.guid), indexMxObjectsByGuid = indexByKey((obj) => obj.getGuid());
function createChangeFromIncompatibleObjectsJson(json) {
  const changeEntries = Object.keys(json.attributes).map((attr) => ({ [attr]: { value: json.attributes[attr]?.value } }));
  return Object.assign({}, ...changeEntries);
}
function isFileDocumentWithContentNonMetaCheck(objectJson) {
  const { attributes } = objectJson;
  return ["FileID", "HasContents", "Size"].every((attr) => attr in attributes) && attributes.HasContents?.value;
}
function getIncompatibleEntities(oldMetadata, newMetadata) {
  const oldMetadataEntityAttributes = extractEntityAttributesMap(oldMetadata), newMetadataEntityAttributes = extractEntityAttributesMap(newMetadata), incompatibleEntities = [];
  for (const [oldEntity, oldAttributeTypeMap] of oldMetadataEntityAttributes) {
    if (!newMetadataEntityAttributes.has(oldEntity)) {
      incompatibleEntities.push(oldEntity);
      continue;
    }
    const newAttrsTypesMap = newMetadataEntityAttributes.get(oldEntity);
    for (const [oldAttrName, oldAttrType] of oldAttributeTypeMap) {
      const newAttrType = newAttrsTypesMap.get(oldAttrName);
      if (newAttrType && newAttrType !== oldAttrType) {
        incompatibleEntities.push(oldEntity);
        break;
      }
    }
  }
  return new Set(incompatibleEntities);
  function extractEntityAttributesMap(metadata) {
    return new Map(metadata.map((meta) => [meta.objectType, new Map(Object.entries(meta.attributes).map(([attrName, { type }]) => [attrName, type]))]));
  }
}
async function getByGuids(guids) {
  return new Promise((resolve, reject) => getData().get({ guids, callback: resolve, error: reject }));
}
async function getByGuid(guid) {
  return new Promise((resolve, reject) => getData().get({ guid, callback(obj) {
    resolve(obj ?? void 0);
  }, error: reject }));
}
const DEFAULT_ATTRIBUTE_VALUES = { String: null, Integer: null, Long: null, Decimal: null, Enum: null, HashString: null, ObjectReference: null, ObjectReferenceSet: [], DateTime: null, Boolean: false, AutoNumber: "0", Binary: null, EnumSet: null };
function createMxObjectJSON(guid, entityMeta) {
  const json = { guid, objectType: entityMeta.name, attributes: {} };
  return getAttributesMeta(entityMeta.name).forEach((attrMeta) => {
    const value = !entityMeta.isPersistable && isSystemAttribute(attrMeta.name) ? function(attr) {
      switch (attr) {
        case SystemAttribute.Owner:
        case SystemAttribute.ChangedBy:
          return getSession().getUserId();
        case SystemAttribute.CreatedDate:
        case SystemAttribute.ChangedDate:
          return Date.now();
      }
    }(attrMeta.name) : void 0 === attrMeta.defaultValue ? DEFAULT_ATTRIBUTE_VALUES[attrMeta.type] : "DateTime" === attrMeta.type && "[%CurrentDateTime%]" === attrMeta.defaultValue ? (/* @__PURE__ */ new Date()).getTime() : attrMeta.defaultValue;
    json.attributes[attrMeta.name] = { value, readonly: attrMeta.isAlwaysReadOnly };
  }), json;
}
function getCachedObjectsByPath(guid, direction, path, objectCache) {
  let cachedObjects = [], uncachedGuids = [];
  const association = getAssociationStep(path);
  if ("reverse" === direction)
    cachedObjects = objectCache.getAllObjects().filter((mxobj) => mxobj.getReferences(association).includes(guid));
  else {
    const rootMxObj = objectCache.getObject(guid);
    rootMxObj && ({ cachedObjects, uncachedGuids } = getRefsObjects(rootMxObj, objectCache, association));
  }
  return { cachedObjects, uncachedGuids };
}
function getRefsObjects(rootMxObj, objectCache, association) {
  const refGuids = rootMxObj.getReferences(association);
  return { cachedObjects: refGuids.map((refGuid) => objectCache.getObject(refGuid)).filter((mxobj) => null !== mxobj), uncachedGuids: refGuids.filter((refGuid) => !objectCache.has(refGuid)) };
}
function getAssociationStep(path) {
  const steps = path.split("/");
  return 1 === steps.length ? path : steps[0];
}
function deriveEntityUnchecked(id) {
  const entityId = deriveEntityId(id), entity = getEntityMeta(entityId);
  return entity?.name;
}
function deriveEntity(id) {
  const entity = deriveEntityUnchecked(id);
  if (void 0 === entity)
    throw new AssertionError(`Can't find entity for guid '${id}'`);
  return entity;
}
function isObjectOffline(id) {
  if (isRuntimeGuid(id)) {
    const entity = deriveEntityUnchecked(id);
    return void 0 !== entity && mx.isOffline(entity);
  }
  return true;
}
function isOffline(entity) {
  return getSession().isOffline() && !(entity && offlineData().hasOnlineSyncMode(entity));
}

function __decorate(decorators, target, key, desc) {
  var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
"function" == typeof SuppressedError && SuppressedError;
const rootPath = "*;";
function isAncestorOrSelf(parent, path) {
  return path.startsWith(parent);
}
class StoreBackend {
  constructor() {
    this.recordGroups = /* @__PURE__ */ new Map(), this.usedSlotsCount = /* @__PURE__ */ new Map(), this.slotObservers = /* @__PURE__ */ new Map();
  }
  get$(widgetId, slot, path) {
    const recordsGroup = this.getOrCreateGroup(widgetId, slot);
    let recordWithExactPath;
    return fromComputation$(`backend.get$(${widgetId}, ${slot}, ${path})`, () => {
      if (recordWithExactPath)
        return recordWithExactPath.get();
      const bestMatchingRecord = recordsGroup.filter(([recordPath]) => isAncestorOrSelf(recordPath, path)).pop();
      return bestMatchingRecord ? (bestMatchingRecord[0] === path && (recordWithExactPath = bestMatchingRecord[1]), bestMatchingRecord[1].get()) : void 0;
    });
  }
  set(widgetId, slot, path, value) {
    this.usedSlotsCount.set(slot, (this.usedSlotsCount.get(slot) ?? 0) + 1);
    const recordsGroup = this.getOrCreateGroup(widgetId, slot), existingRecord = recordsGroup.filter(([recordPath]) => isAncestorOrSelf(recordPath, path)).pop();
    if (existingRecord)
      return void existingRecord[1].set(value);
    const newRecord = tuple(path, observable.box(value, { deep: false, name: `backend.box(${widgetId}, ${slot}, ${path})`, equals: deepEqual })), moreSpecificRecordIndex = recordsGroup.findIndex(([recordPath]) => recordPath.length > path.length);
    -1 === moreSpecificRecordIndex ? recordsGroup.push(newRecord) : recordsGroup.splice(moreSpecificRecordIndex, 0, newRecord);
  }
  getAllEntries$(slot, path) {
    const slotObserver = this.slotObservers.get(slot) ?? createAtom(`backend.slot(${slot})`);
    return this.slotObservers.set(slot, slotObserver), fromComputation$(`backend.getAll$(${slot}, ${path})`, () => {
      slotObserver.reportObserved();
      const result = [];
      for (const [key, recordsGroup] of this.recordGroups.entries()) {
        const [groupSlot, widgetId] = key.split("\xBB");
        if (groupSlot === slot)
          for (const [recordPath, recordBox] of recordsGroup.toJS().reverse())
            path && !isAncestorOrSelf(path, recordPath) || result.push({ widgetId, path: recordPath, value: recordBox.get() });
      }
      return result;
    });
  }
  free(widgetId, slot, path) {
    const currentCount = this.usedSlotsCount.get(slot) ?? 0;
    this.usedSlotsCount.set(slot, Math.max(0, currentCount - 1));
    const recordsKey = this.groupKey(widgetId, slot), recordsGroup = this.recordGroups.get(recordsKey);
    void 0 !== recordsGroup && (recordsGroup.filter(([recordPath]) => isAncestorOrSelf(path, recordPath)).forEach((record) => {
      recordsGroup.remove(record);
    }), 0 === recordsGroup.length && this.recordGroups.delete(recordsKey));
  }
  getUsedSlots() {
    return Array.from(this.usedSlotsCount.entries()).filter(([_, value]) => value > 0).map(([key]) => key);
  }
  groupKey(widgetId, slot) {
    return `${slot}\xBB${widgetId}`;
  }
  getOrCreateGroup(widgetId, slot) {
    const recordsKey = this.groupKey(widgetId, slot), existingGroup = this.recordGroups.get(recordsKey);
    if (existingGroup)
      return existingGroup;
    const newGroup = observable.array([], { deep: false, name: `backend.group(${widgetId}, ${slot})` });
    return this.recordGroups.set(recordsKey, newGroup), this.slotObservers.get(slot)?.reportChanged(), newGroup;
  }
}
__decorate([action], StoreBackend.prototype, "set", null), __decorate([action], StoreBackend.prototype, "free", null);
class StoreFrontend {
  constructor(backend, path, onBackendUpdateRequested, subscriptionPriority) {
    this.backend = backend, this.path = path, this.onBackendUpdateRequested = onBackendUpdateRequested, this.subscriptionPriority = subscriptionPriority, this.localMirrors = /* @__PURE__ */ new Map(), this.updateCallbacks = [], this.destroyed = false;
  }
  useSlot(widgetId, slot) {
    const localMirror = this.getOrCreateLocalMirror(widgetId, slot);
    return tuple(localMirror.value$, action(localMirror.setValue));
  }
  getAll$(slot) {
    const allEntries$ = this.backend.getAllEntries$(slot, this.path);
    return fromComputation$("getAll$({slot})", () => allEntries$.dependOn().map((e) => e.value));
  }
  getSubscriptionPriority() {
    return this.subscriptionPriority;
  }
  addUpdateCallback(callback) {
    this.destroyed ? callback() : (this.updateCallbacks.push(callback), this.onBackendUpdateRequested());
  }
  updateFromBackend() {
    for (const mirror of this.localMirrors.values())
      mirror.updateFromBackend();
    this.flushUpdateCallbacks();
  }
  destroy() {
    for (const mirror of this.localMirrors.values())
      mirror.free();
    this.localMirrors.clear(), this.flushUpdateCallbacks(), this.destroyed = true;
  }
  flushUpdateCallbacks() {
    this.updateCallbacks.splice(0).forEach((c) => c());
  }
  getOrCreateLocalMirror(widgetId, slot) {
    const key = `${widgetId}\u2192${slot}`, existingMirror = this.localMirrors.get(key);
    if (existingMirror)
      return existingMirror;
    let localValue;
    const backendValue$ = this.backend.get$(widgetId, slot, this.path);
    let currentBackendValue, backendValueSubscription;
    const [localValueTracker$, localValueChanged] = useDependency(`localValue(${widgetId}, ${slot})`, () => {
      ensure(backendValueSubscription)(), backendValueSubscription = void 0;
    }, () => {
      currentBackendValue = localValue = readUntracked(backendValue$), backendValueSubscription = reaction(() => backendValue$.dependOn(), (v) => {
        v !== currentBackendValue && (currentBackendValue = v, this.onBackendUpdateRequested());
      }, { name: `copy backendValue for (${widgetId}, ${slot})` });
    });
    let didSetValue = false;
    const newMirror = { value$: fromComputation$(`get$(${widgetId}, ${slot})`, () => (localValueTracker$.dependOn(), localValue)), setValue: (value) => {
      if (!this.localMirrors.has(key))
        throw new Error(`Error trying to set value to ${key}. The slot has already been freed.`);
      didSetValue = true, deepEqual(value, localValue) || localValueChanged(), this.backend.set(widgetId, slot, this.path, value), currentBackendValue = localValue = value;
    }, updateFromBackend: () => {
      void 0 === backendValueSubscription || deepEqual(currentBackendValue, localValue) || (localValueChanged(), localValue = currentBackendValue);
    }, free: () => {
      didSetValue && "localvariable" !== slot && this.backend.free(widgetId, slot, this.path);
    } };
    return this.localMirrors.set(key, newMirror), newMirror;
  }
}
__decorate([action], StoreFrontend.prototype, "updateFromBackend", null), __decorate([action], StoreFrontend.prototype, "destroy", null);
const StoreBackendContext = reactExports.createContext(void 0), StorePathContext = reactExports.createContext(void 0), SubscriptionPriorityContext = reactExports.createContext(0);
function RootStoreProvider(props) {
  return jsxRuntimeExports.jsx(StoreBackendContext.Provider, { value: props.backend, children: jsxRuntimeExports.jsx(StorePathContext.Provider, { value: "*;", children: props.children }) });
}
function useComponentStore() {
  const backend = ensure(reactExports.useContext(StoreBackendContext)), storePath = ensure(reactExports.useContext(StorePathContext)), subscriptionPriority = reactExports.useContext(SubscriptionPriorityContext), forceUpdate = useForceUpdate(), frontend = reactExports.useMemo(() => new StoreFrontend(backend, storePath, forceUpdate, subscriptionPriority), [backend, storePath, forceUpdate, subscriptionPriority]);
  return reactExports.useLayoutEffect(() => () => frontend.destroy(), [backend]), frontend.updateFromBackend(), frontend;
}
function useStoreBackendValue(widgetId, slot) {
  const backend = ensure(reactExports.useContext(StoreBackendContext)), storePath = ensure(reactExports.useContext(StorePathContext));
  useEnsureConstantValues(backend, storePath, widgetId, slot);
  return [reactExports.useMemo(() => backend.get$(widgetId, slot, storePath), []), reactExports.useCallback((value) => backend.set(widgetId, slot, storePath, value), [])];
}
function useOwnStoreBackendSlot(widgetId, slot) {
  const backend = ensure(reactExports.useContext(StoreBackendContext)), storePath = ensure(reactExports.useContext(StorePathContext));
  useEnsureConstantValues(backend, storePath, widgetId, slot), reactExports.useLayoutEffect(() => () => backend.free(widgetId, slot, storePath), []);
}
function NestedStoreProvider(props) {
  const childStorePath = function(parent, namespace) {
    if (namespace.includes(";"))
      throw new AssertionError(`Illegal character ';' in namespace: ${namespace}`);
    return `${parent}${namespace};`;
  }(ensure(reactExports.useContext(StorePathContext)), props.namespace);
  return jsxRuntimeExports.jsxs(StorePathContext.Provider, { value: childStorePath, children: [props.setupStore ? jsxRuntimeExports.jsx(CurrentStoreHandler, { callback: props.setupStore }) : null, props.children] });
}
function CurrentStoreHandler(props) {
  const currentStore = useComponentStore();
  return reactExports.useMemo(() => props.callback(currentStore), [props.callback, currentStore]), null;
}

const associationsToIds = {}, idsToAssociationInfo = {}, idsToAssociationType = {};
function ensureAssociationId(associationPath, dataSourceId, selectableObjectsId) {
  const key = JSON.stringify([associationPath, dataSourceId, selectableObjectsId]), existingId = associationsToIds[key];
  if (existingId)
    return existingId;
  const id = newId("assoc");
  return associationsToIds[key] = id, idsToAssociationInfo[id] = Object.freeze({ associationPath, dataSourceId, selectableObjectsId }), id;
}
function getAssociationInfoById(id) {
  return idsToAssociationInfo[id];
}
function registerAssociationType(id, associationType) {
  idsToAssociationType[id] = associationType;
}
function getAssociationTypeById(id) {
  return idsToAssociationType[id];
}
const attributesToIds = {}, idsToAttributeInfo = {}, idsToAttributeType = {};
function ensureAttributeId(attributePath, dataSourceId) {
  const key = JSON.stringify([attributePath, dataSourceId]), existingId = attributesToIds[key];
  if (existingId)
    return existingId;
  const id = newId("attr");
  return attributesToIds[key] = id, idsToAttributeInfo[id] = Object.freeze({ attributePath, dataSourceId }), id;
}
function getAttributeInfoById(id) {
  return idsToAttributeInfo[id];
}
function registerAttributeType(id, attributeType, isUnlocalizedDate = false, enumUniverse) {
  idsToAttributeType[id] = [attributeType, isUnlocalizedDate, enumUniverse];
}
function getAttributeTypeById(id) {
  return idsToAttributeType[id]?.[0];
}
function isUnlocalizedDateAttribute(id) {
  return idsToAttributeType[id]?.[1] ?? false;
}
function getEnumUniverseById(id) {
  return idsToAttributeType[id]?.[2];
}
const expressionSymbol = Symbol("filterExpression"), dataSourceIdSymbol$1 = Symbol("dataSourceId"), attributeIdToFilterableFlag = {};
function registerFilterAttribute(attributeId, filterable) {
  attributeIdToFilterableFlag[attributeId] = filterable;
}
function isFilterable(attributeId) {
  return attributeIdToFilterableFlag[attributeId];
}
function freezeExpression(obj) {
  return obj[expressionSymbol] || (obj[expressionSymbol] = true, Object.freeze(obj)), obj;
}
function assertValidFilterCondition$1(filter, dataSourceId) {
  if (void 0 === filter)
    return true;
  if (!isFilterCondition(filter))
    throw new AssertionError("setFilter: argument must be a FilterCondition and be created with the filter API or obtained from a ListValue");
  return function assertValidExpressions(expr) {
    switch (expr.type) {
      case "attribute":
        const attributeInfo = getAttributeInfoById(expr.attributeId);
        if (void 0 === attributeInfo)
          throw new AssertionError(`setFilter: FilterCondition uses an attribute with invalid id '${expr.attributeId}'`);
        if (!isFilterable(expr.attributeId))
          throw new AssertionError(`setFilter: FilterCondition uses an attribute with id '${expr.attributeId}' which is not filterable`);
        if (attributeInfo.dataSourceId !== dataSourceId)
          throw new AssertionError(`"setFilter: FilterCondition uses an attribute with id '${expr.attributeId}' which is linked to a different data source`);
        break;
      case "literal":
        break;
      case "function":
        "arg" in expr ? assertValidExpressions(expr.arg) : "arg1" in expr ? (assertValidExpressions(expr.arg1), assertValidExpressions(expr.arg2)) : expr.args.forEach(assertValidExpressions);
        break;
      case "association":
        const associationInfo = getAssociationInfoById(expr.associationId);
        if (void 0 === associationInfo)
          throw new AssertionError(`setFilter: FilterCondition uses an association with invalid id '${expr.associationId}'`);
        if (!isFilterable(expr.associationId))
          throw new AssertionError(`setFilter: FilterCondition uses an association with id '${expr.associationId}' which is not filterable`);
        if (associationInfo.dataSourceId !== dataSourceId)
          throw new AssertionError(`"setFilter: FilterCondition uses an association with id '${expr.associationId}' which is linked to a different data source`);
    }
  }(filter), true;
}
function isFilterCondition(expr) {
  return isFilterExpression(expr) && "function" === expr.type;
}
function isValueExpression(expr) {
  return isAttributeExpression(expr) || isLiteralExpression(expr) || isAssociationExpression(expr);
}
function isAttributeExpression(expr) {
  return isFilterExpression(expr) && "attribute" === expr.type;
}
function isLiteralExpression(expr) {
  return isFilterExpression(expr) && "literal" === expr.type;
}
function isAssociationExpression(expr) {
  return isFilterExpression(expr) && "association" === expr.type;
}
function isFilterExpression(expr) {
  return "object" == typeof expr && null !== expr && expressionSymbol in expr && Object.isFrozen(expr);
}
function equalFilterCondition(a, b) {
  return deepEqual(a, b);
}

const objectSymbol = Symbol("mxObject"), dataSourceIdSymbol = Symbol("dataSourceId");
function toObjectItem(obj, dataSourceId) {
  return { id: obj.getGuid(), [objectSymbol]: obj, [dataSourceIdSymbol]: dataSourceId };
}
function fromObjectItem(item, dataSourceId, description) {
  function throwError(message) {
    throw new Error(description ? `${message} (${description})` : message);
  }
  return isObjectItem(item) || throwError("Only an ObjectItem can be passed to a template."), isDataSourceValid(item, dataSourceId) || throwError("An ObjectItem can only be passed to a template that is linked to the same data source."), item[objectSymbol];
}
function isObjectItem(item) {
  return "object" == typeof item && null != item && objectSymbol in item && dataSourceIdSymbol in item;
}
function isObjectItemArray(value) {
  return Array.isArray(value) && value.every(isObjectItem);
}
function getDataSourceId(item) {
  return item[dataSourceIdSymbol];
}
function isDataSourceValid(item, dataSourceId) {
  return getDataSourceId(item) === dataSourceId;
}

function attribute(attributeId) {
  return function(attributeId2) {
    if (!function(attributeId3) {
      if ("string" != typeof attributeId3)
        return false;
      return void 0 !== getAttributeInfoById(attributeId3);
    }(attributeId2))
      throw new AssertionError(`Argument of function "attribute" is not a valid attribute id: ${attributeId2}`);
    if (!isFilterable(attributeId2))
      throw new AssertionError(`Argument of function "attribute" is not a filterable attribute id: ${attributeId2}`);
  }(attributeId), freezeExpression({ type: "attribute", attributeId });
}
function literal(value) {
  const valueType = function(value2) {
    const type = typeof value2;
    switch (type) {
      case "boolean":
      case "string":
      case "undefined":
        return type;
      case "object":
        if (value2 instanceof Big)
          return "Numeric";
        if (value2 instanceof Date)
          return "DateTime";
        if (isObjectItem(value2))
          return "Reference";
        if (isObjectItemArray(value2)) {
          if (0 === value2.length)
            throw new AssertionError('Argument of function "literal" cannot be an empty array, use empty() instead.');
          return "ReferenceSet";
        }
    }
    throw new AssertionError(`Argument of function "literal" is not a valid literal value: ${value2}`);
  }(value), literalValue = function(value2, valueType2) {
    switch (valueType2) {
      case "Reference":
        const item = value2;
        return { value: item.id, [dataSourceIdSymbol$1]: getDataSourceId(item) };
      case "ReferenceSet":
        const items = value2, dataSourceIds = items.map(getDataSourceId);
        if (unique(dataSourceIds).length > 1)
          throw new AssertionError('Argument of function "literal" cannot contain object items from multiple data sources');
        return { value: Object.freeze(items.map((v) => v.id)), [dataSourceIdSymbol$1]: dataSourceIds[0] };
      default:
        return { value: Object.freeze(value2) };
    }
  }(value, valueType);
  return freezeExpression({ type: "literal", ...literalValue, valueType });
}
function empty() {
  return literal(void 0);
}
function association(associationId) {
  return function(associationId2) {
    if (!function(associationId3) {
      if ("string" != typeof associationId3)
        return false;
      return void 0 !== getAssociationInfoById(associationId3);
    }(associationId2))
      throw new AssertionError(`Argument of function "association" is not a valid association id: ${associationId2}`);
    if (!isFilterable(associationId2))
      throw new AssertionError(`Argument of function "association" is not a filterable association id: ${associationId2}`);
  }(associationId), freezeExpression({ type: "association", associationId });
}
function and(...args) {
  return assertAtLeastTwoArguments("and", args), assertValidFilterConditions("and", args), multiaryFunction("and", ...args);
}
function or(...args) {
  return assertAtLeastTwoArguments("or", args), assertValidFilterConditions("or", args), multiaryFunction("or", ...args);
}
function not(arg) {
  return assertValidFilterCondition("not", arg), function(functionName, arg2) {
    return functionExpression(functionName, { arg: arg2 });
  }("not", arg);
}
function equals(arg1, arg2) {
  return assertValidValueExpression("equals", arg1, 0), assertValidValueExpression("equals", arg2, 1), assertCompatibleValueTypes("equals", arg1, arg2), assertValidEnumTypes("equals", arg1, arg2), assertValidReferenceSets("equals", arg1, arg2), binaryFunction("=", arg1, arg2);
}
function notEqual(arg1, arg2) {
  return assertValidValueExpression("notEqual", arg1, 0), assertValidValueExpression("notEqual", arg2, 1), assertCompatibleValueTypes("notEqual", arg1, arg2), assertValidEnumTypes("notEqual", arg1, arg2), assertValidReferenceSets("notEqual", arg1, arg2), binaryFunction("!=", arg1, arg2);
}
const allowedOrderedComparisonTypes = ["string", "Numeric", "DateTime"];
function greaterThan(arg1, arg2) {
  return assertValidValueExpression("greaterThan", arg1, 0), assertValidValueExpression("greaterThan", arg2, 1), assertCompatibleValueTypes("greaterThan", arg1, arg2, allowedOrderedComparisonTypes), binaryFunction(">", arg1, arg2);
}
function lessThan(arg1, arg2) {
  return assertValidValueExpression("lessThan", arg1, 0), assertValidValueExpression("lessThan", arg2, 1), assertCompatibleValueTypes("lessThan", arg1, arg2, allowedOrderedComparisonTypes), binaryFunction("<", arg1, arg2);
}
function greaterThanOrEqual(arg1, arg2) {
  return assertValidValueExpression("greaterThanOrEqual", arg1, 0), assertValidValueExpression("greaterThanOrEqual", arg2, 1), assertCompatibleValueTypes("greaterThanOrEqual", arg1, arg2, allowedOrderedComparisonTypes), binaryFunction(">=", arg1, arg2);
}
function lessThanOrEqual(arg1, arg2) {
  return assertValidValueExpression("lessThanOrEqual", arg1, 0), assertValidValueExpression("lessThanOrEqual", arg2, 1), assertCompatibleValueTypes("lessThanOrEqual", arg1, arg2, allowedOrderedComparisonTypes), binaryFunction("<=", arg1, arg2);
}
const allowedStringFunctionAttributeTypes = ["String", "Integer", "Long", "Decimal", "AutoNumber"];
function contains(arg1, arg2) {
  switch (assertValidExpression("attribute or association expression", (expr) => isAttributeExpression(expr) || isAssociationExpression(expr), "contains", arg1, 0), assertValidLiteralExpression("contains", arg2, 1), arg1.type) {
    case "association":
      assertExpectedType("contains", 0, getAssociationType(arg1.associationId), ["ReferenceSet"]), assertExpectedType("contains", 1, getValueType(arg2), ["Reference", "ReferenceSet"]), assertCompatibleDataSources("contains", arg1, arg2);
      break;
    case "attribute":
      assertExpectedType("contains", 0, getAttributeType(arg1.attributeId), allowedStringFunctionAttributeTypes), assertExpectedType("contains", 1, getValueType(arg2), ["string"]);
      break;
    default:
      crash();
  }
  return binaryFunction("contains", arg1, arg2);
}
function startsWith(arg1, arg2) {
  return assertValidAttributeExpression("startsWith", arg1, 0), assertValidLiteralExpression("startsWith", arg2, 1), assertExpectedType("startsWith", 0, getAttributeType(arg1.attributeId), allowedStringFunctionAttributeTypes), assertExpectedType("startsWith", 1, getValueType(arg2), ["string"]), binaryFunction("starts-with", arg1, arg2);
}
function endsWith(arg1, arg2) {
  return assertValidAttributeExpression("endsWith", arg1, 0), assertValidLiteralExpression("endsWith", arg2, 1), assertExpectedType("endsWith", 0, getAttributeType(arg1.attributeId), allowedStringFunctionAttributeTypes), assertExpectedType("endsWith", 1, getValueType(arg2), ["string"]), binaryFunction("ends-with", arg1, arg2);
}
function dayEquals(arg1, arg2) {
  return assertValidAttributeExpression("dayEquals", arg1, 0), assertValidLiteralExpression("dayEquals", arg2, 1), assertCompatibleValueTypes("dayEquals", arg1, arg2, ["DateTime"]), binaryFunction("day:=", arg1, arg2);
}
function dayNotEqual(arg1, arg2) {
  return assertValidAttributeExpression("dayNotEqual", arg1, 0), assertValidLiteralExpression("dayNotEqual", arg2, 1), assertCompatibleValueTypes("dayNotEqual", arg1, arg2, ["DateTime"]), binaryFunction("day:!=", arg1, arg2);
}
function dayGreaterThan(arg1, arg2) {
  return assertValidAttributeExpression("dayGreaterThan", arg1, 0), assertValidLiteralExpression("dayGreaterThan", arg2, 1), assertCompatibleValueTypes("dayGreaterThan", arg1, arg2, ["DateTime"]), binaryFunction("day:>", arg1, arg2);
}
function dayLessThan(arg1, arg2) {
  return assertValidAttributeExpression("dayLessThan", arg1, 0), assertValidLiteralExpression("dayLessThan", arg2, 1), assertCompatibleValueTypes("dayLessThan", arg1, arg2, ["DateTime"]), binaryFunction("day:<", arg1, arg2);
}
function dayGreaterThanOrEqual(arg1, arg2) {
  return assertValidAttributeExpression("dayGreaterThanOrEqual", arg1, 0), assertValidLiteralExpression("dayGreaterThanOrEqual", arg2, 1), assertCompatibleValueTypes("dayGreaterThanOrEqual", arg1, arg2, ["DateTime"]), binaryFunction("day:>=", arg1, arg2);
}
function dayLessThanOrEqual(arg1, arg2) {
  return assertValidAttributeExpression("dayLessThanOrEqual", arg1, 0), assertValidLiteralExpression("dayLessThanOrEqual", arg2, 1), assertCompatibleValueTypes("dayLessThanOrEqual", arg1, arg2, ["DateTime"]), binaryFunction("day:<=", arg1, arg2);
}
function binaryFunction(functionName, arg1, arg2) {
  return functionExpression(functionName, { arg1, arg2 });
}
function multiaryFunction(functionName, ...args) {
  return functionExpression(functionName, { args: Object.freeze(args) });
}
function functionExpression(functionName, args) {
  return freezeExpression({ type: "function", name: functionName, ...args });
}
function assertAtLeastTwoArguments(functionName, args) {
  if (args.length < 2)
    throw new AssertionError(`The "${functionName}" function requires at least two arguments.`);
}
function assertValidFilterConditions(functionName, args) {
  args.forEach((arg, i) => assertValidFilterCondition(functionName, arg, i));
}
function assertValidFilterCondition(functionName, arg, index) {
  assertValidExpression("filter condition", isFilterCondition, functionName, arg, index);
}
function assertValidValueExpression(functionName, arg, index) {
  assertValidExpression("value expression", isValueExpression, functionName, arg, index);
}
function assertValidAttributeExpression(functionName, arg, index) {
  assertValidExpression("attribute expression", isAttributeExpression, functionName, arg, index);
}
function assertValidLiteralExpression(functionName, arg, index) {
  assertValidExpression("literal expression", isLiteralExpression, functionName, arg, index);
}
function assertValidExpression(description, predicate, functionName, arg, index) {
  const argument = void 0 !== index ? `Argument #${index}` : "Argument";
  if (null == arg)
    throw new AssertionError(`${argument} of function "${functionName}" cannot be ${arg}`);
  if (!predicate(arg))
    throw new AssertionError(`${argument} of function "${functionName}" is not a valid ${description}`);
}
function assertCompatibleValueTypes(functionName, arg1, arg2, expectedTypes = []) {
  const type1 = getValueType(arg1), type2 = getValueType(arg2);
  if (assertExpectedType(functionName, 0, type1, expectedTypes), assertExpectedType(functionName, 1, type2, expectedTypes), type1 !== type2 && "undefined" !== type1 && "undefined" !== type2)
    throw new AssertionError(`The arguments of function "${functionName}" have incompatible types (${type1} != ${type2}).`);
  assertCompatibleDataSources(functionName, arg1, arg2);
}
function assertCompatibleDataSources(functionName, arg1, arg2) {
  const dataSourceId1 = getSelectableObjectsId(arg1), dataSourceId2 = getSelectableObjectsId(arg2);
  if (dataSourceId1 !== dataSourceId2 && void 0 !== dataSourceId1 && void 0 !== dataSourceId2)
    throw new AssertionError(`The arguments of function "${functionName}" are incompatible, because they are not referring to objects from the same data source.`);
}
function assertValidReferenceSets(functionName, arg1, arg2) {
  if (assertNoReferenceSetLiteral(functionName, 0, arg1), assertNoReferenceSetLiteral(functionName, 1, arg2), isReferenceSetAssociation(arg1) && isReferenceSetAssociation(arg2))
    throw new AssertionError(`The arguments of function "${functionName}" cannot both be reference set associations.`);
}
function assertNoReferenceSetLiteral(functionName, index, arg) {
  if (isLiteralExpression(arg) && "ReferenceSet" === arg.valueType)
    throw new AssertionError(`Argument #${index} of function "${functionName}" cannot be a reference set literal, only empty().`);
}
function isReferenceSetAssociation(arg1) {
  return "association" === arg1.type && "ReferenceSet" === getAssociationType(arg1.associationId);
}
function assertValidEnumTypes(functionName, arg1, arg2) {
  const enumUniverse1 = isEnumAttribute(arg1) ? getEnumUniverse(arg1.attributeId) : void 0, enumUniverse2 = isEnumAttribute(arg2) ? getEnumUniverse(arg2.attributeId) : void 0;
  if (void 0 === enumUniverse1 && void 0 === enumUniverse2)
    return;
  if (void 0 !== enumUniverse1 && void 0 !== enumUniverse2) {
    if (!deepEqual(enumUniverse1, enumUniverse2)) {
      const universe1 = `[${enumUniverse1.join(", ")}]`, universe2 = `[${enumUniverse2.join(", ")}]`;
      throw new AssertionError(`Arguments of function "${functionName}" are incompatible enum attributes (${universe1} != ${universe2}).`);
    }
    return;
  }
  const enumUniverse = enumUniverse1 ?? enumUniverse2;
  function checkEnumLiteral(index, arg) {
    if ("literal" !== arg.type)
      return;
    const literalValue = arg.value;
    if (void 0 !== literalValue && !enumUniverse.includes(literalValue)) {
      const universe = `[${enumUniverse.join(", ")}]`;
      throw new AssertionError(`Argument #${index} of function "${functionName}" has an invalid enum literal value (${literalValue} != ${universe}).`);
    }
  }
  checkEnumLiteral(0, arg1), checkEnumLiteral(1, arg2);
}
function assertExpectedType(functionName, index, actual, expected) {
  if (0 !== expected.length && !expected.includes(actual)) {
    const expectedString = 1 === expected.length ? expected[0] : `[${expected.join(", ")}]`;
    throw new AssertionError(`Argument #${index} of function "${functionName}" has an incompatible type (${actual} != ${expectedString}).`);
  }
}
function getValueType(expression) {
  switch (expression.type) {
    case "attribute":
      return function(attributeId) {
        const attributeType = getAttributeType(attributeId);
        switch (attributeType) {
          case "Boolean":
            return "boolean";
          case "DateTime":
            return "DateTime";
          case "AutoNumber":
          case "Integer":
          case "Long":
          case "Decimal":
            return "Numeric";
          case "Enum":
          case "String":
          case "HashString":
            return "string";
          case "Binary":
          case "EnumSet":
          case "ObjectReference":
          case "ObjectReferenceSet":
            throw new AssertionError("Unsupported attribute type: " + attributeType);
        }
      }(expression.attributeId);
    case "literal":
      return expression.valueType;
    case "association":
      return getAssociationType(expression.associationId);
  }
}
function getSelectableObjectsId(expression) {
  switch (expression.type) {
    case "attribute":
      return;
    case "literal":
      return expression[dataSourceIdSymbol$1];
    case "association":
      return getAssociationInfoById(expression.associationId)?.selectableObjectsId;
  }
}
function getAttributeType(attributeId) {
  return ensure(getAttributeTypeById(attributeId));
}
function getAssociationType(associationId) {
  return ensure(getAssociationTypeById(associationId));
}
function isEnumAttribute(arg) {
  return "attribute" === arg.type && "Enum" === getAttributeType(arg.attributeId);
}
function getEnumUniverse(attributeId) {
  return ensure(getEnumUniverseById(attributeId));
}

const pageScope = "$$globalScope";

const knownEnumerations = /* @__PURE__ */ new Map();
function addEnumerations(enumerations) {
  Object.entries(enumerations).forEach(([e, enumerationValue]) => {
    knownEnumerations.has(e) || knownEnumerations.set(e, enumerationValue);
  });
}
function translateEnumeration(enumeration, value) {
  const knownOption = ensure(knownEnumerations.get(enumeration)).find(([option]) => option === value);
  return knownOption ? knownOption[1] : value;
}
function getEnumerationOptions(enumeration) {
  return ensure(knownEnumerations.get(enumeration)).map(([option]) => option);
}
function clientToAttributeValue(value, type) {
  switch (type) {
    case "DateTime":
      return "" !== value ? new Date(value) : void 0;
    case "AutoNumber":
      return new Big(value);
    case "String":
      return value;
    default:
      return "" !== value ? value : void 0;
  }
}
function attributeToClientValue(value) {
  return void 0 === value ? "" : value instanceof Date ? value.getTime() : value;
}
function runtimeValueToAttributeValue(runtimeValue, type) {
  return clientToAttributeValue(runtimeValueToClientValue(runtimeValue, type), type);
}
function attributeValueToRuntimeValue(attributeValue) {
  return clientToRuntimeValue(attributeToClientValue(attributeValue));
}
function runtimeValueToClientValue(value, type) {
  if (null == value)
    return "";
  switch (type) {
    case "Integer":
    case "Long":
    case "Decimal":
      return new Big(value);
    case "Date":
    case "DateTime":
      return value;
    case "Boolean":
      return Boolean(value);
    case "ObjectReferenceSet":
      return Array.isArray(value) && value.length > 0 ? value : "";
    default:
      return String(value);
  }
}
function assertIsAttributeValue(value, entity, attribute) {
  const type = getAttributeType$1(entity, attribute);
  if (!type)
    throw new AssertionError(`Attribute ${attribute} is not accessible.`);
  "Enum" === type ? function(condition) {
    if (!condition)
      throw new AssertionError(`Value ${value} is not assignable to attribute of type ${type}.`);
  }(void 0 === value || "string" == typeof value && getEnumerationOptions(getAttributeEnumerationType(entity, attribute)).includes(value)) : assertIsNonEnumValue(value, type);
}
function assertIsVariableValue(value, type, enumerationId) {
  if (!type)
    throw new AssertionError("Value type is not valid.");
  "Enum" === type ? function(condition) {
    if (!condition)
      throw new AssertionError(`Value ${value} is not assignable to variable of type ${type}.`);
  }(void 0 === value || "string" == typeof value && !!enumerationId && getEnumerationOptions(enumerationId).includes(value)) : assertIsNonEnumValue(value, type, false, "Variable");
}
function assertIsNonEnumValue(value, type, allowUndefinedRefSets = false, assertionValueType = "Attribute") {
  switch (type) {
    case "String":
    case "ObjectReference":
    case "HashString":
      return assertIs("string" == typeof value || void 0 === value);
    case "ObjectReferenceSet":
      return assertIs(Array.isArray(value) && value.every((v) => "string" == typeof v) || void 0 === value && allowUndefinedRefSets);
    case "Boolean":
      return assertIs("boolean" == typeof value);
    case "DateTime":
      return assertIs(void 0 === value || value instanceof Date && !isNaN(value.getTime()));
    case "Integer":
    case "Long":
    case "Decimal":
      return assertIs(value instanceof Big || void 0 === value);
    default:
      throw new AssertionError(`${assertionValueType} type ${type} is not supported.`);
  }
  function assertIs(condition) {
    if (!condition)
      throw new AssertionError(`Value '${value}' is not assignable to ${assertionValueType.toLowerCase()} of type ${type}.`);
  }
}
function clientToRuntimeValue(value, keepEmptyStringValue = false) {
  return "" === value ? keepEmptyStringValue ? "" : null : value instanceof Big ? value.toString() : value;
}
function anyToClientValue(value, type) {
  if (null == value || "" === value)
    return "ObjectReferenceSet" === type ? [] : "";
  switch (type) {
    case "Boolean":
      return Boolean(value);
    case "Decimal":
    case "Integer":
    case "Long":
      return new Big(value);
    case "DateTime":
      return Number(value);
    case "ObjectReference":
      if (Array.isArray(value))
        throw new Error("Trying to set single object reference to multiple values");
      return value.toString();
    case "ObjectReferenceSet":
      if (!Array.isArray(value))
        throw new Error("Trying to set object reference set to single value");
      return value.map((guid) => guid.toString());
    default:
      return String(value);
  }
}
function assertIsPositiveInteger(value) {
  if ("number" == typeof value && value >= 0 && Math.floor(value) === value)
    return true;
  throw new AssertionError(`Value ${value} should be a positive integer.`);
}
function assertIsBoolean(value) {
  if ("boolean" == typeof value)
    return true;
  throw new AssertionError(`Value ${value} should be a boolean.`);
}
function runtimeValueToArgument(value, type) {
  if ("" !== value && null != value)
    return Array.isArray(value) ? value.length ? { guids: value } : void 0 : "ObjectReference" === type ? { guid: "string" == typeof value ? value : crash() } : { value };
}
function attributeValueToActionArgument(value, kind) {
  switch (kind) {
    case "object":
      return { id: value };
    case "list":
      return { ids: value };
    case "primitive":
      return { primitive: value };
  }
}
function actionArgumentToWidgetVariable(actionArgument) {
  if (actionArgument)
    return "object" in actionArgument ? available(actionArgument.object) : "id" in actionArgument ? actionArgument.id : "ids" in actionArgument ? actionArgument.ids : "primitive" in actionArgument ? actionArgument.primitive : crash();
}
function attributeValueToRuntimeArgument(value, kind) {
  switch (kind) {
    case "object":
      return { guid: value };
    case "list":
      return { guids: value };
    case "primitive":
      return { value: attributeValueToRuntimeValue(value) };
  }
}

function mapObject(obj, func, scope = null) {
  return Object.keys(obj).reduce(function(acc, key) {
    return acc[key] = func.call(scope, obj[key], key), acc;
  }, {});
}
function objectFromArray(arr) {
  return arr.reduce(function(acc, pair) {
    return acc[pair[0]] = pair[1], acc;
  }, {});
}
function objectIsEmpty(obj) {
  for (var i in obj)
    return false;
  return true;
}
function getFileError(doc) {
  var area, json, error = null;
  return (area = doc.getElementsByTagName("textarea")[0]) && (json = JSON.parse(area.value)).type && "exception" === json.type && ((error = new DescribedServerError(json.description))._type = "exception"), error;
}
var DECIMAL_TOO_BIG = new Big("1e20"), INT_MIN = new Big(2).pow(31).times(-1), INT_MAX = new Big(2).pow(31).minus(1), LONG_MIN = new Big(2).pow(63).times(-1), LONG_MAX = new Big(2).pow(63).minus(1);
function checkRange(value, min, max) {
  return value.gte(min) && value.lte(max);
}
const validation = { OK: 0, NOT_INTEGER: 1, RANGE_INTEGER: 2, RANGE_LONG: 3, RANGE_DECIMAL: 4 };
function validate(value, type) {
  if (/^(Integer|Long|Decimal)$/.test(type)) {
    if ("" === value || null === value)
      return validation.OK;
    if (value instanceof Big || (value = new Big(value)), ("Integer" === type || "Long" === type) && function(value2) {
      return !value2.mod(1).eq(0);
    }(value))
      return validation.NOT_INTEGER;
    if ("Integer" === type && !checkRange(value, INT_MIN, INT_MAX))
      return validation.RANGE_INTEGER;
    if ("Long" === type && !checkRange(value, LONG_MIN, LONG_MAX))
      return validation.RANGE_LONG;
    if ("Decimal" === type && value.abs().gte(DECIMAL_TOO_BIG))
      return validation.RANGE_DECIMAL;
    if ("Decimal" === type && !value.mod(1e-8).eq(0))
      return validation.RANGE_DECIMAL;
  }
  return validation.OK;
}
function localizeDate(date) {
  const newDate = /* @__PURE__ */ new Date();
  return newDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()), newDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()), newDate;
}
function delocalizeDate(date) {
  const newDate = /* @__PURE__ */ new Date();
  return newDate.setUTCFullYear(date.getFullYear(), date.getMonth(), date.getDate()), newDate.setUTCHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()), newDate;
}
var _a;
const snapshot = Symbol("snapshot"), publishLock = Symbol("publishLock");
class MxObject {
  get jsonData() {
    return this._jsonData;
  }
  constructor(kwArgs) {
    this.publishQueue = [], this[_a] = 0, this._guid = "0", this._unavailable = false, this.id = "mendix.lib.MxObject";
    const untrustedArgs = kwArgs, objectType = untrustedArgs.json?.objectType;
    if (!untrustedArgs.meta || !objectType)
      throw new AssertionError(`new MxObject(): cannot create Mendix object. Check entity access for entity ${objectType}`);
    this.metaData = kwArgs.meta, this._isPartial = kwArgs.isPartial ?? false, this._jsonData = kwArgs.json, this._updateFromJsonData(), this.id += "(" + objectType + ":" + this._guid + ")", this._partialTreeId = this._isPartial ? kwArgs.partialTreeId ?? newId("partial") : void 0;
  }
  resetFromJSON(json) {
    this._jsonData = json, this._updateFromJsonData();
  }
  markAsUnavailable() {
    this._jsonData = { guid: this._guid, attributes: {} }, this._updateFromJsonData(), this._unavailable = true;
  }
  _updateFromJsonData() {
    this._guid = this._jsonData.guid;
    for (const key in this._jsonData.attributes) {
      const attr = key;
      this._setAttributeValue(attr, this._getAttributeValue(attr));
    }
  }
  getGuid() {
    return this._guid;
  }
  hasChanges() {
    return !objectIsEmpty(getData().getChanges(this._guid));
  }
  snapshot() {
    return this[snapshot] ?? (this[snapshot] = new MxObjectSnapshot(this));
  }
  isUnavailable() {
    return this._unavailable;
  }
  isPartial() {
    return this._isPartial;
  }
  set(attr, value) {
    this._setContent(attr, value);
  }
  set2(attr, value) {
    this._setContent(attr, attributeToClientValue(value));
  }
  isReadonlyAttr(attr) {
    if (this.has(attr)) {
      const value = this._jsonData.attributes[attr];
      return !(!value || !("readonly" in value)) && value.readonly;
    }
    {
      const attrMeta = this.metaData.attributes[attr];
      return void 0 === attrMeta || attrMeta.isAlwaysReadOnly;
    }
  }
  fetch(path, callback, error) {
    let pathComponents;
    pathComponents = path ? path instanceof Array ? path.slice() : path.split("/") : [], this.isA(pathComponents[0]) && pathComponents.shift();
    let obj = this;
    const performFetch = () => {
      if (0 === pathComponents.length)
        callback(obj);
      else if (1 === pathComponents.length)
        callback(obj.get(pathComponents[0]));
      else {
        const ref = pathComponents.shift(), entity = pathComponents.shift();
        obj._fetchReference(ref, entity, (result) => {
          void 0 === result ? callback(null) : Array.isArray(result) ? 0 === pathComponents.length ? callback(result) : handleError$1(new AssertionError(`${this.id}.fetch : ${obj} reference set should be last reference in path`)) : (obj = result, performFetch());
        }, handleError$1);
      }
    };
    function handleError$1(e) {
      error ? error(e) : handleError(e);
    }
    performFetch();
  }
  _fetchReference(attr, entity, callback, error) {
    const references = this.getReferences(attr);
    0 !== references.length ? getData().get({ guids: references, callback: (objs) => {
      if (this.isObjectReferenceSet(attr))
        0 === objs.length || objs[0].isA(entity) ? callback(objs) : callback(void 0);
      else {
        const obj = objs[0];
        obj?.isA(entity) ? callback(obj) : callback(void 0);
      }
    }, error }) : callback(void 0);
  }
  get(attr) {
    if ("string" != typeof attr)
      throw new AssertionError(`parameter attr ${attr} is not of type String`);
    return this.has(attr) ? this._convertToClientValue(attr, this.getRawValue(attr)) : null;
  }
  get2(attr) {
    if ("string" != typeof attr)
      throw new AssertionError(`parameter attr ${attr} is not of type String`);
    return clientToAttributeValue(this.has(attr) ? this._convertToClientValue(attr, this.getRawValue(attr)) : null, this.getAttributeType(attr));
  }
  getOriginalValue(attr) {
    if ("string" != typeof attr)
      throw new AssertionError(`parameter attr ${attr} is not of type String`);
    return this.has(attr) ? this._convertToClientValue(attr, this._getRawOriginalValue(attr)) : null;
  }
  has(attr) {
    if ("string" != typeof attr)
      throw new AssertionError("attribute parameter is not a string");
    return hasKey(this._jsonData.attributes, attr);
  }
  getReferences(attr) {
    if ("string" != typeof attr)
      throw new AssertionError(`parameter attr ${attr} is not of type String.`);
    if (!this.has(attr))
      return [];
    if (!this.isReference(attr))
      throw new AssertionError("attribute " + attr + " is not an ObjectReference(Set).");
    const ref = this.getRawValue(attr);
    return this.isObjectReference(attr) ? null == ref ? [] : [ref] : null == ref ? [] : ref.slice();
  }
  getOriginalReferences(attr) {
    if ("string" != typeof attr)
      throw new AssertionError(`parameter attr ${attr} is not of type String.`);
    if (!this.has(attr))
      return [];
    if (!this.isReference(attr))
      throw new AssertionError("attribute " + attr + " is not an ObjectReference(Set).");
    const ref = this._getRawOriginalValue(attr);
    return this.isObjectReference(attr) ? null == ref ? [] : [ref] : null == ref ? [] : ref.slice();
  }
  getReference(attr) {
    return this.get(attr);
  }
  isEnum(attr) {
    return "Enum" === this.metaData.attributes[attr]?.type;
  }
  isNumeric(attr) {
    return isNumericType(this.metaData.attributes[attr]?.type);
  }
  isPassword(attr) {
    return "HashString" === this.metaData.attributes[attr]?.type;
  }
  isDate(attr) {
    return "DateTime" === this.metaData.attributes[attr]?.type;
  }
  isLocalizedDate(attr) {
    return Boolean(this.metaData.attributes[attr]?.isDateLocalized);
  }
  isBoolean(attr) {
    return "Boolean" === this.metaData.attributes[attr]?.type;
  }
  isReference(attr) {
    return isReferenceType(this.metaData.attributes[attr]?.type);
  }
  isObjectReference(attr) {
    return "ObjectReference" === this.metaData.attributes[attr]?.type;
  }
  isObjectReferenceSet(attr) {
    return "ObjectReferenceSet" === this.metaData.attributes[attr]?.type;
  }
  hasChildren(attr) {
    if ("string" != typeof attr)
      throw new AssertionError(`parameter attr (${attr}) is not of type String.`);
    return !this._attributeChanged(attr) && this._hasChildren(attr);
  }
  getChildren(attr) {
    if ("string" != typeof attr)
      throw new AssertionError(`parameter attr (${attr}) is not of type String.`);
    if (!this.has(attr))
      return [];
    if (!this.isReference(attr))
      throw new AssertionError(`attribute ${attr} is not an ObjectReference(Set).`);
    return this._attributeChanged(attr) ? [] : this._hasChildren(attr) ? this._getChildren(attr) : [];
  }
  getChild(attr) {
    if ("string" != typeof attr)
      throw new AssertionError(`parameter attr(${attr}) is not of type String.`);
    if (!this.has(attr))
      return;
    if (!this.isObjectReference(attr))
      throw new AssertionError("attribute " + attr + " is not an ObjectReference.");
    const children = this.getChildren(attr);
    return 0 === children.length ? null : children[0];
  }
  removeReferences(attr, guidsArg) {
    if ("string" != typeof attr)
      throw new AssertionError("parameter attr is not of type String.");
    if (!this.has(attr))
      return false;
    if (!this.isReference(attr))
      throw new AssertionError("attempt to remove Reference from non-Reference attribute : " + attr);
    const guids = Array.isArray(guidsArg) ? guidsArg : [guidsArg];
    if (this._attributeChanged(attr) || !this._hasChildren(attr))
      this.isObjectReference(attr) ? this._setContent(attr, null) : this._setContent(attr, arraySubtract(this.getReferences(attr), guids));
    else {
      if (!this.isObjectReference(attr)) {
        const attribute = this._jsonData.attributes[attr], value = attribute && "value" in attribute ? attribute.value : attribute;
        for (const guid of guids)
          delete value[guid];
        const val = arraySubtract(this.getReferences(attr), guids);
        return this._makeChange(attr, val);
      }
      this._setContent(attr, null);
    }
    return true;
  }
  addReference(attr, guid) {
    if ("string" != typeof attr)
      throw new AssertionError("parameter attr is not of type String.");
    if (!guid)
      throw new AssertionError("parameter guid is not set.");
    if (!this.has(attr))
      return false;
    if (!this.isReference(attr))
      throw new AssertionError("attempt to add Reference to non-Reference attribute : " + attr);
    if (this.isObjectReference(attr))
      this._setContent(attr, guid);
    else {
      const guids = this.getReferences(attr);
      guids.join(";").match(guid) || (guids.push(guid), this._setContent(attr, guids));
    }
    return true;
  }
  addReferences(attr, guids) {
    if ("string" != typeof attr)
      throw new AssertionError("parameter attr is not of type String.");
    if (!Array.isArray(guids))
      throw new AssertionError("parameter guids is not an Array.");
    if (!this.has(attr))
      return false;
    if (!this.isObjectReferenceSet(attr))
      throw new AssertionError("attempt to add References to non-ReferenceSet attribute : " + attr);
    const currentGuids = this.getReferences(attr), guidsToAdd = guids.filter((guid) => !currentGuids.includes(guid));
    return guidsToAdd.length > 0 && this._setContent(attr, currentGuids.concat(guidsToAdd)), true;
  }
  getReferenceAttributes() {
    return Object.values(this.metaData.attributes).filter((attrMeta) => isReferenceType(attrMeta.type) && this.has(attrMeta.name)).map((attrMeta) => attrMeta.name);
  }
  getAttributes() {
    return Object.values(this.metaData.attributes).filter((attrMeta) => this.has(attrMeta.name)).map((attrMeta) => attrMeta.name);
  }
  getPrimitives() {
    return Object.values(this.metaData.attributes).filter((attrMeta) => !isReferenceType(attrMeta.type) && this.has(attrMeta.name)).map((attrMeta) => attrMeta.name);
  }
  getAttributeType(attr) {
    return !!this.has(attr) && this.metaData.attributes[attr].type;
  }
  getSelectorEntity(attr) {
    return this.has(attr) ? this.metaData.attributes[attr]?.referenceEntity ?? false : null;
  }
  getEntity() {
    return this.metaData.name;
  }
  isPersistable() {
    return this.metaData.isPersistable;
  }
  isRemoteFileEntity() {
    return !!this.metaData.isRemoteFileEntity;
  }
  isNew() {
    return getData().isNew(this._guid);
  }
  isA(classname) {
    return isEntityA(this.metaData.name, classname);
  }
  hasSuperEntities() {
    return this.metaData.generalizations.length > 0;
  }
  getSuperEntities() {
    return this.metaData.generalizations;
  }
  hasSubEntities() {
    return this.metaData.specializations.length > 0;
  }
  getSubEntities() {
    return this.metaData.specializations;
  }
  inheritsFrom(className) {
    return this.metaData.generalizations.includes(className);
  }
  toJSON() {
    return this._jsonData;
  }
  toString() {
    return this._partialTreeId ? `${this.getGuid()}_${this._partialTreeId}` : this.getGuid();
  }
  getRawValue(attr) {
    const objectChanges = getData().getChanges(this._guid);
    return Object.prototype.hasOwnProperty.call(objectChanges, attr) ? objectChanges[attr].value : this._getRawOriginalValue(attr);
  }
  _getRawOriginalValue(attr) {
    return this._hasChildren(attr) ? this._getChildValue(attr) : this._getAttributeValue(attr);
  }
  _attributeChanged(attr) {
    const changes = getData().getChanges(this._guid);
    return Object.prototype.hasOwnProperty.call(changes, attr);
  }
  _getChildren(attr) {
    return (this.isObjectReference(attr) ? [this._getAttributeValue(attr)] : Object.values(this._getAttributeValue(attr))).map((json) => MxObject.fromJson(json, true, this._partialTreeId));
  }
  _getChildValue(attr) {
    const guids = this._getChildren(attr).map((child) => child.getGuid());
    return this.isObjectReference(attr) ? 0 === guids.length ? null : guids[0] : guids;
  }
  _convertToRuntimeValue(attr, value) {
    const attributeType = this.getAttributeType(attr), clientValue = anyToClientValue(value, attributeType), runtimeValue = clientToRuntimeValue(clientValue, "String" === attributeType && "" === value);
    if (this.isNumeric(attr) && validate(runtimeValue, attributeType) !== validation.OK)
      throw new Error(`Cannot set invalid value '${value}' to MxObject attribute '${attr}'`);
    return this.isDate(attr) && !this.isLocalizedDate(attr) && "number" == typeof runtimeValue ? delocalizeDate(new Date(runtimeValue)).getTime() : this.isPassword(attr) ? value.replace(/[\s\t]+$/, "").replace(/^[\s\t]+/, "") : runtimeValue;
  }
  _convertToClientValue(attr, value) {
    if ("string" != typeof attr)
      throw new Error("mendix/lib/MxMetaObject.isDate : parameter attr is not of type String.");
    const preConverted = runtimeValueToClientValue(value, this.metaData.attributes[attr]?.type);
    return this.isDate(attr) && "" !== preConverted ? this.isLocalizedDate(attr) ? preConverted : localizeDate(new Date(preConverted)).getTime() : preConverted;
  }
  _setContent(attr, value) {
    if ("string" != typeof attr)
      throw new AssertionError(`parameter attr (${attr}) is not of type String.`);
    if (!hasKey(this.metaData.attributes, attr))
      return;
    const newValue = this._convertToRuntimeValue(attr, value), oldValue = this.getRawValue(attr);
    if (newValue !== oldValue) {
      const releaseLock = this.lockPublish();
      this._makeChange(attr, newValue), this.metaData.attributes[attr]?.isBidiReference && (getObjects(this.isObjectReference(attr) ? [oldValue] : arraySubtract(oldValue, newValue)).filter((mxObj) => !mxObj.isReadonlyAttr(attr) && mxObj.getReferences(attr).includes(this._guid)).forEach((mxObj) => mxObj.removeReferences(attr, [this._guid])), getObjects(this.isObjectReference(attr) ? [newValue] : arraySubtract(newValue, oldValue)).filter((mxObj) => !mxObj.isReadonlyAttr(attr) && !mxObj.getReferences(attr).includes(this._guid)).forEach((mxObj) => mxObj.addReference(attr, this._guid))), releaseLock().catch(handleError);
    }
  }
  _hasChildren(attr) {
    if (!this.isReference(attr))
      return false;
    const value = this._getAttributeValue(attr);
    return null !== value && "object" == typeof value && !Array.isArray(value);
  }
  _getAttributeValue(attr) {
    const val = this._jsonData.attributes[attr] ?? null;
    return val && "value" in val ? val.value : val;
  }
  _setAttributeValue(attr, value) {
    const val = this._jsonData.attributes[attr];
    void 0 === value && (value = null), val && "value" in val ? val.value = value : this._jsonData.attributes[attr] = value;
  }
  _makeChange(attr, value) {
    if (this.isUnavailable())
      throw new AssertionError(`Cannot modify attribute ${attr} of an unavailable object.`);
    getData().makeChange(this._guid, attr, value), this.publish({ guid: this._guid, attr }).catch(handleError);
  }
  lockPublish() {
    return this[publishLock]++, async () => {
      this[publishLock]--, await this.processPublishQueue();
    };
  }
  async publish(message) {
    this.publishQueue.push(message), await this.processPublishQueue();
  }
  async processPublishQueue() {
    if (0 !== this[publishLock])
      return;
    const messages = this.publishQueue.splice(0);
    await publish(...messages);
  }
  static fromJson(json, isPartial = false, partialTreeId) {
    return new MxObject({ json, meta: getEntityMeta(json.objectType), isPartial, partialTreeId });
  }
}
function getObjects(guids) {
  return guids.map((guid) => getData().getCachedObject(guid)).filter((mxObject) => null != mxObject);
}
function arraySubtract(lhs, rhs) {
  return lhs.filter((item) => !rhs.includes(item));
}
_a = publishLock;
class MxObjectSnapshot extends MxObject {
  constructor(mxObject) {
    super({ meta: mxObject.metaData, json: { guid: mxObject.getGuid(), objectType: mxObject.getEntity() } }), this._mxObject = mxObject, this.isSnapshot = true;
  }
  resetFromJSON(json) {
    super.resetFromJSON(json), this._mxObject.resetFromJSON(json);
  }
  markAsUnavailable() {
    super.markAsUnavailable(), this._mxObject.markAsUnavailable();
  }
  hasChanges() {
    return false;
  }
  snapshot() {
    return this;
  }
  isReadonlyAttr(_attr) {
    return true;
  }
  isPartial() {
    return this._mxObject.isPartial();
  }
  toString() {
    return this._mxObject.toString();
  }
  _fetchReference(attr, entity, callback, error) {
    super._fetchReference(attr, entity, (result) => {
      result instanceof MxObject ? callback(result.snapshot()) : Array.isArray(result) ? callback(result.map((mxobj) => mxobj.snapshot())) : callback(result);
    }, error);
  }
  has(attr) {
    return this._mxObject.has(attr);
  }
  toJSON() {
    return this._mxObject.toJSON();
  }
  _attributeChanged(_attr) {
    return false;
  }
  getRawValue(attr) {
    return this._mxObject._getRawOriginalValue(attr);
  }
  _getAttributeValue(attr) {
    return this._mxObject._getAttributeValue(attr);
  }
  _makeChange(attr) {
    throw new AssertionError(`Cannot modify attribute ${attr} of a read-only object.`);
  }
  _getChildren(attr) {
    return this._mxObject._getChildren(attr).map((mxobj) => mxobj.snapshot());
  }
  convertToEditable() {
    return getData().removeChanges(this.getGuid()), this._mxObject;
  }
}

function _typeof(o) {
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function toInteger(dirtyNumber) {
  if (null === dirtyNumber || true === dirtyNumber || false === dirtyNumber)
    return NaN;
  var number = Number(dirtyNumber);
  return isNaN(number) ? number : number < 0 ? Math.ceil(number) : Math.floor(number);
}
function requiredArgs(required, args) {
  if (args.length < required)
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  return argument instanceof Date || "object" === _typeof(argument) && "[object Date]" === argStr ? new Date(argument.getTime()) : "number" == typeof argument || "[object Number]" === argStr ? new Date(argument) : ("string" != typeof argument && "[object String]" !== argStr || "undefined" == typeof console || (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), /* @__PURE__ */ new Date(NaN));
}

var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function startOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions(), weekStartsOn = toInteger(null !== (_ref = null !== (_ref2 = null !== (_ref3 = null !== (_options$weekStartsOn = null == options ? void 0 : options.weekStartsOn) && void 0 !== _options$weekStartsOn ? _options$weekStartsOn : null == options || null === (_options$locale = options.locale) || void 0 === _options$locale || null === (_options$locale$optio = _options$locale.options) || void 0 === _options$locale$optio ? void 0 : _options$locale$optio.weekStartsOn) && void 0 !== _ref3 ? _ref3 : defaultOptions2.weekStartsOn) && void 0 !== _ref2 ? _ref2 : null === (_defaultOptions$local = defaultOptions2.locale) || void 0 === _defaultOptions$local || null === (_defaultOptions$local2 = _defaultOptions$local.options) || void 0 === _defaultOptions$local2 ? void 0 : _defaultOptions$local2.weekStartsOn) && void 0 !== _ref ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var date = toDate(dirtyDate), day = date.getDay(), diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  return date.setDate(date.getDate() - diff), date.setHours(0, 0, 0, 0), date;
}

function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate), amount = toInteger(dirtyAmount);
  return isNaN(amount) ? /* @__PURE__ */ new Date(NaN) : amount ? (date.setDate(date.getDate() + amount), date) : date;
}
function subDays(dirtyDate, dirtyAmount) {
  return requiredArgs(2, arguments), addDays(dirtyDate, -toInteger(dirtyAmount));
}

function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return date.setHours(0, 0, 0, 0), date;
}
function endOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return date.setHours(23, 59, 59, 999), date;
}
function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate), month = date.getMonth();
  return date.setFullYear(date.getFullYear(), month + 1, 0), date.setHours(23, 59, 59, 999), date;
}
function startOfMinute(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return date.setSeconds(0, 0), date;
}
function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return date.setDate(1), date.setHours(0, 0, 0, 0), date;
}
function endOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate), year = date.getFullYear();
  return date.setFullYear(year + 1, 0, 0), date.setHours(23, 59, 59, 999), date;
}
function startOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var cleanDate = toDate(dirtyDate), date = /* @__PURE__ */ new Date(0);
  return date.setFullYear(cleanDate.getFullYear(), 0, 1), date.setHours(0, 0, 0, 0), date;
}
function endOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions(), weekStartsOn = toInteger(null !== (_ref = null !== (_ref2 = null !== (_ref3 = null !== (_options$weekStartsOn = null == options ? void 0 : options.weekStartsOn) && void 0 !== _options$weekStartsOn ? _options$weekStartsOn : null == options || null === (_options$locale = options.locale) || void 0 === _options$locale || null === (_options$locale$optio = _options$locale.options) || void 0 === _options$locale$optio ? void 0 : _options$locale$optio.weekStartsOn) && void 0 !== _ref3 ? _ref3 : defaultOptions.weekStartsOn) && void 0 !== _ref2 ? _ref2 : null === (_defaultOptions$local = defaultOptions.locale) || void 0 === _defaultOptions$local || null === (_defaultOptions$local2 = _defaultOptions$local.options) || void 0 === _defaultOptions$local2 ? void 0 : _defaultOptions$local2.weekStartsOn) && void 0 !== _ref ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var date = toDate(dirtyDate), day = date.getDay(), diff = 6 + (day < weekStartsOn ? -7 : 0) - (day - weekStartsOn);
  return date.setDate(date.getDate() + diff), date.setHours(23, 59, 59, 999), date;
}
function startOfHour(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return date.setMinutes(0, 0, 0), date;
}
function runtimeValueToExpressionVariable(runtimeValue, type, getObject) {
  return function(value, type2, getObject2) {
    switch (type2) {
      case "ObjectReferenceSet":
        return Array.isArray(value) ? value.map((guid) => getObject2(guid)) : new Array();
      case "ObjectReference":
        return void 0 !== value ? getObject2(value) : void 0;
      default:
        return value;
    }
  }(runtimeValueToAttributeValue(runtimeValue, type), type, getObject);
}
function expressionVariableToRuntimeValue(value) {
  const attributeValue = expressionVariableToAttributeValue(value), clientValue = attributeToClientValue(attributeValue);
  return clientToRuntimeValue(clientValue, "" === value);
}
function expressionVariableToAttributeValue(value) {
  return isArrayOf(MxObject, value) ? value.map((obj) => obj.getGuid()) : value instanceof MxObject ? value.getGuid() : value;
}
function anyToExpressionVariable(value) {
  switch (typeof value) {
    case "undefined":
    case "string":
    case "boolean":
      return value;
    case "number":
      return new Big(value);
    default:
      if (value instanceof Big || value instanceof Date || value instanceof MxObject)
        return value;
      if (null === value)
        return;
      if (Array.isArray(value)) {
        if (value.every((elem) => elem instanceof MxObject))
          return value;
        throw new AssertionError(`Array ${value.join(", ")} cannot be used as Nanoflow variable, because it contains something else then MxObjects.`);
      }
      throw new AssertionError(`Value ${value} cannot be used as Nanoflow variable.`);
  }
}
function actionArgumentToExpressionVariable(argument) {
  if (argument) {
    if ("object" in argument)
      return argument.object;
    if ("objects" in argument)
      return argument.objects;
    throw new AssertionError();
  }
}
function expressionVariableToRuntimeArgument(value) {
  if (void 0 !== value)
    return isMxObjectArray(value) ? { guids: value.map((o) => o.getGuid()) } : value instanceof MxObject ? { guid: value.getGuid() } : { value: expressionVariableToRuntimeValue(value) };
}
function toRuntimeArgument(object, attribute) {
  return runtimeValueToArgument(object.getRawValue(attribute), object.getAttributeType(attribute));
}
function isMxObjectArray(variable) {
  return Array.isArray(variable) && variable.every((e) => e instanceof MxObject);
}
function addDaysExtended(func, amount) {
  return (date, options) => addDays(func(date, options), amount);
}
function subDaysExtended(func, amount) {
  return (date, options) => subDays(func(date, options), amount);
}
const funcMap = { beginOfCurrentMinute: startOfMinute, endOfCurrentMinute: function(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return date.setSeconds(59, 999), date;
}, beginOfCurrentHour: startOfHour, endOfCurrentHour: function(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return date.setMinutes(59, 59, 999), date;
}, beginOfCurrentDay: startOfDay, endOfCurrentDay: endOfDay, beginOfCurrentWeek: startOfWeek, endOfCurrentWeek: endOfWeek, beginOfCurrentMonth: startOfMonth, endOfCurrentMonth: endOfMonth, beginOfCurrentYear: startOfYear, endOfCurrentYear: endOfYear, beginOfYesterday: subDaysExtended(startOfDay, 1), endOfYesterday: subDaysExtended(endOfDay, 1), beginOfTomorrow: addDaysExtended(startOfDay, 1), endOfTomorrow: addDaysExtended(endOfDay, 1) };
function createExpressionTokens(getNow) {
  const tokensCollection = { currentUser: () => getSession().getUserId(), currentDateTime: getNow };
  return Object.entries(funcMap).forEach(([exposedName, func]) => {
    tokensCollection[exposedName] = () => func(getNow(), { locale: getDateFnsLocale() }), tokensCollection[exposedName + "UTC"] = () => delocalizeDate(func(localizeDate(getNow())));
  }), tokensCollection;
}

function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime(), amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  return utcDate.setUTCFullYear(date.getFullYear()), date.getTime() - utcDate.getTime();
}
function isValid(dirtyDate) {
  if (requiredArgs(1, arguments), !function(value) {
    return requiredArgs(1, arguments), value instanceof Date || "object" === _typeof(value) && "[object Date]" === Object.prototype.toString.call(value);
  }(dirtyDate) && "number" != typeof dirtyDate)
    return false;
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
function subMilliseconds(dirtyDate, dirtyAmount) {
  return requiredArgs(2, arguments), addMilliseconds(dirtyDate, -toInteger(dirtyAmount));
}
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate), day = date.getUTCDay(), diff = (day < 1 ? 7 : 0) + day - 1;
  return date.setUTCDate(date.getUTCDate() - diff), date.setUTCHours(0, 0, 0, 0), date;
}
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate), year = date.getUTCFullYear(), fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4), fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear), fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4), fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  return date.getTime() >= startOfNextYear.getTime() ? year + 1 : date.getTime() >= startOfThisYear.getTime() ? year : year - 1;
}
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate), diff = startOfUTCISOWeek(date).getTime() - function(dirtyDate2) {
    requiredArgs(1, arguments);
    var year = getUTCISOWeekYear(dirtyDate2), fourthOfJanuary = /* @__PURE__ */ new Date(0);
    return fourthOfJanuary.setUTCFullYear(year, 0, 4), fourthOfJanuary.setUTCHours(0, 0, 0, 0), startOfUTCISOWeek(fourthOfJanuary);
  }(date).getTime();
  return Math.round(diff / 6048e5) + 1;
}
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions(), weekStartsOn = toInteger(null !== (_ref = null !== (_ref2 = null !== (_ref3 = null !== (_options$weekStartsOn = null == options ? void 0 : options.weekStartsOn) && void 0 !== _options$weekStartsOn ? _options$weekStartsOn : null == options || null === (_options$locale = options.locale) || void 0 === _options$locale || null === (_options$locale$optio = _options$locale.options) || void 0 === _options$locale$optio ? void 0 : _options$locale$optio.weekStartsOn) && void 0 !== _ref3 ? _ref3 : defaultOptions.weekStartsOn) && void 0 !== _ref2 ? _ref2 : null === (_defaultOptions$local = defaultOptions.locale) || void 0 === _defaultOptions$local || null === (_defaultOptions$local2 = _defaultOptions$local.options) || void 0 === _defaultOptions$local2 ? void 0 : _defaultOptions$local2.weekStartsOn) && void 0 !== _ref ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var date = toDate(dirtyDate), day = date.getUTCDay(), diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  return date.setUTCDate(date.getUTCDate() - diff), date.setUTCHours(0, 0, 0, 0), date;
}
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate), year = date.getUTCFullYear(), defaultOptions = getDefaultOptions(), firstWeekContainsDate = toInteger(null !== (_ref = null !== (_ref2 = null !== (_ref3 = null !== (_options$firstWeekCon = null == options ? void 0 : options.firstWeekContainsDate) && void 0 !== _options$firstWeekCon ? _options$firstWeekCon : null == options || null === (_options$locale = options.locale) || void 0 === _options$locale || null === (_options$locale$optio = _options$locale.options) || void 0 === _options$locale$optio ? void 0 : _options$locale$optio.firstWeekContainsDate) && void 0 !== _ref3 ? _ref3 : defaultOptions.firstWeekContainsDate) && void 0 !== _ref2 ? _ref2 : null === (_defaultOptions$local = defaultOptions.locale) || void 0 === _defaultOptions$local || null === (_defaultOptions$local2 = _defaultOptions$local.options) || void 0 === _defaultOptions$local2 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) && void 0 !== _ref ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate), firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options), firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate), firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  return date.getTime() >= startOfNextYear.getTime() ? year + 1 : date.getTime() >= startOfThisYear.getTime() ? year : year - 1;
}
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate), diff = startOfUTCWeek(date, options).getTime() - function(dirtyDate2, options2) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs(1, arguments);
    var defaultOptions = getDefaultOptions(), firstWeekContainsDate = toInteger(null !== (_ref = null !== (_ref2 = null !== (_ref3 = null !== (_options$firstWeekCon = null == options2 ? void 0 : options2.firstWeekContainsDate) && void 0 !== _options$firstWeekCon ? _options$firstWeekCon : null == options2 || null === (_options$locale = options2.locale) || void 0 === _options$locale || null === (_options$locale$optio = _options$locale.options) || void 0 === _options$locale$optio ? void 0 : _options$locale$optio.firstWeekContainsDate) && void 0 !== _ref3 ? _ref3 : defaultOptions.firstWeekContainsDate) && void 0 !== _ref2 ? _ref2 : null === (_defaultOptions$local = defaultOptions.locale) || void 0 === _defaultOptions$local || null === (_defaultOptions$local2 = _defaultOptions$local.options) || void 0 === _defaultOptions$local2 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) && void 0 !== _ref ? _ref : 1), year = getUTCWeekYear(dirtyDate2, options2), firstWeek = /* @__PURE__ */ new Date(0);
    return firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate), firstWeek.setUTCHours(0, 0, 0, 0), startOfUTCWeek(firstWeek, options2);
  }(date, options).getTime();
  return Math.round(diff / 6048e5) + 1;
}
function addLeadingZeros(number, targetLength) {
  for (var sign = number < 0 ? "-" : "", output = Math.abs(number).toString(); output.length < targetLength; )
    output = "0" + output;
  return sign + output;
}
var formatters$1_y = function(date, token) {
  var signedYear = date.getUTCFullYear(), year = signedYear > 0 ? signedYear : 1 - signedYear;
  return addLeadingZeros("yy" === token ? year % 100 : year, token.length);
}, formatters$1_M = function(date, token) {
  var month = date.getUTCMonth();
  return "M" === token ? String(month + 1) : addLeadingZeros(month + 1, 2);
}, formatters$1_d = function(date, token) {
  return addLeadingZeros(date.getUTCDate(), token.length);
}, formatters$1_h = function(date, token) {
  return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
}, formatters$1_H = function(date, token) {
  return addLeadingZeros(date.getUTCHours(), token.length);
}, formatters$1_m = function(date, token) {
  return addLeadingZeros(date.getUTCMinutes(), token.length);
}, formatters$1_s = function(date, token) {
  return addLeadingZeros(date.getUTCSeconds(), token.length);
}, formatters$1_S = function(date, token) {
  var numberOfDigits = token.length, milliseconds = date.getUTCMilliseconds();
  return addLeadingZeros(Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3)), token.length);
}, dayPeriodEnum_midnight = "midnight", dayPeriodEnum_noon = "noon", dayPeriodEnum_morning = "morning", dayPeriodEnum_afternoon = "afternoon", dayPeriodEnum_evening = "evening", dayPeriodEnum_night = "night", formatters = { G: function(date, token, localize) {
  var era = date.getUTCFullYear() > 0 ? 1 : 0;
  switch (token) {
    case "G":
    case "GG":
    case "GGG":
      return localize.era(era, { width: "abbreviated" });
    case "GGGGG":
      return localize.era(era, { width: "narrow" });
    default:
      return localize.era(era, { width: "wide" });
  }
}, y: function(date, token, localize) {
  if ("yo" === token) {
    var signedYear = date.getUTCFullYear(), year = signedYear > 0 ? signedYear : 1 - signedYear;
    return localize.ordinalNumber(year, { unit: "year" });
  }
  return formatters$1_y(date, token);
}, Y: function(date, token, localize, options) {
  var signedWeekYear = getUTCWeekYear(date, options), weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
  return "YY" === token ? addLeadingZeros(weekYear % 100, 2) : "Yo" === token ? localize.ordinalNumber(weekYear, { unit: "year" }) : addLeadingZeros(weekYear, token.length);
}, R: function(date, token) {
  return addLeadingZeros(getUTCISOWeekYear(date), token.length);
}, u: function(date, token) {
  return addLeadingZeros(date.getUTCFullYear(), token.length);
}, Q: function(date, token, localize) {
  var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
  switch (token) {
    case "Q":
      return String(quarter);
    case "QQ":
      return addLeadingZeros(quarter, 2);
    case "Qo":
      return localize.ordinalNumber(quarter, { unit: "quarter" });
    case "QQQ":
      return localize.quarter(quarter, { width: "abbreviated", context: "formatting" });
    case "QQQQQ":
      return localize.quarter(quarter, { width: "narrow", context: "formatting" });
    default:
      return localize.quarter(quarter, { width: "wide", context: "formatting" });
  }
}, q: function(date, token, localize) {
  var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
  switch (token) {
    case "q":
      return String(quarter);
    case "qq":
      return addLeadingZeros(quarter, 2);
    case "qo":
      return localize.ordinalNumber(quarter, { unit: "quarter" });
    case "qqq":
      return localize.quarter(quarter, { width: "abbreviated", context: "standalone" });
    case "qqqqq":
      return localize.quarter(quarter, { width: "narrow", context: "standalone" });
    default:
      return localize.quarter(quarter, { width: "wide", context: "standalone" });
  }
}, M: function(date, token, localize) {
  var month = date.getUTCMonth();
  switch (token) {
    case "M":
    case "MM":
      return formatters$1_M(date, token);
    case "Mo":
      return localize.ordinalNumber(month + 1, { unit: "month" });
    case "MMM":
      return localize.month(month, { width: "abbreviated", context: "formatting" });
    case "MMMMM":
      return localize.month(month, { width: "narrow", context: "formatting" });
    default:
      return localize.month(month, { width: "wide", context: "formatting" });
  }
}, L: function(date, token, localize) {
  var month = date.getUTCMonth();
  switch (token) {
    case "L":
      return String(month + 1);
    case "LL":
      return addLeadingZeros(month + 1, 2);
    case "Lo":
      return localize.ordinalNumber(month + 1, { unit: "month" });
    case "LLL":
      return localize.month(month, { width: "abbreviated", context: "standalone" });
    case "LLLLL":
      return localize.month(month, { width: "narrow", context: "standalone" });
    default:
      return localize.month(month, { width: "wide", context: "standalone" });
  }
}, w: function(date, token, localize, options) {
  var week = getUTCWeek(date, options);
  return "wo" === token ? localize.ordinalNumber(week, { unit: "week" }) : addLeadingZeros(week, token.length);
}, I: function(date, token, localize) {
  var isoWeek = getUTCISOWeek(date);
  return "Io" === token ? localize.ordinalNumber(isoWeek, { unit: "week" }) : addLeadingZeros(isoWeek, token.length);
}, d: function(date, token, localize) {
  return "do" === token ? localize.ordinalNumber(date.getUTCDate(), { unit: "date" }) : formatters$1_d(date, token);
}, D: function(date, token, localize) {
  var dayOfYear = function(dirtyDate) {
    requiredArgs(1, arguments);
    var date2 = toDate(dirtyDate), timestamp = date2.getTime();
    date2.setUTCMonth(0, 1), date2.setUTCHours(0, 0, 0, 0);
    var difference = timestamp - date2.getTime();
    return Math.floor(difference / 864e5) + 1;
  }(date);
  return "Do" === token ? localize.ordinalNumber(dayOfYear, { unit: "dayOfYear" }) : addLeadingZeros(dayOfYear, token.length);
}, E: function(date, token, localize) {
  var dayOfWeek = date.getUTCDay();
  switch (token) {
    case "E":
    case "EE":
    case "EEE":
      return localize.day(dayOfWeek, { width: "abbreviated", context: "formatting" });
    case "EEEEE":
      return localize.day(dayOfWeek, { width: "narrow", context: "formatting" });
    case "EEEEEE":
      return localize.day(dayOfWeek, { width: "short", context: "formatting" });
    default:
      return localize.day(dayOfWeek, { width: "wide", context: "formatting" });
  }
}, e: function(date, token, localize, options) {
  var dayOfWeek = date.getUTCDay(), localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
  switch (token) {
    case "e":
      return String(localDayOfWeek);
    case "ee":
      return addLeadingZeros(localDayOfWeek, 2);
    case "eo":
      return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
    case "eee":
      return localize.day(dayOfWeek, { width: "abbreviated", context: "formatting" });
    case "eeeee":
      return localize.day(dayOfWeek, { width: "narrow", context: "formatting" });
    case "eeeeee":
      return localize.day(dayOfWeek, { width: "short", context: "formatting" });
    default:
      return localize.day(dayOfWeek, { width: "wide", context: "formatting" });
  }
}, c: function(date, token, localize, options) {
  var dayOfWeek = date.getUTCDay(), localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
  switch (token) {
    case "c":
      return String(localDayOfWeek);
    case "cc":
      return addLeadingZeros(localDayOfWeek, token.length);
    case "co":
      return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
    case "ccc":
      return localize.day(dayOfWeek, { width: "abbreviated", context: "standalone" });
    case "ccccc":
      return localize.day(dayOfWeek, { width: "narrow", context: "standalone" });
    case "cccccc":
      return localize.day(dayOfWeek, { width: "short", context: "standalone" });
    default:
      return localize.day(dayOfWeek, { width: "wide", context: "standalone" });
  }
}, i: function(date, token, localize) {
  var dayOfWeek = date.getUTCDay(), isoDayOfWeek = 0 === dayOfWeek ? 7 : dayOfWeek;
  switch (token) {
    case "i":
      return String(isoDayOfWeek);
    case "ii":
      return addLeadingZeros(isoDayOfWeek, token.length);
    case "io":
      return localize.ordinalNumber(isoDayOfWeek, { unit: "day" });
    case "iii":
      return localize.day(dayOfWeek, { width: "abbreviated", context: "formatting" });
    case "iiiii":
      return localize.day(dayOfWeek, { width: "narrow", context: "formatting" });
    case "iiiiii":
      return localize.day(dayOfWeek, { width: "short", context: "formatting" });
    default:
      return localize.day(dayOfWeek, { width: "wide", context: "formatting" });
  }
}, a: function(date, token, localize) {
  var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
  switch (token) {
    case "a":
    case "aa":
      return localize.dayPeriod(dayPeriodEnumValue, { width: "abbreviated", context: "formatting" });
    case "aaa":
      return localize.dayPeriod(dayPeriodEnumValue, { width: "abbreviated", context: "formatting" }).toLowerCase();
    case "aaaaa":
      return localize.dayPeriod(dayPeriodEnumValue, { width: "narrow", context: "formatting" });
    default:
      return localize.dayPeriod(dayPeriodEnumValue, { width: "wide", context: "formatting" });
  }
}, b: function(date, token, localize) {
  var dayPeriodEnumValue, hours = date.getUTCHours();
  switch (dayPeriodEnumValue = 12 === hours ? dayPeriodEnum_noon : 0 === hours ? dayPeriodEnum_midnight : hours / 12 >= 1 ? "pm" : "am", token) {
    case "b":
    case "bb":
      return localize.dayPeriod(dayPeriodEnumValue, { width: "abbreviated", context: "formatting" });
    case "bbb":
      return localize.dayPeriod(dayPeriodEnumValue, { width: "abbreviated", context: "formatting" }).toLowerCase();
    case "bbbbb":
      return localize.dayPeriod(dayPeriodEnumValue, { width: "narrow", context: "formatting" });
    default:
      return localize.dayPeriod(dayPeriodEnumValue, { width: "wide", context: "formatting" });
  }
}, B: function(date, token, localize) {
  var dayPeriodEnumValue, hours = date.getUTCHours();
  switch (dayPeriodEnumValue = hours >= 17 ? dayPeriodEnum_evening : hours >= 12 ? dayPeriodEnum_afternoon : hours >= 4 ? dayPeriodEnum_morning : dayPeriodEnum_night, token) {
    case "B":
    case "BB":
    case "BBB":
      return localize.dayPeriod(dayPeriodEnumValue, { width: "abbreviated", context: "formatting" });
    case "BBBBB":
      return localize.dayPeriod(dayPeriodEnumValue, { width: "narrow", context: "formatting" });
    default:
      return localize.dayPeriod(dayPeriodEnumValue, { width: "wide", context: "formatting" });
  }
}, h: function(date, token, localize) {
  if ("ho" === token) {
    var hours = date.getUTCHours() % 12;
    return 0 === hours && (hours = 12), localize.ordinalNumber(hours, { unit: "hour" });
  }
  return formatters$1_h(date, token);
}, H: function(date, token, localize) {
  return "Ho" === token ? localize.ordinalNumber(date.getUTCHours(), { unit: "hour" }) : formatters$1_H(date, token);
}, K: function(date, token, localize) {
  var hours = date.getUTCHours() % 12;
  return "Ko" === token ? localize.ordinalNumber(hours, { unit: "hour" }) : addLeadingZeros(hours, token.length);
}, k: function(date, token, localize) {
  var hours = date.getUTCHours();
  return 0 === hours && (hours = 24), "ko" === token ? localize.ordinalNumber(hours, { unit: "hour" }) : addLeadingZeros(hours, token.length);
}, m: function(date, token, localize) {
  return "mo" === token ? localize.ordinalNumber(date.getUTCMinutes(), { unit: "minute" }) : formatters$1_m(date, token);
}, s: function(date, token, localize) {
  return "so" === token ? localize.ordinalNumber(date.getUTCSeconds(), { unit: "second" }) : formatters$1_s(date, token);
}, S: function(date, token) {
  return formatters$1_S(date, token);
}, X: function(date, token, _localize, options) {
  var timezoneOffset = (options._originalDate || date).getTimezoneOffset();
  if (0 === timezoneOffset)
    return "Z";
  switch (token) {
    case "X":
      return formatTimezoneWithOptionalMinutes(timezoneOffset);
    case "XXXX":
    case "XX":
      return formatTimezone(timezoneOffset);
    default:
      return formatTimezone(timezoneOffset, ":");
  }
}, x: function(date, token, _localize, options) {
  var timezoneOffset = (options._originalDate || date).getTimezoneOffset();
  switch (token) {
    case "x":
      return formatTimezoneWithOptionalMinutes(timezoneOffset);
    case "xxxx":
    case "xx":
      return formatTimezone(timezoneOffset);
    default:
      return formatTimezone(timezoneOffset, ":");
  }
}, O: function(date, token, _localize, options) {
  var timezoneOffset = (options._originalDate || date).getTimezoneOffset();
  switch (token) {
    case "O":
    case "OO":
    case "OOO":
      return "GMT" + formatTimezoneShort(timezoneOffset, ":");
    default:
      return "GMT" + formatTimezone(timezoneOffset, ":");
  }
}, z: function(date, token, _localize, options) {
  var timezoneOffset = (options._originalDate || date).getTimezoneOffset();
  switch (token) {
    case "z":
    case "zz":
    case "zzz":
      return "GMT" + formatTimezoneShort(timezoneOffset, ":");
    default:
      return "GMT" + formatTimezone(timezoneOffset, ":");
  }
}, t: function(date, token, _localize, options) {
  var originalDate = options._originalDate || date;
  return addLeadingZeros(Math.floor(originalDate.getTime() / 1e3), token.length);
}, T: function(date, token, _localize, options) {
  return addLeadingZeros((options._originalDate || date).getTime(), token.length);
} };
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? "-" : "+", absOffset = Math.abs(offset), hours = Math.floor(absOffset / 60), minutes = absOffset % 60;
  if (0 === minutes)
    return sign + String(hours);
  var delimiter = dirtyDelimiter;
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  return offset % 60 == 0 ? (offset > 0 ? "-" : "+") + addLeadingZeros(Math.abs(offset) / 60, 2) : formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "", sign = offset > 0 ? "-" : "+", absOffset = Math.abs(offset);
  return sign + addLeadingZeros(Math.floor(absOffset / 60), 2) + delimiter + addLeadingZeros(absOffset % 60, 2);
}
var dateLongFormatter = function(pattern, formatLong) {
  switch (pattern) {
    case "P":
      return formatLong.date({ width: "short" });
    case "PP":
      return formatLong.date({ width: "medium" });
    case "PPP":
      return formatLong.date({ width: "long" });
    default:
      return formatLong.date({ width: "full" });
  }
}, timeLongFormatter = function(pattern, formatLong) {
  switch (pattern) {
    case "p":
      return formatLong.time({ width: "short" });
    case "pp":
      return formatLong.time({ width: "medium" });
    case "ppp":
      return formatLong.time({ width: "long" });
    default:
      return formatLong.time({ width: "full" });
  }
}, longFormatters = { p: timeLongFormatter, P: function(pattern, formatLong) {
  var dateTimeFormat, matchResult = pattern.match(/(P+)(p+)?/) || [], datePattern = matchResult[1], timePattern = matchResult[2];
  if (!timePattern)
    return dateLongFormatter(pattern, formatLong);
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong.dateTime({ width: "long" });
      break;
    default:
      dateTimeFormat = formatLong.dateTime({ width: "full" });
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong)).replace("{{time}}", timeLongFormatter(timePattern, formatLong));
} }, protectedDayOfYearTokens = ["D", "DD"], protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return -1 !== protectedDayOfYearTokens.indexOf(token);
}
function isProtectedWeekYearToken(token) {
  return -1 !== protectedWeekYearTokens.indexOf(token);
}
function throwProtectedError(token, format2, input) {
  if ("YYYY" === token)
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if ("YY" === token)
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if ("D" === token)
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if ("DD" === token)
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
}
var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, escapedStringRegExp$1 = /^'([^]*?)'?$/, doubleQuoteRegExp$1 = /''/g, unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr), defaultOptions = getDefaultOptions(), locale$1 = null !== (_ref = null !== (_options$locale = null == options ? void 0 : options.locale) && void 0 !== _options$locale ? _options$locale : defaultOptions.locale) && void 0 !== _ref ? _ref : locale, firstWeekContainsDate = toInteger(null !== (_ref2 = null !== (_ref3 = null !== (_ref4 = null !== (_options$firstWeekCon = null == options ? void 0 : options.firstWeekContainsDate) && void 0 !== _options$firstWeekCon ? _options$firstWeekCon : null == options || null === (_options$locale2 = options.locale) || void 0 === _options$locale2 || null === (_options$locale2$opti = _options$locale2.options) || void 0 === _options$locale2$opti ? void 0 : _options$locale2$opti.firstWeekContainsDate) && void 0 !== _ref4 ? _ref4 : defaultOptions.firstWeekContainsDate) && void 0 !== _ref3 ? _ref3 : null === (_defaultOptions$local = defaultOptions.locale) || void 0 === _defaultOptions$local || null === (_defaultOptions$local2 = _defaultOptions$local.options) || void 0 === _defaultOptions$local2 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) && void 0 !== _ref2 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var weekStartsOn = toInteger(null !== (_ref5 = null !== (_ref6 = null !== (_ref7 = null !== (_options$weekStartsOn = null == options ? void 0 : options.weekStartsOn) && void 0 !== _options$weekStartsOn ? _options$weekStartsOn : null == options || null === (_options$locale3 = options.locale) || void 0 === _options$locale3 || null === (_options$locale3$opti = _options$locale3.options) || void 0 === _options$locale3$opti ? void 0 : _options$locale3$opti.weekStartsOn) && void 0 !== _ref7 ? _ref7 : defaultOptions.weekStartsOn) && void 0 !== _ref6 ? _ref6 : null === (_defaultOptions$local3 = defaultOptions.locale) || void 0 === _defaultOptions$local3 || null === (_defaultOptions$local4 = _defaultOptions$local3.options) || void 0 === _defaultOptions$local4 ? void 0 : _defaultOptions$local4.weekStartsOn) && void 0 !== _ref5 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  if (!locale$1.localize)
    throw new RangeError("locale must contain localize property");
  if (!locale$1.formatLong)
    throw new RangeError("locale must contain formatLong property");
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate))
    throw new RangeError("Invalid time value");
  var utcDate = subMilliseconds(originalDate, getTimezoneOffsetInMilliseconds(originalDate)), formatterOptions = { firstWeekContainsDate, weekStartsOn, locale: locale$1, _originalDate: originalDate };
  return formatStr.match(longFormattingTokensRegExp$1).map(function(substring) {
    var firstCharacter = substring[0];
    return "p" === firstCharacter || "P" === firstCharacter ? (0, longFormatters[firstCharacter])(substring, locale$1.formatLong) : substring;
  }).join("").match(formattingTokensRegExp$1).map(function(substring) {
    if ("''" === substring)
      return "'";
    var firstCharacter = substring[0];
    if ("'" === firstCharacter)
      return function(input) {
        var matched = input.match(escapedStringRegExp$1);
        if (!matched)
          return input;
        return matched[1].replace(doubleQuoteRegExp$1, "'");
      }(substring);
    var formatter = formatters[firstCharacter];
    if (formatter)
      return null != options && options.useAdditionalWeekYearTokens || !isProtectedWeekYearToken(substring) || throwProtectedError(substring, dirtyFormatStr, String(dirtyDate)), null != options && options.useAdditionalDayOfYearTokens || !isProtectedDayOfYearToken(substring) || throwProtectedError(substring, dirtyFormatStr, String(dirtyDate)), formatter(utcDate, substring, locale$1.localize, formatterOptions);
    if (firstCharacter.match(unescapedLatinCharacterRegExp$1))
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    return substring;
  }).join("");
}
function assign$1(target, object) {
  if (null == target)
    throw new TypeError("assign requires that input parameter not be null or undefined");
  for (var property in object)
    Object.prototype.hasOwnProperty.call(object, property) && (target[property] = object[property]);
  return target;
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++)
    n[e] = r[e];
  return n;
}
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = function(r2, a2) {
      if (r2) {
        if ("string" == typeof r2)
          return _arrayLikeToArray(r2, a2);
        var t2 = {}.toString.call(r2).slice(8, -1);
        return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
      }
    }(r)) || e) {
      t && (r = t);
      var _n = 0, F = function() {
      };
      return { s: F, n: function() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function() {
    t = t.call(r);
  }, n: function() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function(r2) {
    u = true, o = r2;
  }, f: function() {
    try {
      a || null == t.return || t.return();
    } finally {
      if (u)
        throw o;
    }
  } };
}
function _assertThisInitialized(e) {
  if (void 0 === e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function() {
    return !!t;
  })();
}
function _createSuper(t) {
  var r = _isNativeReflectConstruct();
  return function() {
    var e, o = _getPrototypeOf(t);
    if (r) {
      var s = _getPrototypeOf(this).constructor;
      e = Reflect.construct(o, arguments, s);
    } else
      e = o.apply(this, arguments);
    return function(t2, e2) {
      if (e2 && ("object" == _typeof(e2) || "function" == typeof e2))
        return e2;
      if (void 0 !== e2)
        throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t2);
    }(this, e);
  };
}
function _classCallCheck(a, n) {
  if (!(a instanceof n))
    throw new TypeError("Cannot call a class as a function");
}
function toPropertyKey(t) {
  var i = function(t2, r) {
    if ("object" != _typeof(t2) || !t2)
      return t2;
    var e = t2[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i2 = e.call(t2, r || "default");
      if ("object" != _typeof(i2))
        return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t2);
  }(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _createClass(e, r, t) {
  return r && function(e2, r2) {
    for (var t2 = 0; t2 < r2.length; t2++) {
      var o = r2[t2];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e2, toPropertyKey(o.key), o);
    }
  }(e.prototype, r), Object.defineProperty(e, "prototype", { writable: false }), e;
}
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
var Setter = function() {
  function Setter2() {
    _classCallCheck(this, Setter2), _defineProperty(this, "priority", void 0), _defineProperty(this, "subPriority", 0);
  }
  return _createClass(Setter2, [{ key: "validate", value: function(_utcDate, _options) {
    return true;
  } }]), Setter2;
}(), ValueSetter = function() {
  _inherits(ValueSetter2, Setter);
  var _super = _createSuper(ValueSetter2);
  function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
    var _this;
    return _classCallCheck(this, ValueSetter2), (_this = _super.call(this)).value = value, _this.validateValue = validateValue, _this.setValue = setValue, _this.priority = priority, subPriority && (_this.subPriority = subPriority), _this;
  }
  return _createClass(ValueSetter2, [{ key: "validate", value: function(utcDate, options) {
    return this.validateValue(utcDate, this.value, options);
  } }, { key: "set", value: function(utcDate, flags, options) {
    return this.setValue(utcDate, flags, this.value, options);
  } }]), ValueSetter2;
}(), DateToSystemTimezoneSetter = function() {
  _inherits(DateToSystemTimezoneSetter2, Setter);
  var _super2 = _createSuper(DateToSystemTimezoneSetter2);
  function DateToSystemTimezoneSetter2() {
    var _this2;
    _classCallCheck(this, DateToSystemTimezoneSetter2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this2 = _super2.call.apply(_super2, [this].concat(args))), "priority", 10), _defineProperty(_assertThisInitialized(_this2), "subPriority", -1), _this2;
  }
  return _createClass(DateToSystemTimezoneSetter2, [{ key: "set", value: function(date, flags) {
    if (flags.timestampIsSet)
      return date;
    var convertedDate = /* @__PURE__ */ new Date(0);
    return convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()), convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()), convertedDate;
  } }]), DateToSystemTimezoneSetter2;
}(), Parser$1 = function() {
  function Parser2() {
    _classCallCheck(this, Parser2), _defineProperty(this, "incompatibleTokens", void 0), _defineProperty(this, "priority", void 0), _defineProperty(this, "subPriority", void 0);
  }
  return _createClass(Parser2, [{ key: "run", value: function(dateString, token, match, options) {
    var result = this.parse(dateString, token, match, options);
    return result ? { setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority), rest: result.rest } : null;
  } }, { key: "validate", value: function(_utcDate, _value, _options) {
    return true;
  } }]), Parser2;
}(), EraParser = function() {
  _inherits(EraParser2, Parser$1);
  var _super = _createSuper(EraParser2);
  function EraParser2() {
    var _this;
    _classCallCheck(this, EraParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 140), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["R", "u", "t", "T"]), _this;
  }
  return _createClass(EraParser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return match.era(dateString, { width: "abbreviated" }) || match.era(dateString, { width: "narrow" });
      case "GGGGG":
        return match.era(dateString, { width: "narrow" });
      default:
        return match.era(dateString, { width: "wide" }) || match.era(dateString, { width: "abbreviated" }) || match.era(dateString, { width: "narrow" });
    }
  } }, { key: "set", value: function(date, flags, value) {
    return flags.era = value, date.setUTCFullYear(value, 0, 1), date.setUTCHours(0, 0, 0, 0), date;
  } }]), EraParser2;
}(), numericPatterns_month = /^(1[0-2]|0?\d)/, numericPatterns_date = /^(3[0-1]|[0-2]?\d)/, numericPatterns_dayOfYear = /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/, numericPatterns_week = /^(5[0-3]|[0-4]?\d)/, numericPatterns_hour23h = /^(2[0-3]|[0-1]?\d)/, numericPatterns_hour24h = /^(2[0-4]|[0-1]?\d)/, numericPatterns_hour11h = /^(1[0-1]|0?\d)/, numericPatterns_hour12h = /^(1[0-2]|0?\d)/, numericPatterns_minute = /^[0-5]?\d/, numericPatterns_second = /^[0-5]?\d/, numericPatterns_singleDigit = /^\d/, numericPatterns_twoDigits = /^\d{1,2}/, numericPatterns_threeDigits = /^\d{1,3}/, numericPatterns_fourDigits = /^\d{1,4}/, numericPatterns_anyDigitsSigned = /^-?\d+/, numericPatterns_singleDigitSigned = /^-?\d/, numericPatterns_twoDigitsSigned = /^-?\d{1,2}/, numericPatterns_threeDigitsSigned = /^-?\d{1,3}/, numericPatterns_fourDigitsSigned = /^-?\d{1,4}/, timezonePatterns_basicOptionalMinutes = /^([+-])(\d{2})(\d{2})?|Z/, timezonePatterns_basic = /^([+-])(\d{2})(\d{2})|Z/, timezonePatterns_basicOptionalSeconds = /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/, timezonePatterns_extended = /^([+-])(\d{2}):(\d{2})|Z/, timezonePatterns_extendedOptionalSeconds = /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/;
function mapValue(parseFnResult, mapFn) {
  return parseFnResult ? { value: mapFn(parseFnResult.value), rest: parseFnResult.rest } : parseFnResult;
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  return matchResult ? { value: parseInt(matchResult[0], 10), rest: dateString.slice(matchResult[0].length) } : null;
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  return matchResult ? "Z" === matchResult[0] ? { value: 0, rest: dateString.slice(1) } : { value: ("+" === matchResult[1] ? 1 : -1) * (36e5 * (matchResult[2] ? parseInt(matchResult[2], 10) : 0) + 6e4 * (matchResult[3] ? parseInt(matchResult[3], 10) : 0) + 1e3 * (matchResult[5] ? parseInt(matchResult[5], 10) : 0)), rest: dateString.slice(matchResult[0].length) } : null;
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns_anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns_singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns_twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns_threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns_fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns_singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns_twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns_threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns_fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var result, isCommonEra = currentYear > 0, absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  if (absCurrentYear <= 50)
    result = twoDigitYear || 100;
  else {
    var rangeEnd = absCurrentYear + 50;
    result = twoDigitYear + 100 * Math.floor(rangeEnd / 100) - (twoDigitYear >= rangeEnd % 100 ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 == 0 || year % 4 == 0 && year % 100 != 0;
}
var YearParser = function() {
  _inherits(YearParser2, Parser$1);
  var _super = _createSuper(YearParser2);
  function YearParser2() {
    var _this;
    _classCallCheck(this, YearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 130), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]), _this;
  }
  return _createClass(YearParser2, [{ key: "parse", value: function(dateString, token, match) {
    var valueCallback = function(year) {
      return { year, isTwoDigitYear: "yy" === token };
    };
    switch (token) {
      case "y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "yo":
        return mapValue(match.ordinalNumber(dateString, { unit: "year" }), valueCallback);
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  } }, { key: "validate", value: function(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  } }, { key: "set", value: function(date, flags, value) {
    var currentYear = date.getUTCFullYear();
    if (value.isTwoDigitYear) {
      var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
      return date.setUTCFullYear(normalizedTwoDigitYear, 0, 1), date.setUTCHours(0, 0, 0, 0), date;
    }
    var year = "era" in flags && 1 !== flags.era ? 1 - value.year : value.year;
    return date.setUTCFullYear(year, 0, 1), date.setUTCHours(0, 0, 0, 0), date;
  } }]), YearParser2;
}(), LocalWeekYearParser = function() {
  _inherits(LocalWeekYearParser2, Parser$1);
  var _super = _createSuper(LocalWeekYearParser2);
  function LocalWeekYearParser2() {
    var _this;
    _classCallCheck(this, LocalWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 130), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]), _this;
  }
  return _createClass(LocalWeekYearParser2, [{ key: "parse", value: function(dateString, token, match) {
    var valueCallback = function(year) {
      return { year, isTwoDigitYear: "YY" === token };
    };
    switch (token) {
      case "Y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "Yo":
        return mapValue(match.ordinalNumber(dateString, { unit: "year" }), valueCallback);
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  } }, { key: "validate", value: function(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  } }, { key: "set", value: function(date, flags, value, options) {
    var currentYear = getUTCWeekYear(date, options);
    if (value.isTwoDigitYear) {
      var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
      return date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate), date.setUTCHours(0, 0, 0, 0), startOfUTCWeek(date, options);
    }
    var year = "era" in flags && 1 !== flags.era ? 1 - value.year : value.year;
    return date.setUTCFullYear(year, 0, options.firstWeekContainsDate), date.setUTCHours(0, 0, 0, 0), startOfUTCWeek(date, options);
  } }]), LocalWeekYearParser2;
}(), ISOWeekYearParser = function() {
  _inherits(ISOWeekYearParser2, Parser$1);
  var _super = _createSuper(ISOWeekYearParser2);
  function ISOWeekYearParser2() {
    var _this;
    _classCallCheck(this, ISOWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 130), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]), _this;
  }
  return _createClass(ISOWeekYearParser2, [{ key: "parse", value: function(dateString, token) {
    return parseNDigitsSigned("R" === token ? 4 : token.length, dateString);
  } }, { key: "set", value: function(_date, _flags, value) {
    var firstWeekOfYear = /* @__PURE__ */ new Date(0);
    return firstWeekOfYear.setUTCFullYear(value, 0, 4), firstWeekOfYear.setUTCHours(0, 0, 0, 0), startOfUTCISOWeek(firstWeekOfYear);
  } }]), ISOWeekYearParser2;
}(), ExtendedYearParser = function() {
  _inherits(ExtendedYearParser2, Parser$1);
  var _super = _createSuper(ExtendedYearParser2);
  function ExtendedYearParser2() {
    var _this;
    _classCallCheck(this, ExtendedYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 130), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]), _this;
  }
  return _createClass(ExtendedYearParser2, [{ key: "parse", value: function(dateString, token) {
    return parseNDigitsSigned("u" === token ? 4 : token.length, dateString);
  } }, { key: "set", value: function(date, _flags, value) {
    return date.setUTCFullYear(value, 0, 1), date.setUTCHours(0, 0, 0, 0), date;
  } }]), ExtendedYearParser2;
}(), QuarterParser = function() {
  _inherits(QuarterParser2, Parser$1);
  var _super = _createSuper(QuarterParser2);
  function QuarterParser2() {
    var _this;
    _classCallCheck(this, QuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 120), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]), _this;
  }
  return _createClass(QuarterParser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "Q":
      case "QQ":
        return parseNDigits(token.length, dateString);
      case "Qo":
        return match.ordinalNumber(dateString, { unit: "quarter" });
      case "QQQ":
        return match.quarter(dateString, { width: "abbreviated", context: "formatting" }) || match.quarter(dateString, { width: "narrow", context: "formatting" });
      case "QQQQQ":
        return match.quarter(dateString, { width: "narrow", context: "formatting" });
      default:
        return match.quarter(dateString, { width: "wide", context: "formatting" }) || match.quarter(dateString, { width: "abbreviated", context: "formatting" }) || match.quarter(dateString, { width: "narrow", context: "formatting" });
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 1 && value <= 4;
  } }, { key: "set", value: function(date, _flags, value) {
    return date.setUTCMonth(3 * (value - 1), 1), date.setUTCHours(0, 0, 0, 0), date;
  } }]), QuarterParser2;
}(), StandAloneQuarterParser = function() {
  _inherits(StandAloneQuarterParser2, Parser$1);
  var _super = _createSuper(StandAloneQuarterParser2);
  function StandAloneQuarterParser2() {
    var _this;
    _classCallCheck(this, StandAloneQuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 120), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]), _this;
  }
  return _createClass(StandAloneQuarterParser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "q":
      case "qq":
        return parseNDigits(token.length, dateString);
      case "qo":
        return match.ordinalNumber(dateString, { unit: "quarter" });
      case "qqq":
        return match.quarter(dateString, { width: "abbreviated", context: "standalone" }) || match.quarter(dateString, { width: "narrow", context: "standalone" });
      case "qqqqq":
        return match.quarter(dateString, { width: "narrow", context: "standalone" });
      default:
        return match.quarter(dateString, { width: "wide", context: "standalone" }) || match.quarter(dateString, { width: "abbreviated", context: "standalone" }) || match.quarter(dateString, { width: "narrow", context: "standalone" });
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 1 && value <= 4;
  } }, { key: "set", value: function(date, _flags, value) {
    return date.setUTCMonth(3 * (value - 1), 1), date.setUTCHours(0, 0, 0, 0), date;
  } }]), StandAloneQuarterParser2;
}(), MonthParser = function() {
  _inherits(MonthParser2, Parser$1);
  var _super = _createSuper(MonthParser2);
  function MonthParser2() {
    var _this;
    _classCallCheck(this, MonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]), _defineProperty(_assertThisInitialized(_this), "priority", 110), _this;
  }
  return _createClass(MonthParser2, [{ key: "parse", value: function(dateString, token, match) {
    var valueCallback = function(value) {
      return value - 1;
    };
    switch (token) {
      case "M":
        return mapValue(parseNumericPattern(numericPatterns_month, dateString), valueCallback);
      case "MM":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Mo":
        return mapValue(match.ordinalNumber(dateString, { unit: "month" }), valueCallback);
      case "MMM":
        return match.month(dateString, { width: "abbreviated", context: "formatting" }) || match.month(dateString, { width: "narrow", context: "formatting" });
      case "MMMMM":
        return match.month(dateString, { width: "narrow", context: "formatting" });
      default:
        return match.month(dateString, { width: "wide", context: "formatting" }) || match.month(dateString, { width: "abbreviated", context: "formatting" }) || match.month(dateString, { width: "narrow", context: "formatting" });
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 0 && value <= 11;
  } }, { key: "set", value: function(date, _flags, value) {
    return date.setUTCMonth(value, 1), date.setUTCHours(0, 0, 0, 0), date;
  } }]), MonthParser2;
}(), StandAloneMonthParser = function() {
  _inherits(StandAloneMonthParser2, Parser$1);
  var _super = _createSuper(StandAloneMonthParser2);
  function StandAloneMonthParser2() {
    var _this;
    _classCallCheck(this, StandAloneMonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 110), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]), _this;
  }
  return _createClass(StandAloneMonthParser2, [{ key: "parse", value: function(dateString, token, match) {
    var valueCallback = function(value) {
      return value - 1;
    };
    switch (token) {
      case "L":
        return mapValue(parseNumericPattern(numericPatterns_month, dateString), valueCallback);
      case "LL":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Lo":
        return mapValue(match.ordinalNumber(dateString, { unit: "month" }), valueCallback);
      case "LLL":
        return match.month(dateString, { width: "abbreviated", context: "standalone" }) || match.month(dateString, { width: "narrow", context: "standalone" });
      case "LLLLL":
        return match.month(dateString, { width: "narrow", context: "standalone" });
      default:
        return match.month(dateString, { width: "wide", context: "standalone" }) || match.month(dateString, { width: "abbreviated", context: "standalone" }) || match.month(dateString, { width: "narrow", context: "standalone" });
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 0 && value <= 11;
  } }, { key: "set", value: function(date, _flags, value) {
    return date.setUTCMonth(value, 1), date.setUTCHours(0, 0, 0, 0), date;
  } }]), StandAloneMonthParser2;
}();
var LocalWeekParser = function() {
  _inherits(LocalWeekParser2, Parser$1);
  var _super = _createSuper(LocalWeekParser2);
  function LocalWeekParser2() {
    var _this;
    _classCallCheck(this, LocalWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 100), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]), _this;
  }
  return _createClass(LocalWeekParser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "w":
        return parseNumericPattern(numericPatterns_week, dateString);
      case "wo":
        return match.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 1 && value <= 53;
  } }, { key: "set", value: function(date, _flags, value, options) {
    return startOfUTCWeek(function(dirtyDate, dirtyWeek, options2) {
      requiredArgs(2, arguments);
      var date2 = toDate(dirtyDate), week = toInteger(dirtyWeek), diff = getUTCWeek(date2, options2) - week;
      return date2.setUTCDate(date2.getUTCDate() - 7 * diff), date2;
    }(date, value, options), options);
  } }]), LocalWeekParser2;
}();
var ISOWeekParser = function() {
  _inherits(ISOWeekParser2, Parser$1);
  var _super = _createSuper(ISOWeekParser2);
  function ISOWeekParser2() {
    var _this;
    _classCallCheck(this, ISOWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 100), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]), _this;
  }
  return _createClass(ISOWeekParser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "I":
        return parseNumericPattern(numericPatterns_week, dateString);
      case "Io":
        return match.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 1 && value <= 53;
  } }, { key: "set", value: function(date, _flags, value) {
    return startOfUTCISOWeek(function(dirtyDate, dirtyISOWeek) {
      requiredArgs(2, arguments);
      var date2 = toDate(dirtyDate), isoWeek = toInteger(dirtyISOWeek), diff = getUTCISOWeek(date2) - isoWeek;
      return date2.setUTCDate(date2.getUTCDate() - 7 * diff), date2;
    }(date, value));
  } }]), ISOWeekParser2;
}(), DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], DateParser = function() {
  _inherits(DateParser2, Parser$1);
  var _super = _createSuper(DateParser2);
  function DateParser2() {
    var _this;
    _classCallCheck(this, DateParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 90), _defineProperty(_assertThisInitialized(_this), "subPriority", 1), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]), _this;
  }
  return _createClass(DateParser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "d":
        return parseNumericPattern(numericPatterns_date, dateString);
      case "do":
        return match.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  } }, { key: "validate", value: function(date, value) {
    var isLeapYear = isLeapYearIndex(date.getUTCFullYear()), month = date.getUTCMonth();
    return isLeapYear ? value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month] : value >= 1 && value <= DAYS_IN_MONTH[month];
  } }, { key: "set", value: function(date, _flags, value) {
    return date.setUTCDate(value), date.setUTCHours(0, 0, 0, 0), date;
  } }]), DateParser2;
}(), DayOfYearParser = function() {
  _inherits(DayOfYearParser2, Parser$1);
  var _super = _createSuper(DayOfYearParser2);
  function DayOfYearParser2() {
    var _this;
    _classCallCheck(this, DayOfYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 90), _defineProperty(_assertThisInitialized(_this), "subpriority", 1), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]), _this;
  }
  return _createClass(DayOfYearParser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "D":
      case "DD":
        return parseNumericPattern(numericPatterns_dayOfYear, dateString);
      case "Do":
        return match.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  } }, { key: "validate", value: function(date, value) {
    return isLeapYearIndex(date.getUTCFullYear()) ? value >= 1 && value <= 366 : value >= 1 && value <= 365;
  } }, { key: "set", value: function(date, _flags, value) {
    return date.setUTCMonth(0, value), date.setUTCHours(0, 0, 0, 0), date;
  } }]), DayOfYearParser2;
}();
function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions = getDefaultOptions(), weekStartsOn = toInteger(null !== (_ref = null !== (_ref2 = null !== (_ref3 = null !== (_options$weekStartsOn = null == options ? void 0 : options.weekStartsOn) && void 0 !== _options$weekStartsOn ? _options$weekStartsOn : null == options || null === (_options$locale = options.locale) || void 0 === _options$locale || null === (_options$locale$optio = _options$locale.options) || void 0 === _options$locale$optio ? void 0 : _options$locale$optio.weekStartsOn) && void 0 !== _ref3 ? _ref3 : defaultOptions.weekStartsOn) && void 0 !== _ref2 ? _ref2 : null === (_defaultOptions$local = defaultOptions.locale) || void 0 === _defaultOptions$local || null === (_defaultOptions$local2 = _defaultOptions$local.options) || void 0 === _defaultOptions$local2 ? void 0 : _defaultOptions$local2.weekStartsOn) && void 0 !== _ref ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var date = toDate(dirtyDate), day = toInteger(dirtyDay), diff = ((day % 7 + 7) % 7 < weekStartsOn ? 7 : 0) + day - date.getUTCDay();
  return date.setUTCDate(date.getUTCDate() + diff), date;
}
var DayParser = function() {
  _inherits(DayParser2, Parser$1);
  var _super = _createSuper(DayParser2);
  function DayParser2() {
    var _this;
    _classCallCheck(this, DayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 90), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]), _this;
  }
  return _createClass(DayParser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return match.day(dateString, { width: "abbreviated", context: "formatting" }) || match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
      case "EEEEE":
        return match.day(dateString, { width: "narrow", context: "formatting" });
      case "EEEEEE":
        return match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
      default:
        return match.day(dateString, { width: "wide", context: "formatting" }) || match.day(dateString, { width: "abbreviated", context: "formatting" }) || match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 0 && value <= 6;
  } }, { key: "set", value: function(date, _flags, value, options) {
    return (date = setUTCDay(date, value, options)).setUTCHours(0, 0, 0, 0), date;
  } }]), DayParser2;
}(), LocalDayParser = function() {
  _inherits(LocalDayParser2, Parser$1);
  var _super = _createSuper(LocalDayParser2);
  function LocalDayParser2() {
    var _this;
    _classCallCheck(this, LocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 90), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]), _this;
  }
  return _createClass(LocalDayParser2, [{ key: "parse", value: function(dateString, token, match, options) {
    var valueCallback = function(value) {
      var wholeWeekDays = 7 * Math.floor((value - 1) / 7);
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      case "e":
      case "ee":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      case "eo":
        return mapValue(match.ordinalNumber(dateString, { unit: "day" }), valueCallback);
      case "eee":
        return match.day(dateString, { width: "abbreviated", context: "formatting" }) || match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
      case "eeeee":
        return match.day(dateString, { width: "narrow", context: "formatting" });
      case "eeeeee":
        return match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
      default:
        return match.day(dateString, { width: "wide", context: "formatting" }) || match.day(dateString, { width: "abbreviated", context: "formatting" }) || match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 0 && value <= 6;
  } }, { key: "set", value: function(date, _flags, value, options) {
    return (date = setUTCDay(date, value, options)).setUTCHours(0, 0, 0, 0), date;
  } }]), LocalDayParser2;
}(), StandAloneLocalDayParser = function() {
  _inherits(StandAloneLocalDayParser2, Parser$1);
  var _super = _createSuper(StandAloneLocalDayParser2);
  function StandAloneLocalDayParser2() {
    var _this;
    _classCallCheck(this, StandAloneLocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 90), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]), _this;
  }
  return _createClass(StandAloneLocalDayParser2, [{ key: "parse", value: function(dateString, token, match, options) {
    var valueCallback = function(value) {
      var wholeWeekDays = 7 * Math.floor((value - 1) / 7);
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      case "c":
      case "cc":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      case "co":
        return mapValue(match.ordinalNumber(dateString, { unit: "day" }), valueCallback);
      case "ccc":
        return match.day(dateString, { width: "abbreviated", context: "standalone" }) || match.day(dateString, { width: "short", context: "standalone" }) || match.day(dateString, { width: "narrow", context: "standalone" });
      case "ccccc":
        return match.day(dateString, { width: "narrow", context: "standalone" });
      case "cccccc":
        return match.day(dateString, { width: "short", context: "standalone" }) || match.day(dateString, { width: "narrow", context: "standalone" });
      default:
        return match.day(dateString, { width: "wide", context: "standalone" }) || match.day(dateString, { width: "abbreviated", context: "standalone" }) || match.day(dateString, { width: "short", context: "standalone" }) || match.day(dateString, { width: "narrow", context: "standalone" });
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 0 && value <= 6;
  } }, { key: "set", value: function(date, _flags, value, options) {
    return (date = setUTCDay(date, value, options)).setUTCHours(0, 0, 0, 0), date;
  } }]), StandAloneLocalDayParser2;
}();
var ISODayParser = function() {
  _inherits(ISODayParser2, Parser$1);
  var _super = _createSuper(ISODayParser2);
  function ISODayParser2() {
    var _this;
    _classCallCheck(this, ISODayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 90), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]), _this;
  }
  return _createClass(ISODayParser2, [{ key: "parse", value: function(dateString, token, match) {
    var valueCallback = function(value) {
      return 0 === value ? 7 : value;
    };
    switch (token) {
      case "i":
      case "ii":
        return parseNDigits(token.length, dateString);
      case "io":
        return match.ordinalNumber(dateString, { unit: "day" });
      case "iii":
        return mapValue(match.day(dateString, { width: "abbreviated", context: "formatting" }) || match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" }), valueCallback);
      case "iiiii":
        return mapValue(match.day(dateString, { width: "narrow", context: "formatting" }), valueCallback);
      case "iiiiii":
        return mapValue(match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" }), valueCallback);
      default:
        return mapValue(match.day(dateString, { width: "wide", context: "formatting" }) || match.day(dateString, { width: "abbreviated", context: "formatting" }) || match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" }), valueCallback);
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 1 && value <= 7;
  } }, { key: "set", value: function(date, _flags, value) {
    return date = function(dirtyDate, dirtyDay) {
      requiredArgs(2, arguments);
      var day = toInteger(dirtyDay);
      day % 7 == 0 && (day -= 7);
      var date2 = toDate(dirtyDate), diff = ((day % 7 + 7) % 7 < 1 ? 7 : 0) + day - date2.getUTCDay();
      return date2.setUTCDate(date2.getUTCDate() + diff), date2;
    }(date, value), date.setUTCHours(0, 0, 0, 0), date;
  } }]), ISODayParser2;
}(), AMPMParser = function() {
  _inherits(AMPMParser2, Parser$1);
  var _super = _createSuper(AMPMParser2);
  function AMPMParser2() {
    var _this;
    _classCallCheck(this, AMPMParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 80), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]), _this;
  }
  return _createClass(AMPMParser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return match.dayPeriod(dateString, { width: "abbreviated", context: "formatting" }) || match.dayPeriod(dateString, { width: "narrow", context: "formatting" });
      case "aaaaa":
        return match.dayPeriod(dateString, { width: "narrow", context: "formatting" });
      default:
        return match.dayPeriod(dateString, { width: "wide", context: "formatting" }) || match.dayPeriod(dateString, { width: "abbreviated", context: "formatting" }) || match.dayPeriod(dateString, { width: "narrow", context: "formatting" });
    }
  } }, { key: "set", value: function(date, _flags, value) {
    return date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0), date;
  } }]), AMPMParser2;
}(), AMPMMidnightParser = function() {
  _inherits(AMPMMidnightParser2, Parser$1);
  var _super = _createSuper(AMPMMidnightParser2);
  function AMPMMidnightParser2() {
    var _this;
    _classCallCheck(this, AMPMMidnightParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 80), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]), _this;
  }
  return _createClass(AMPMMidnightParser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return match.dayPeriod(dateString, { width: "abbreviated", context: "formatting" }) || match.dayPeriod(dateString, { width: "narrow", context: "formatting" });
      case "bbbbb":
        return match.dayPeriod(dateString, { width: "narrow", context: "formatting" });
      default:
        return match.dayPeriod(dateString, { width: "wide", context: "formatting" }) || match.dayPeriod(dateString, { width: "abbreviated", context: "formatting" }) || match.dayPeriod(dateString, { width: "narrow", context: "formatting" });
    }
  } }, { key: "set", value: function(date, _flags, value) {
    return date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0), date;
  } }]), AMPMMidnightParser2;
}(), DayPeriodParser = function() {
  _inherits(DayPeriodParser2, Parser$1);
  var _super = _createSuper(DayPeriodParser2);
  function DayPeriodParser2() {
    var _this;
    _classCallCheck(this, DayPeriodParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 80), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "t", "T"]), _this;
  }
  return _createClass(DayPeriodParser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return match.dayPeriod(dateString, { width: "abbreviated", context: "formatting" }) || match.dayPeriod(dateString, { width: "narrow", context: "formatting" });
      case "BBBBB":
        return match.dayPeriod(dateString, { width: "narrow", context: "formatting" });
      default:
        return match.dayPeriod(dateString, { width: "wide", context: "formatting" }) || match.dayPeriod(dateString, { width: "abbreviated", context: "formatting" }) || match.dayPeriod(dateString, { width: "narrow", context: "formatting" });
    }
  } }, { key: "set", value: function(date, _flags, value) {
    return date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0), date;
  } }]), DayPeriodParser2;
}(), Hour1to12Parser = function() {
  _inherits(Hour1to12Parser2, Parser$1);
  var _super = _createSuper(Hour1to12Parser2);
  function Hour1to12Parser2() {
    var _this;
    _classCallCheck(this, Hour1to12Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 70), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]), _this;
  }
  return _createClass(Hour1to12Parser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "h":
        return parseNumericPattern(numericPatterns_hour12h, dateString);
      case "ho":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 1 && value <= 12;
  } }, { key: "set", value: function(date, _flags, value) {
    var isPM = date.getUTCHours() >= 12;
    return isPM && value < 12 ? date.setUTCHours(value + 12, 0, 0, 0) : isPM || 12 !== value ? date.setUTCHours(value, 0, 0, 0) : date.setUTCHours(0, 0, 0, 0), date;
  } }]), Hour1to12Parser2;
}(), Hour0to23Parser = function() {
  _inherits(Hour0to23Parser2, Parser$1);
  var _super = _createSuper(Hour0to23Parser2);
  function Hour0to23Parser2() {
    var _this;
    _classCallCheck(this, Hour0to23Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 70), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]), _this;
  }
  return _createClass(Hour0to23Parser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "H":
        return parseNumericPattern(numericPatterns_hour23h, dateString);
      case "Ho":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 0 && value <= 23;
  } }, { key: "set", value: function(date, _flags, value) {
    return date.setUTCHours(value, 0, 0, 0), date;
  } }]), Hour0to23Parser2;
}(), Hour0To11Parser = function() {
  _inherits(Hour0To11Parser2, Parser$1);
  var _super = _createSuper(Hour0To11Parser2);
  function Hour0To11Parser2() {
    var _this;
    _classCallCheck(this, Hour0To11Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 70), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]), _this;
  }
  return _createClass(Hour0To11Parser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "K":
        return parseNumericPattern(numericPatterns_hour11h, dateString);
      case "Ko":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 0 && value <= 11;
  } }, { key: "set", value: function(date, _flags, value) {
    return date.getUTCHours() >= 12 && value < 12 ? date.setUTCHours(value + 12, 0, 0, 0) : date.setUTCHours(value, 0, 0, 0), date;
  } }]), Hour0To11Parser2;
}(), Hour1To24Parser = function() {
  _inherits(Hour1To24Parser2, Parser$1);
  var _super = _createSuper(Hour1To24Parser2);
  function Hour1To24Parser2() {
    var _this;
    _classCallCheck(this, Hour1To24Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 70), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]), _this;
  }
  return _createClass(Hour1To24Parser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "k":
        return parseNumericPattern(numericPatterns_hour24h, dateString);
      case "ko":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 1 && value <= 24;
  } }, { key: "set", value: function(date, _flags, value) {
    var hours = value <= 24 ? value % 24 : value;
    return date.setUTCHours(hours, 0, 0, 0), date;
  } }]), Hour1To24Parser2;
}(), MinuteParser = function() {
  _inherits(MinuteParser2, Parser$1);
  var _super = _createSuper(MinuteParser2);
  function MinuteParser2() {
    var _this;
    _classCallCheck(this, MinuteParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 60), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]), _this;
  }
  return _createClass(MinuteParser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "m":
        return parseNumericPattern(numericPatterns_minute, dateString);
      case "mo":
        return match.ordinalNumber(dateString, { unit: "minute" });
      default:
        return parseNDigits(token.length, dateString);
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 0 && value <= 59;
  } }, { key: "set", value: function(date, _flags, value) {
    return date.setUTCMinutes(value, 0, 0), date;
  } }]), MinuteParser2;
}(), SecondParser = function() {
  _inherits(SecondParser2, Parser$1);
  var _super = _createSuper(SecondParser2);
  function SecondParser2() {
    var _this;
    _classCallCheck(this, SecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 50), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]), _this;
  }
  return _createClass(SecondParser2, [{ key: "parse", value: function(dateString, token, match) {
    switch (token) {
      case "s":
        return parseNumericPattern(numericPatterns_second, dateString);
      case "so":
        return match.ordinalNumber(dateString, { unit: "second" });
      default:
        return parseNDigits(token.length, dateString);
    }
  } }, { key: "validate", value: function(_date, value) {
    return value >= 0 && value <= 59;
  } }, { key: "set", value: function(date, _flags, value) {
    return date.setUTCSeconds(value, 0), date;
  } }]), SecondParser2;
}(), FractionOfSecondParser = function() {
  _inherits(FractionOfSecondParser2, Parser$1);
  var _super = _createSuper(FractionOfSecondParser2);
  function FractionOfSecondParser2() {
    var _this;
    _classCallCheck(this, FractionOfSecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 30), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]), _this;
  }
  return _createClass(FractionOfSecondParser2, [{ key: "parse", value: function(dateString, token) {
    return mapValue(parseNDigits(token.length, dateString), function(value) {
      return Math.floor(value * Math.pow(10, 3 - token.length));
    });
  } }, { key: "set", value: function(date, _flags, value) {
    return date.setUTCMilliseconds(value), date;
  } }]), FractionOfSecondParser2;
}(), ISOTimezoneWithZParser = function() {
  _inherits(ISOTimezoneWithZParser2, Parser$1);
  var _super = _createSuper(ISOTimezoneWithZParser2);
  function ISOTimezoneWithZParser2() {
    var _this;
    _classCallCheck(this, ISOTimezoneWithZParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 10), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "x"]), _this;
  }
  return _createClass(ISOTimezoneWithZParser2, [{ key: "parse", value: function(dateString, token) {
    switch (token) {
      case "X":
        return parseTimezonePattern(timezonePatterns_basicOptionalMinutes, dateString);
      case "XX":
        return parseTimezonePattern(timezonePatterns_basic, dateString);
      case "XXXX":
        return parseTimezonePattern(timezonePatterns_basicOptionalSeconds, dateString);
      case "XXXXX":
        return parseTimezonePattern(timezonePatterns_extendedOptionalSeconds, dateString);
      default:
        return parseTimezonePattern(timezonePatterns_extended, dateString);
    }
  } }, { key: "set", value: function(date, flags, value) {
    return flags.timestampIsSet ? date : new Date(date.getTime() - value);
  } }]), ISOTimezoneWithZParser2;
}(), ISOTimezoneParser = function() {
  _inherits(ISOTimezoneParser2, Parser$1);
  var _super = _createSuper(ISOTimezoneParser2);
  function ISOTimezoneParser2() {
    var _this;
    _classCallCheck(this, ISOTimezoneParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 10), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "X"]), _this;
  }
  return _createClass(ISOTimezoneParser2, [{ key: "parse", value: function(dateString, token) {
    switch (token) {
      case "x":
        return parseTimezonePattern(timezonePatterns_basicOptionalMinutes, dateString);
      case "xx":
        return parseTimezonePattern(timezonePatterns_basic, dateString);
      case "xxxx":
        return parseTimezonePattern(timezonePatterns_basicOptionalSeconds, dateString);
      case "xxxxx":
        return parseTimezonePattern(timezonePatterns_extendedOptionalSeconds, dateString);
      default:
        return parseTimezonePattern(timezonePatterns_extended, dateString);
    }
  } }, { key: "set", value: function(date, flags, value) {
    return flags.timestampIsSet ? date : new Date(date.getTime() - value);
  } }]), ISOTimezoneParser2;
}(), TimestampSecondsParser = function() {
  _inherits(TimestampSecondsParser2, Parser$1);
  var _super = _createSuper(TimestampSecondsParser2);
  function TimestampSecondsParser2() {
    var _this;
    _classCallCheck(this, TimestampSecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 40), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*"), _this;
  }
  return _createClass(TimestampSecondsParser2, [{ key: "parse", value: function(dateString) {
    return parseAnyDigitsSigned(dateString);
  } }, { key: "set", value: function(_date, _flags, value) {
    return [new Date(1e3 * value), { timestampIsSet: true }];
  } }]), TimestampSecondsParser2;
}(), TimestampMillisecondsParser = function() {
  _inherits(TimestampMillisecondsParser2, Parser$1);
  var _super = _createSuper(TimestampMillisecondsParser2);
  function TimestampMillisecondsParser2() {
    var _this;
    _classCallCheck(this, TimestampMillisecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [this].concat(args))), "priority", 20), _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*"), _this;
  }
  return _createClass(TimestampMillisecondsParser2, [{ key: "parse", value: function(dateString) {
    return parseAnyDigitsSigned(dateString);
  } }, { key: "set", value: function(_date, _flags, value) {
    return [new Date(value), { timestampIsSet: true }];
  } }]), TimestampMillisecondsParser2;
}(), parsers = { G: new EraParser(), y: new YearParser(), Y: new LocalWeekYearParser(), R: new ISOWeekYearParser(), u: new ExtendedYearParser(), Q: new QuarterParser(), q: new StandAloneQuarterParser(), M: new MonthParser(), L: new StandAloneMonthParser(), w: new LocalWeekParser(), I: new ISOWeekParser(), d: new DateParser(), D: new DayOfYearParser(), E: new DayParser(), e: new LocalDayParser(), c: new StandAloneLocalDayParser(), i: new ISODayParser(), a: new AMPMParser(), b: new AMPMMidnightParser(), B: new DayPeriodParser(), h: new Hour1to12Parser(), H: new Hour0to23Parser(), K: new Hour0To11Parser(), k: new Hour1To24Parser(), m: new MinuteParser(), s: new SecondParser(), S: new FractionOfSecondParser(), X: new ISOTimezoneWithZParser(), x: new ISOTimezoneParser(), t: new TimestampSecondsParser(), T: new TimestampMillisecondsParser() }, formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, escapedStringRegExp = /^'([^]*?)'?$/, doubleQuoteRegExp = /''/g, notWhitespaceRegExp = /\S/, unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString), formatString = String(dirtyFormatString), defaultOptions = getDefaultOptions(), locale$1 = null !== (_ref = null !== (_options$locale = null == options ? void 0 : options.locale) && void 0 !== _options$locale ? _options$locale : defaultOptions.locale) && void 0 !== _ref ? _ref : locale;
  if (!locale$1.match)
    throw new RangeError("locale must contain match property");
  var firstWeekContainsDate = toInteger(null !== (_ref2 = null !== (_ref3 = null !== (_ref4 = null !== (_options$firstWeekCon = null == options ? void 0 : options.firstWeekContainsDate) && void 0 !== _options$firstWeekCon ? _options$firstWeekCon : null == options || null === (_options$locale2 = options.locale) || void 0 === _options$locale2 || null === (_options$locale2$opti = _options$locale2.options) || void 0 === _options$locale2$opti ? void 0 : _options$locale2$opti.firstWeekContainsDate) && void 0 !== _ref4 ? _ref4 : defaultOptions.firstWeekContainsDate) && void 0 !== _ref3 ? _ref3 : null === (_defaultOptions$local = defaultOptions.locale) || void 0 === _defaultOptions$local || null === (_defaultOptions$local2 = _defaultOptions$local.options) || void 0 === _defaultOptions$local2 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) && void 0 !== _ref2 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var weekStartsOn = toInteger(null !== (_ref5 = null !== (_ref6 = null !== (_ref7 = null !== (_options$weekStartsOn = null == options ? void 0 : options.weekStartsOn) && void 0 !== _options$weekStartsOn ? _options$weekStartsOn : null == options || null === (_options$locale3 = options.locale) || void 0 === _options$locale3 || null === (_options$locale3$opti = _options$locale3.options) || void 0 === _options$locale3$opti ? void 0 : _options$locale3$opti.weekStartsOn) && void 0 !== _ref7 ? _ref7 : defaultOptions.weekStartsOn) && void 0 !== _ref6 ? _ref6 : null === (_defaultOptions$local3 = defaultOptions.locale) || void 0 === _defaultOptions$local3 || null === (_defaultOptions$local4 = _defaultOptions$local3.options) || void 0 === _defaultOptions$local4 ? void 0 : _defaultOptions$local4.weekStartsOn) && void 0 !== _ref5 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  if ("" === formatString)
    return "" === dateString ? toDate(dirtyReferenceDate) : /* @__PURE__ */ new Date(NaN);
  var _step, subFnOptions = { firstWeekContainsDate, weekStartsOn, locale: locale$1 }, setters = [new DateToSystemTimezoneSetter()], tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    return firstCharacter in longFormatters ? (0, longFormatters[firstCharacter])(substring, locale$1.formatLong) : substring;
  }).join("").match(formattingTokensRegExp), usedTokens = [], _iterator = _createForOfIteratorHelper(tokens);
  try {
    var _loop = function() {
      var token = _step.value;
      null != options && options.useAdditionalWeekYearTokens || !isProtectedWeekYearToken(token) || throwProtectedError(token, formatString, dirtyDateString), null != options && options.useAdditionalDayOfYearTokens || !isProtectedDayOfYearToken(token) || throwProtectedError(token, formatString, dirtyDateString);
      var firstCharacter = token[0], parser = parsers[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function(usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });
          if (incompatibleToken)
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
        } else if ("*" === parser.incompatibleTokens && usedTokens.length > 0)
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        usedTokens.push({ token: firstCharacter, fullToken: token });
        var parseResult = parser.run(dateString, token, locale$1.match, subFnOptions);
        if (!parseResult)
          return { v: /* @__PURE__ */ new Date(NaN) };
        options.mxBuddhistCalendar && ["y", "Y"].includes(firstCharacter) && (parseResult.setter.value.year -= 543), setters.push(parseResult.setter), dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp))
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        if ("''" === token ? token = "'" : "'" === firstCharacter && (token = token.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'")), 0 !== dateString.indexOf(token))
          return { v: /* @__PURE__ */ new Date(NaN) };
        dateString = dateString.slice(token.length);
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _ret = _loop();
      if ("object" === _typeof(_ret))
        return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString))
    return /* @__PURE__ */ new Date(NaN);
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a, b) {
    return b - a;
  }).filter(function(priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  }), date = toDate(dirtyReferenceDate);
  if (isNaN(date.getTime()))
    return /* @__PURE__ */ new Date(NaN);
  var _step2, utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date)), flags = {}, _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters);
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var setter = _step2.value;
      if (!setter.validate(utcDate, subFnOptions))
        return /* @__PURE__ */ new Date(NaN);
      var result = setter.set(utcDate, flags, subFnOptions);
      Array.isArray(result) ? (utcDate = result[0], assign$1(flags, result[1])) : utcDate = result;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return utcDate;
}
function toDateFnsPattern(mendixPattern) {
  return replaceSymbols(mendixPattern, [{ existing: "yyy", replacement: "yyyy" }, { existing: "E", replacement: "e" }, { existing: "EE", replacement: "ee" }, { existing: "YYY", replacement: "YYYY" }, { existing: "Z", replacement: "XX" }, { existing: "ZZ", replacement: "XX" }, { existing: "ZZZ", replacement: "XX" }, { existing: "ZZZZ", replacement: "zzzz" }]);
}
function toMendixPattern(runtimePattern) {
  return replaceSymbols(runtimePattern, [{ existing: "GGGG", replacement: "GGG" }, { existing: "GGGGG", replacement: "GGG" }, { existing: "GGGGGG", replacement: "GGG" }, { existing: "MMMMM", replacement: "MMMM" }, { existing: "E", replacement: "EEE" }, { existing: "EE", replacement: "EEE" }, { existing: "EEEEE", replacement: "EEEE" }, { existing: "EEEEEE", replacement: "EEEE" }, { existing: "S", replacement: "SSS" }, { existing: "SS", replacement: "SSS" }, { existing: "SSSS", replacement: "'0'SSS" }, { existing: "SSSSS", replacement: "'00'SSS" }, { existing: "SSSSSS", replacement: "'000'SSS" }, { existing: "W", replacement: "'W'" }, { existing: "WW", replacement: "'WW'" }, { existing: "WWW", replacement: "'WWW'" }, { existing: "WWWW", replacement: "'WWWW'" }, { existing: "WWWWW", replacement: "'WWWWW'" }, { existing: "WWWWWW", replacement: "'WWWWWW'" }, { existing: "F", replacement: "'F'" }, { existing: "FF", replacement: "'FF'" }, { existing: "FFF", replacement: "'FFF'" }, { existing: "FFFF", replacement: "'FFFF'" }, { existing: "FFFFF", replacement: "'FFFFF'" }, { existing: "FFFFFF", replacement: "'FFFFFF'" }, { existing: "Z", replacement: "'Z'" }, { existing: "ZZ", replacement: "'ZZ'" }, { existing: "ZZZ", replacement: "'ZZZ'" }, { existing: "ZZZZ", replacement: "'ZZZZ'" }, { existing: "ZZZZZ", replacement: "'ZZZZZ'" }, { existing: "ZZZZZZ", replacement: "'ZZZZZZ'" }, { existing: "z", replacement: "'z'" }, { existing: "zz", replacement: "'zz'" }, { existing: "zzz", replacement: "'zzz'" }, { existing: "zzzz", replacement: "'zzzz'" }, { existing: "zzzzz", replacement: "'zzzzz'" }, { existing: "zzzzzz", replacement: "'zzzzzz'" }, { existing: "X", replacement: "'X'" }, { existing: "XX", replacement: "'XX'" }, { existing: "XXX", replacement: "'XXX'" }, { existing: "XXXX", replacement: "'XXXX'" }, { existing: "XXXXX", replacement: "'XXXXX'" }, { existing: "XXXXXX", replacement: "'XXXXXX'" }]);
}
function replaceSymbols(haystack, symbols) {
  const result = haystack.match(/''|'(?:''|[^'])+(?:'|$)|(.)\1*/g) ?? [];
  return symbols.reduce((symbolGroups, { existing, replacement }) => symbolGroups.map((value) => value === existing ? replacement : value), result).join("");
}
function shouldUseBuddhistCalendar(languageTag) {
  return /th$/i.test(languageTag);
}
function preformatBuddhistCalendar(locale2, date, pattern) {
  const year = function(dirtyDate) {
    return requiredArgs(1, arguments), toDate(dirtyDate).getFullYear();
  }(date) + 543, weekYear = function(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs(1, arguments);
    var date2 = toDate(dirtyDate), year2 = date2.getFullYear(), defaultOptions = getDefaultOptions(), firstWeekContainsDate = toInteger(null !== (_ref = null !== (_ref2 = null !== (_ref3 = null !== (_options$firstWeekCon = null == options ? void 0 : options.firstWeekContainsDate) && void 0 !== _options$firstWeekCon ? _options$firstWeekCon : null == options || null === (_options$locale = options.locale) || void 0 === _options$locale || null === (_options$locale$optio = _options$locale.options) || void 0 === _options$locale$optio ? void 0 : _options$locale$optio.firstWeekContainsDate) && void 0 !== _ref3 ? _ref3 : defaultOptions.firstWeekContainsDate) && void 0 !== _ref2 ? _ref2 : null === (_defaultOptions$local = defaultOptions.locale) || void 0 === _defaultOptions$local || null === (_defaultOptions$local2 = _defaultOptions$local.options) || void 0 === _defaultOptions$local2 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) && void 0 !== _ref ? _ref : 1);
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7))
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
    firstWeekOfNextYear.setFullYear(year2 + 1, 0, firstWeekContainsDate), firstWeekOfNextYear.setHours(0, 0, 0, 0);
    var startOfNextYear = startOfWeek(firstWeekOfNextYear, options), firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
    firstWeekOfThisYear.setFullYear(year2, 0, firstWeekContainsDate), firstWeekOfThisYear.setHours(0, 0, 0, 0);
    var startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
    return date2.getTime() >= startOfNextYear.getTime() ? year2 + 1 : date2.getTime() >= startOfThisYear.getTime() ? year2 : year2 - 1;
  }(date, { locale: locale2 }) + 543;
  return replaceSymbols(pattern, [{ existing: "yy", replacement: `'${twoDigit(year)}'` }, { existing: "yyyy", replacement: `'${year}'` }, { existing: "YY", replacement: `  ${twoDigit(weekYear)}'` }, { existing: "YYYY", replacement: `'${weekYear}'` }]);
}
function twoDigit(year) {
  return year.toString().slice(-2);
}
function formatDate$1(date, formatterConfig) {
  let pattern = toDateFnsPattern(getDateTimePattern(formatterConfig));
  if (shouldUseBuddhistCalendar(getLocale().languageTag) && (pattern = preformatBuddhistCalendar(getDateFnsLocale(), date, pattern)), pattern.includes("u")) {
    const { startIndex, endIndex, convertedPattern } = convertDayOfWeekPattern(pattern), formattedDate = format(date, convertedPattern, getDateFnsOptions());
    return formattedDate.slice(0, startIndex) + "0".repeat(endIndex - startIndex) + formattedDate.slice(startIndex);
  }
  return format(date, pattern, getDateFnsOptions());
}
function parseDate(value, formatterConfig, fallbackDate = /* @__PURE__ */ new Date()) {
  const datePattern = toDateFnsPattern(getDateTimePattern(formatterConfig)), options = { ...getDateFnsOptions(), mxBuddhistCalendar: shouldUseBuddhistCalendar(getLocale().languageTag) }, twoDigitYearPattern = replaceSymbols(datePattern, [{ existing: "yyyy", replacement: "yy" }]), patterns = [twoDigitYearPattern, datePattern, replaceNonBreakingSpaces(datePattern), replaceNonBreakingSpaces(twoDigitYearPattern)];
  for (const pattern of patterns) {
    const { startIndex, endIndex, convertedPattern } = convertDayOfWeekPattern(pattern), convertedPatternMatchingValue = value.slice(0, startIndex) + value.slice(endIndex);
    try {
      const date = parse(convertedPatternMatchingValue, convertedPattern, fallbackDate, options);
      if (!isNaN(date.getTime()))
        return date;
    } catch {
      continue;
    }
  }
  try {
    const timestamp = Date.parse(value);
    if (!isNaN(timestamp))
      return new Date(value);
  } catch {
    return;
  }
}
function replaceNonBreakingSpaces(s) {
  return s.replace("\xA0", " ").replace("\u2007", " ").replace("\u202F", " ");
}
function getDateTimePattern(formatterConfig = { type: "datetime" }) {
  return "custom" !== formatterConfig.type ? getLocale().patterns[formatterConfig.type] : formatterConfig.pattern;
}
function getDateFormatPlaceholder(formatterConfig) {
  return getDateTimePattern(formatterConfig).replace(/('.*?(?:'|$))|(\w)+/g, (match, group1, group2) => group1 ? "''" === group1 ? "'" : group1.replace(/'/g, "") : "a" === group2 ? getLocale().dates.dayPeriods.join("/") : match.toLowerCase());
}
function getDateFnsOptions() {
  return { useAdditionalDayOfYearTokens: true, useAdditionalWeekYearTokens: true, locale: getDateFnsLocale() };
}
function convertDayOfWeekPattern(pattern) {
  return { startIndex: pattern.indexOf("u"), endIndex: pattern.lastIndexOf("u"), convertedPattern: pattern.replace(/u+/g, "i") };
}

function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate), amount = toInteger(dirtyAmount);
  if (isNaN(amount))
    return /* @__PURE__ */ new Date(NaN);
  if (!amount)
    return date;
  var dayOfMonth = date.getDate(), endOfDesiredMonth = new Date(date.getTime());
  return endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0), dayOfMonth >= endOfDesiredMonth.getDate() ? endOfDesiredMonth : (date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth), date);
}
function addYears(dirtyDate, dirtyAmount) {
  return requiredArgs(2, arguments), addMonths(dirtyDate, 12 * toInteger(dirtyAmount));
}
function subMonths(dirtyDate, dirtyAmount) {
  return requiredArgs(2, arguments), addMonths(dirtyDate, -toInteger(dirtyAmount));
}
function subYears(dirtyDate, dirtyAmount) {
  return requiredArgs(2, arguments), addYears(dirtyDate, -toInteger(dirtyAmount));
}

function parseNumber(text, decimalsCount) {
  const { numbers } = getLocale();
  if (!function(text2, groupingSeparator, decimalSeparator) {
    const decimalPart = `\\${decimalSeparator}\\d+`;
    return Boolean(new RegExp(`^-?((\\d+|\\d{1,3}(?:\\${groupingSeparator}\\d{3})*)(${decimalPart})?|${decimalPart})(e[+-]?\\d+)?$`).exec(text2));
  }(text, numbers.groupingSeparator, numbers.decimalSeparator))
    return;
  let value;
  try {
    value = new Big(text.split(numbers.groupingSeparator).join("").split(numbers.decimalSeparator).join("."));
  } catch {
    return;
  }
  return null != decimalsCount && decimalsCount >= 0 ? value.round(decimalsCount) : value;
}
function formatNumber(value, groupDigits, decimalsCount) {
  const { numbers } = getLocale(), isNegative = value.lt(0), decimalPrecision = void 0 !== decimalsCount && decimalsCount < 0 ? void 0 : decimalsCount;
  let [intPart, decimalPart = ""] = value.toFixed(decimalPrecision).split(".");
  if (!intPart)
    throw new Error(`Value '${value}' cannot be formatted as number.`);
  return isNegative && (intPart = intPart.slice(1)), groupDigits && (intPart = function(digits, groupSize = 3) {
    const parts = [];
    let remainder = digits;
    for (; remainder.length > groupSize; ) {
      const groupPosition = remainder.length - groupSize;
      parts.unshift(remainder.substring(groupPosition)), remainder = remainder.substring(0, groupPosition);
    }
    remainder && parts.unshift(remainder);
    return parts;
  }(intPart).join(numbers.groupingSeparator)), decimalPart && (decimalPart = numbers.decimalSeparator + decimalPart), (isNegative ? numbers.minusSign : "") + intPart + decimalPart;
}
function formatValue(value, type, config) {
  if (void 0 === value)
    return "";
  switch (type) {
    case "Decimal":
    case "Integer":
    case "Long":
      if (!(value instanceof Big))
        throw new Error(`Value '${value}' cannot be formatted as a numeric value.`);
      const numberConfig = config, groupDigits = numberConfig?.groupDigits, decimalPrecision = numberConfig?.decimalPrecision;
      return formatNumber(value, groupDigits, decimalPrecision);
    case "DateTime":
      if (!(value instanceof Date))
        throw new Error(`Value '${value}' cannot be formatted as Date.`);
      return formatDate$1(value, config);
    case "Boolean":
      return translate("mxui.common", value.toString());
    default:
      return String(value);
  }
}

function addHours(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, 36e5 * amount);
}
function addMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, 6e4 * amount);
}
function addQuarters(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, 3 * amount);
}
function addSeconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, 1e3 * amount);
}
function addWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, 7 * amount);
}
const dirtyGuids = /* @__PURE__ */ new Set();
function markAsDirty(guids) {
  guids.forEach((guid) => dirtyGuids.add(guid));
}
function unmarkAsDirty(guids) {
  guids.forEach((guid) => dirtyGuids.delete(guid));
}
function clearDirtyGuids() {
  dirtyGuids.clear();
}
function isDirtyGuid(guid) {
  return dirtyGuids.has(guid);
}
class AccessDeniedError extends Error {
  constructor(variableName, entityName, attributeName) {
    super(`Unable to get a member from variable $${variableName}, because you do not have sufficient permissions to "${entityName}.${attributeName}".`), this.variableName = variableName, this.entityName = entityName, this.attributeName = attributeName, Object.setPrototypeOf(this, AccessDeniedError.prototype);
  }
}
class EmptyVariableAccessError extends Error {
  constructor(variableName) {
    super(`Unable to get a member from an empty variable $${variableName}.`), this.variableName = variableName, Object.setPrototypeOf(this, EmptyVariableAccessError.prototype);
  }
}
let synchronizationInProgress = false;
async function runInSynchronizationLock(fn) {
  if (synchronizationInProgress)
    throw new DescribedError(translate("mxui.sys.UI", "simultaneous_sync_error"));
  synchronizationInProgress = true, await publish({ param: "synchronizationState" });
  try {
    return await fn();
  } finally {
    synchronizationInProgress = false, await publish({ param: "synchronizationState" });
  }
}
function operationErrorText(operator, ...args) {
  return `Operator ${operator} not supported in expression ${operator}(${args.join(", ")})`;
}
function toNumber(expressionResult) {
  const number = Number(expressionResult);
  if (isNaN(number))
    throw new AssertionError("Unexpected expression value");
  return number;
}
const betweenMonthsYearsFunctionMap = { calendarMonthsBetween: function(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft), dateRight = toDate(dirtyDateRight);
  return 12 * (dateLeft.getFullYear() - dateRight.getFullYear()) + (dateLeft.getMonth() - dateRight.getMonth());
}, calendarYearsBetween: function(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft), dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() - dateRight.getFullYear();
} }, addFunctionMap = { addMilliseconds, addSeconds, addMinutes, addHours, addDays, addWeeks, addMonths, addQuarters, addYears }, beginOfFunctionMap = { beginOfDay: startOfDay, beginOfMonth: startOfMonth, beginOfYear: startOfYear }, endOfFunctionMap = { endOfDay, endOfMonth, endOfYear }, beginEndOfWeekFunctionMap = { beginOfWeek: startOfWeek, endOfWeek }, subFunctionMap = { subtractMilliseconds: subMilliseconds, subtractSeconds: function(dirtyDate, dirtyAmount) {
  return requiredArgs(2, arguments), addSeconds(dirtyDate, -toInteger(dirtyAmount));
}, subtractMinutes: function(dirtyDate, dirtyAmount) {
  return requiredArgs(2, arguments), addMinutes(dirtyDate, -toInteger(dirtyAmount));
}, subtractHours: function(dirtyDate, dirtyAmount) {
  return requiredArgs(2, arguments), addHours(dirtyDate, -toInteger(dirtyAmount));
}, subtractDays: subDays, subtractWeeks: function(dirtyDate, dirtyAmount) {
  return requiredArgs(2, arguments), addWeeks(dirtyDate, -toInteger(dirtyAmount));
}, subtractMonths: subMonths, subtractQuarters: function(dirtyDate, dirtyAmount) {
  return requiredArgs(2, arguments), addQuarters(dirtyDate, -toInteger(dirtyAmount));
}, subtractYears: subYears }, trimFunctionMap = { trimToSeconds: function(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return date.setMilliseconds(0), date;
}, trimToMinutes: startOfMinute, trimToHours: startOfHour, trimToDays: startOfDay, trimToMonths: startOfMonth, trimToYears: startOfYear }, expressionDateFunctions = { dateTime: (...args) => evaluateCreateDateTime(args, false, () => operationErrorText("dateTime", ...args)), dateTimeUTC: (...args) => evaluateCreateDateTime(args, true, () => operationErrorText("dateTimeUTC", ...args)), dateTimeToEpoch(arg) {
  if (arg instanceof Date)
    return new Big(arg.getTime());
  throw new Error(operationErrorText("dateTimeToEpoch", arg));
}, epochToDateTime(arg) {
  if (arg instanceof Big)
    return new Date(Number(arg));
  throw new Error(operationErrorText("epochToDateTime", arg));
}, ...createExpressionFunctionCollection({ millisecondsBetween: 1, secondsBetween: 1e3, minutesBetween: 6e4, hoursBetween: 36e5, daysBetween: 864e5, weeksBetween: 6048e5 }, function(args, scale, getErrorText) {
  const firstDate = args[0], secondDate = args[1];
  if (firstDate instanceof Date && secondDate instanceof Date) {
    return new Big(firstDate.getTime()).sub(secondDate.getTime()).abs().div(scale);
  }
  throw new Error(getErrorText());
}, false), ...createExpressionFunctionCollection(betweenMonthsYearsFunctionMap, function(args, betweenFunction, getErrorText) {
  const [date1, date2] = args;
  if (date1 instanceof Date && date2 instanceof Date)
    return new Big(betweenFunction(date1, date2)).abs();
  throw new Error(getErrorText());
}, false), ...createExpressionFunctionCollection(addFunctionMap, evaluateDateAddOrSubtract, true), ...createExpressionFunctionCollection(beginOfFunctionMap, evaluateBeginOrEndOf, false), ...createExpressionFunctionCollection(beginEndOfWeekFunctionMap, function(args, dateFunction, getErrorText) {
  const date = args[0];
  if (date instanceof Date)
    return dateFunction(date, { locale: getDateFnsLocale() });
  throw new Error(getErrorText());
}, false), ...createExpressionFunctionCollection(endOfFunctionMap, evaluateBeginOrEndOf, false), ...createExpressionFunctionCollection(subFunctionMap, evaluateDateAddOrSubtract, true), ...createExpressionFunctionCollection(trimFunctionMap, function(args, trimFunction, getErrorText, utc) {
  let date = args[0];
  if (date instanceof Date) {
    utc && (date = localizeDate(date));
    let newDate = trimFunction(date);
    return utc && (newDate = delocalizeDate(newDate)), newDate;
  }
  throw new Error(getErrorText());
}, true) };
function evaluateCreateDateTime(args, utc, getErrorText) {
  const numbers = args.map((arg) => {
    if (arg instanceof Big)
      return Number(arg);
    throw new Error(getErrorText());
  });
  return 1 === numbers.length && numbers.push(1), numbers[1] = ensure(numbers[1]) - 1, utc ? new Date(Date.UTC(...numbers)) : new Date(...numbers);
}
function evaluateDateAddOrSubtract(args, addFunction, getErrorText, utc) {
  let date = args[0];
  const add = args[1];
  if (date instanceof Date && add instanceof Big) {
    utc && (date = localizeDate(date));
    let newDate = addFunction(date, Number(add));
    return utc && (newDate = delocalizeDate(newDate)), newDate;
  }
  throw new Error(getErrorText());
}
function evaluateBeginOrEndOf(args, dateFunction, getErrorText) {
  const date = args[0];
  if (date instanceof Date)
    return dateFunction(date);
  throw new Error(getErrorText());
}
function createExpressionFunctionCollection(functionMap, evaluator2, utcVariant) {
  return Object.entries(functionMap).reduce((collection, [name, parameter]) => {
    if (collection[name] = (...args) => evaluator2(args, parameter, () => operationErrorText(name, ...args)), utcVariant) {
      const utcName = `${name}UTC`;
      collection[utcName] = (...args) => evaluator2(args, parameter, () => operationErrorText(utcName, ...args), true);
    }
    return collection;
  }, {});
}
const expressionFormatFunctions = { toString: (arg) => arg instanceof Big ? arg.toString() : void 0 === arg ? "" : arg instanceof Date ? formatDate$1(arg, { type: "datetime" }) : String(arg), parseInteger(arg, defaultValue) {
  if ("string" == typeof arg) {
    if (/^-?\d+$/.test(arg)) {
      const result = new Big(arg);
      return result.eq(-0) ? result.abs() : result;
    }
    if (void 0 === defaultValue)
      throw new Error(`Not parsable to Integer: ${arg}`);
    return defaultValue;
  }
  throw new Error(operationErrorText("parseInteger", arg));
}, parseDecimal(arg, defaultValue) {
  if ("string" == typeof arg) {
    const parsed = parseNumber(arg);
    if (void 0 === parsed && void 0 === defaultValue)
      throw new Error(`Not parsable to Decimal: ${arg}`);
    return parsed ?? defaultValue;
  }
  throw new Error(operationErrorText("parseDecimal", arg));
}, formatDecimal(arg) {
  if (arg instanceof Big)
    return formatNumber(arg);
  throw new Error(operationErrorText("formatDecimal", arg));
}, parseDateTime: (...args) => evaluateParseDateTime(args, false, operationErrorText("parseDateTime", ...args)), parseDateTimeUTC: (...args) => evaluateParseDateTime(args, true, operationErrorText("parseDateTimeUTC", ...args)), formatDate: (arg) => evaluateFormatDate(arg, { type: "date" }, false, operationErrorText("formatDate", arg)), formatDateUTC: (arg) => evaluateFormatDate(arg, { type: "date" }, true, operationErrorText("formatDateUTC", arg)), formatTime: (arg) => evaluateFormatDate(arg, { type: "time" }, false, operationErrorText("formatTime", arg)), formatTimeUTC: (arg) => evaluateFormatDate(arg, { type: "time" }, true, operationErrorText("formatTimeUTC", arg)), formatDateTime: (...args) => evaluateFormatDate(args[0], toFormatterConfig(args[1]), false, operationErrorText("formatDateTime", ...args)), formatDateTimeUTC: (...args) => evaluateFormatDate(args[0], toFormatterConfig(args[1]), true, operationErrorText("formatDateTimeUTC", ...args)), getCaption(arg, enumeration) {
  if (void 0 === arg)
    return "";
  if ("string" == typeof arg && "string" == typeof enumeration)
    return translateEnumeration(enumeration, arg);
  throw new Error(operationErrorText("getCaption", arg, enumeration));
}, getKey(arg) {
  if (void 0 === arg)
    return "";
  if ("string" == typeof arg)
    return arg;
  throw new Error(operationErrorText("getKey", arg));
}, _format(arg, formatStr) {
  if ("string" == typeof formatStr) {
    const format = JSON.parse(formatStr), type = arg instanceof Big ? "Decimal" : arg instanceof Date ? "DateTime" : "boolean" == typeof arg ? "Boolean" : "String";
    return formatValue(arg, type, format);
  }
  throw new Error(operationErrorText("_format", arg, formatStr));
} };
function evaluateParseDateTime(args, utc, errorText) {
  const [value, pattern, fallback] = args;
  if ("string" == typeof value && "string" == typeof pattern) {
    const parsed = parseDate(value.trim(), { type: "custom", pattern: toMendixPattern(pattern.trim()) });
    if (parsed instanceof Date)
      return utc ? delocalizeDate(parsed) : parsed;
    if (fallback instanceof Date)
      return fallback;
    throw new Error(`Unparseable date: "${value}"`);
  }
  throw new Error(errorText);
}
function evaluateFormatDate(arg, formatterConfig, utc, errorText) {
  if (arg instanceof Date)
    return utc && (arg = localizeDate(arg)), "custom" !== formatterConfig.type && (formatterConfig = { type: "custom", pattern: getLocale().nanoflowPatterns[formatterConfig.type] }), formatDate$1(arg, formatterConfig);
  throw new Error(errorText);
}
function toFormatterConfig(pattern) {
  return "string" == typeof pattern ? { type: "custom", pattern: toMendixPattern(pattern) } : { type: "datetime" };
}
const expressionListFunctions = { _newList: () => [], _toList: (arg1) => asList(arg1, operationErrorText("_toList", arg1)), _addToList(arg1, arg2) {
  const arr1 = asList(arg1, operationErrorText("_addToList", arg1, arg2)), arr2 = asList(arg2, operationErrorText("_addToList", arg1, arg2));
  return arr1.concat(arr2);
}, _removeFromList(arg1, arg2) {
  const arr1 = asList(arg1, operationErrorText("_removeFromList", arg1, arg2)), arr2 = asList(arg2, operationErrorText("_removeFromList", arg1, arg2));
  return arr1.filter((guid) => !arr2.includes(guid));
}, _unionLists(arg1, arg2) {
  const arr1 = asList(arg1, operationErrorText("_unionLists", arg1, arg2)), arr2 = asList(arg2, operationErrorText("_unionLists", arg1, arg2));
  return arr1.concat(arr2.filter((guid) => !arr1.includes(guid)));
}, _intersectLists(arg1, arg2) {
  const arr1 = asList(arg1, operationErrorText("_intersectLists", arg1, arg2)), arr2 = asList(arg2, operationErrorText("_intersectLists", arg1, arg2));
  return arr1.filter((guid) => arr2.includes(guid));
}, _listContains(arg1, arg2) {
  const arr1 = asList(arg1, operationErrorText("_listContains", arg1, arg2)), arr2 = asList(arg2, operationErrorText("_listContains", arg1, arg2));
  return arr2.length > 0 && arr2.every((guid) => arr1.includes(guid));
}, _head(arg1) {
  if (arg1 instanceof Array)
    return arg1.length > 0 ? arg1[0] : void 0;
  if (void 0 !== arg1)
    throw new Error(operationErrorText("_head", arg1));
} };
function asList(arg, errorText) {
  if (arg instanceof Array)
    return arg;
  if (isString(arg))
    return arg.length > 0 ? [arg] : [];
  if (void 0 === arg)
    return [];
  throw new Error(errorText);
}
const expressionStringFunctions = { toUpperCase: (arg1) => asString(arg1).toUpperCase(), toLowerCase: (arg1) => asString(arg1).toLowerCase(), trim: (arg1) => asString(arg1).trim(), startsWith: (arg1, arg2) => (arg1 = asString(arg1), arg2 = asString(arg2), arg1.substr(0, arg2.length) === arg2), endsWith: (arg1, arg2) => (arg1 = asString(arg1), arg2 = asString(arg2), arg1.substr(arg1.length - arg2.length) === arg2), substring(arg1, arg2, arg3) {
  if (arg1 = asString(arg1), arg2?.gte(0)) {
    if (2 === arguments.length)
      return arg1.substr(Number(arg2));
    if (arg3?.gte(0))
      return arg1.substr(Number(arg2), Number(arg3));
  }
  throw new Error(operationErrorText("substring", arg1, arg2, arg3));
}, find(arg1, arg2, arg3) {
  if (arg1 = asString(arg1), arg2 = asString(arg2), 2 === arguments.length)
    return new Big(arg1.indexOf(arg2));
  if (void 0 !== arg3)
    return new Big(arg1.indexOf(arg2, Number(arg3)));
  throw new Error(operationErrorText("find", arg1, arg2, arg3));
}, findLast(arg1, arg2, arg3) {
  if (arg1 = asString(arg1), arg2 = asString(arg2), 2 === arguments.length)
    return new Big(arg1.lastIndexOf(arg2));
  if (void 0 !== arg3)
    return new Big(arg1.lastIndexOf(arg2, Number(arg3)));
  throw new Error(operationErrorText("findLast", arg1, arg2, arg3));
}, urlEncode: (arg1) => encodeURIComponent(asString(arg1)).replace("%20", "+"), urlDecode: (arg1) => decodeURIComponent(asString(arg1).replace("+", "%20")), isMatch(arg1, arg2) {
  if (void 0 !== arg2)
    return new RegExp(`^(${arg2})$`).test(asString(arg1));
  throw new Error(operationErrorText("isMatch", arg1, arg2));
}, replaceFirst(arg1, arg2, arg3) {
  if (void 0 !== arg2 && void 0 !== arg3) {
    const escapedForReplaceValue = arg3.replace(/\$/g, "$$$$");
    return asString(arg1).replace(new RegExp(arg2), escapedForReplaceValue);
  }
  throw new Error(operationErrorText("replaceFirst", arg1, arg2));
}, replaceAll(arg1, arg2, arg3) {
  if (void 0 !== arg2 && void 0 !== arg3) {
    const escapedForReplaceValue = arg3.replace(/\$/g, "$$$$");
    return asString(arg1).replace(new RegExp(arg2, "g"), escapedForReplaceValue);
  }
  throw new Error(operationErrorText("replaceAll", arg1, arg2));
} };
function asString(arg) {
  return void 0 === arg ? "" : arg;
}
const expressionLogicFunctions = { not: (arg) => !arg, "=": (arg1, arg2) => arg1 instanceof Big && arg2 instanceof Big ? arg1.eq(arg2) : arg1 instanceof Date && arg2 instanceof Date ? arg1.getTime() === arg2.getTime() : "string" == typeof arg1 || "string" == typeof arg2 ? (arg1 ?? "") === (arg2 ?? "") : arg1 instanceof Array && arg2 instanceof Array ? arg1.length === arg2.length && arg1.every((elem) => arg2.includes(elem)) : arg1 instanceof Array && void 0 === arg2 ? 0 === arg1.length : void 0 === arg1 && arg2 instanceof Array ? 0 === arg2.length : arg1 === arg2, "!=": (arg1, arg2) => !expressionLogicFunctions["="](arg1, arg2), ">"(arg1, arg2) {
  if (arg1 instanceof Big && arg2 instanceof Big)
    return arg1.gt(arg2);
  if (arg1 instanceof Date && arg2 instanceof Date)
    return arg1.getTime() > arg2.getTime();
  if (void 0 === arg1 || void 0 === arg2)
    throw new Error(operationErrorText(">", arg1, arg2));
  return arg1 > arg2;
}, ">=": (arg1, arg2) => expressionLogicFunctions["="](arg1, arg2) || expressionLogicFunctions[">"](arg1, arg2), "<"(arg1, arg2) {
  if (arg1 instanceof Big && arg2 instanceof Big)
    return arg1.lt(arg2);
  if (arg1 instanceof Date && arg2 instanceof Date)
    return arg1.getTime() < arg2.getTime();
  if (void 0 === arg1 || void 0 === arg2)
    throw new Error(operationErrorText("<", arg1, arg2));
  return arg1 < arg2;
}, "<=": (arg1, arg2) => expressionLogicFunctions["="](arg1, arg2) || expressionLogicFunctions["<"](arg1, arg2), contains: (arg1, arg2) => arg1 instanceof Array && "string" == typeof arg2 ? arg1.includes(arg2) : arg1 instanceof Array && arg2 instanceof Array ? arg2.every((elem) => arg1.includes(elem)) : asString(arg1).includes(asString(arg2)) }, expressionMathFunctions = { "+"(arg1, arg2) {
  if (arg1 instanceof Big && arg2 instanceof Big)
    return arg1.plus(arg2);
  if ("string" == typeof arg1)
    return arg1 + (void 0 !== arg2 ? arg2.toString() : "");
  if ("string" == typeof arg2)
    return (void 0 !== arg1 ? arg1.toString() : "") + arg2;
  throw new Error(operationErrorText("+", arg1, arg2));
}, "-"(arg1, arg2) {
  if (1 === arguments.length && void 0 !== arg1)
    return arg1.times(-1);
  if (void 0 !== arg1 && void 0 !== arg2)
    return arg1.minus(arg2);
  throw new Error(operationErrorText("-", arg1, arg2));
}, "*"(arg1, arg2) {
  if (void 0 !== arg1 && void 0 !== arg2)
    return arg1.times(arg2);
  throw new Error(operationErrorText("*", arg1, arg2));
}, div(arg1, arg2) {
  if (void 0 !== arg1 && void 0 !== arg2)
    return arg1.div(arg2);
  throw new Error(operationErrorText("div", arg1, arg2));
}, mod(arg1, arg2) {
  if (void 0 !== arg1 && void 0 !== arg2)
    return arg1.mod(arg2);
  throw new Error(operationErrorText("mod", arg1, arg2));
}, ":": (arg1, arg2) => expressionMathFunctions.div(arg1, arg2), max(...args) {
  if (args[0] instanceof Big)
    return args.reduce((n1, n2) => n1.gt(n2) ? n1 : n2);
  if (args[0] instanceof Date)
    return args.reduce((d1, d2) => d1.getTime() > d2.getTime() ? d1 : d2);
  throw new Error(operationErrorText("max", ...args));
}, min(...args) {
  if (args[0] instanceof Big)
    return args.reduce((n1, n2) => n1.lt(n2) ? n1 : n2);
  if (args[0] instanceof Date)
    return args.reduce((d1, d2) => d1.getTime() < d2.getTime() ? d1 : d2);
  throw new Error(operationErrorText("min", ...args));
}, round(arg, dp) {
  if (arg instanceof Big)
    return arg.round(void 0 === dp ? 0 : Number(dp));
  throw new Error(operationErrorText("round", arg));
}, random: () => new Big(Math.random()), floor(arg) {
  if (arg instanceof Big) {
    const fractional = arg.mod(1);
    return fractional.eq(0) ? arg.eq(-0) ? arg.abs() : arg : arg.minus(fractional).minus(arg.lt(0) ? 1 : 0);
  }
  throw new Error(operationErrorText("floor", arg));
}, ceil(arg) {
  if (arg instanceof Big) {
    const result = expressionMathFunctions.floor(arg.times(-1));
    return result.eq(0) ? result : result.times(-1);
  }
  throw new Error(operationErrorText("ceil", arg));
}, pow(arg, exponent) {
  if (arg instanceof Big && exponent instanceof Big)
    return Number(exponent) === Math.floor(Number(exponent)) ? arg.pow(Number(exponent)) : new Big(Math.pow(Number(arg), Number(exponent)));
  throw new Error(operationErrorText("pow", arg));
}, abs(arg) {
  if (arg instanceof Big)
    return arg.abs();
  throw new Error(operationErrorText("abs", arg));
}, sqrt(arg) {
  if (arg instanceof Big && arg.gte(0))
    return arg.sqrt();
  throw new Error(operationErrorText("sqrt", arg));
} }, expressionFunctions = { ...expressionDateFunctions, ...expressionListFunctions, ...expressionLogicFunctions, ...expressionMathFunctions, ...expressionStringFunctions, ...expressionFormatFunctions, length: (arg1) => Array.isArray(arg1) ? new Big(arg1.length) : new Big(asString(arg1).length), isNew: (arg) => void 0 !== arg && getData().isNew(arg), isSynced(arg) {
  if (void 0 !== arg)
    return !isDirtyGuid(arg);
  throw new Error(operationErrorText("isSynced", arg));
}, isSyncing: { fn: () => synchronizationInProgress, staticDependencies: [{ param: "synchronizationState" }] }, _hasSomeRole: (...args) => getSession().hasSomeRole(args), _isNamedUser: () => !getSession().isGuest(), _catchEmptyVar: { fn: (arg1, arg2) => arg1 ?? arg2, errorHandler: (error, argIndex) => 0 === argIndex && error instanceof EmptyVariableAccessError ? { value: void 0 } : void 0 } };
const getExpressionFunction = (functionsCollection = expressionFunctions, (name) => {
  const fn = functionsCollection[name];
  if (function(fn2) {
    return "object" == typeof fn2 && null !== fn2 ? !(!("fn" in fn2) || "function" != typeof fn2.fn || "staticDependencies" in fn2 && !Array.isArray(fn2.staticDependencies) || "errorHandler" in fn2 && "function" != typeof fn2.errorHandler) : "function" == typeof fn2;
  }(fn))
    return fn;
  throw new Error(`Function ${name} is not known`);
});
var functionsCollection;
function mapMaybePromise(values, handle) {
  return values.some((v) => v instanceof Promise) ? Promise.all(values).then(handle) : handle(values);
}
class ExpressionContext {
  constructor(getVariable, config) {
    this.getVariable = getVariable, this.dependencies = [];
    const { trackDependencies = true, allowEmptyVariablesAccess = false } = config ?? {};
    this.trackDependencies = trackDependencies, this.allowEmptyVariableAccess = allowEmptyVariablesAccess;
  }
  resolveVariable(name) {
    const variable = this.getVariable(name);
    return this.trackDependencies && (isArrayOf(MxObject, variable) ? variable.forEach((obj) => this.addDependency({ guid: obj.getGuid() })) : variable instanceof MxObject && this.addDependency({ guid: variable.getGuid() })), expressionVariableToAttributeValue(variable);
  }
  resolveAttribute(variable, attribute) {
    const value = this.resolveWidgetVariable(variable);
    return value instanceof Promise ? value.then((obj) => void 0 === obj ? void 0 : this.resolveAttributeOf(obj, attribute, variable)) : void 0 === value ? void 0 : this.resolveAttributeOf(value, attribute, variable);
  }
  async resolvePath(variable, path) {
    const steps = path.split("/"), attribute = steps.length % 2 == 1 ? steps.pop() : void 0, objectVariable = await this.resolveWidgetVariable(variable);
    if (void 0 === objectVariable)
      return objectVariable;
    let objects = [objectVariable], resultIsList = false, lastEntity = ensure(objects[0]).getEntity();
    for (let i = 0; i < steps.length; i += 2) {
      const association = steps[i], entity = steps[i + 1], associationType = getAttributeType$1(lastEntity, association);
      if (!associationType)
        throw new AccessDeniedError(variable, lastEntity, association);
      "ObjectReferenceSet" === associationType && (resultIsList = true);
      const previousEntity = lastEntity;
      lastEntity = entity;
      const partialChildObjects = uniqueBy(objects.flatMap((obj) => {
        if (!obj.has(association))
          throw new AccessDeniedError(variable, previousEntity, association);
        return obj.getChildren(association);
      }), (o) => o.getGuid());
      if (partialChildObjects.length) {
        objects = partialChildObjects.filter((obj) => obj.isA(entity));
        continue;
      }
      const references = unique(objects.flatMap((obj) => {
        if (this.addDependency({ guid: obj.getGuid(), attr: association }), !obj.has(association))
          throw new AccessDeniedError(variable, previousEntity, association);
        return obj.getReferences(association);
      }));
      this.trackDependencies && references.forEach((guid) => this.addDependency({ guid })), objects = (await getByGuids(references)).filter((obj) => obj.isA(entity));
    }
    if (void 0 === attribute) {
      const guids = objects.map((o) => o.getGuid());
      return resultIsList ? guids : guids[0];
    }
    if (resultIsList)
      throw new AssertionError();
    return objects.length ? this.resolveAttributeOf(ensure(objects[0]), attribute, variable) : void 0;
  }
  getDependencies() {
    return this.dependencies.slice();
  }
  resolveWidgetVariable(variable) {
    const value = this.getVariable(variable);
    if (this.checkEmptyVariableAccess(value, variable), void 0 !== value) {
      if (value instanceof MxObject)
        return this.addDependency({ guid: value.getGuid() }), value;
      if ("string" == typeof value) {
        const guid = value;
        return this.addDependency({ guid }), getByGuid(guid).then((o) => (this.checkEmptyVariableAccess(o, variable), o));
      }
      throw new AssertionError();
    }
  }
  checkEmptyVariableAccess(value, variable) {
    if (void 0 === value && !this.allowEmptyVariableAccess)
      throw new EmptyVariableAccessError(variable);
  }
  resolveAttributeOf(obj, attribute, variable) {
    if ("type" === attribute)
      return obj.getEntity();
    if (!obj.has(attribute))
      throw new AccessDeniedError(variable, obj.getEntity(), attribute);
    return this.addDependency({ guid: obj.getGuid(), attr: attribute }), obj.get2(attribute);
  }
  addDependency(dependency) {
    if (!this.trackDependencies)
      return;
    this.dependencies.find((dep) => deepEqual(dep, dependency)) || this.dependencies.push(dependency);
  }
}
const logger$3 = LogManager.get().getLogger(), evaluator = new class {
  constructor(getExpressionFunction2, expressionTokens, getConstants) {
    this.getExpressionFunction = getExpressionFunction2, this.expressionTokens = expressionTokens, this.getConstants = getConstants;
  }
  evaluate(expr, context) {
    switch (expr.type) {
      case "variable":
        return expr.path ? expr.path.includes("/") ? context.resolvePath(expr.variable, expr.path) : context.resolveAttribute(expr.variable, expr.path) : context.resolveVariable(expr.variable);
      case "conditional":
        return mapMaybePromise([this.evaluate(expr.condition, context)], ([conditionValue]) => this.evaluate(conditionValue ? expr.then : expr.else, context));
      case "function":
        const fn = this.getExpressionFunction(expr.name), errorHandler = function(fn2) {
          return "errorHandler" in fn2;
        }(fn) ? fn.errorHandler : void 0;
        return mapMaybePromise(function(evaluator2, context2, expressions, errorHandler2) {
          const parameters = [];
          let seenPromise = false;
          return expressions.forEach((exp, i) => {
            let result;
            try {
              result = evaluator2.evaluate(exp, context2), result instanceof Promise && (result = result.then(void 0, (e) => {
                const handledError = errorHandler2?.(e, i);
                return handledError ? Promise.resolve(handledError.value) : Promise.reject(e);
              }), seenPromise = true);
            } catch (e) {
              const handledError = errorHandler2?.(e, i);
              if (handledError)
                result = handledError.value;
              else {
                if (!seenPromise)
                  throw e;
                result = Promise.reject(e);
              }
            }
            parameters.push(result);
          }), parameters;
        }(this, context, expr.parameters, errorHandler), (values) => {
          const functionBody = "fn" in fn ? fn.fn : fn;
          return function(fn2) {
            return "staticDependencies" in fn2;
          }(fn) && fn.staticDependencies.forEach((dependency) => {
            context.addDependency(dependency);
          }), functionBody(...values);
        });
      case "literalNumeric":
        return new Big(expr.value);
      case "literal":
        return expr.value ?? void 0;
      case "token":
        return ensure(this.expressionTokens[expr.name])();
      case "constant":
        const constant = ensure(this.getConstants().find(({ name }) => expr.name === name));
        return runtimeValueToAttributeValue(constant.value, constant.type);
    }
  }
}(getExpressionFunction, createExpressionTokens(() => /* @__PURE__ */ new Date()), () => getSession().getConstants());
function evaluateFormExpression(expression, args) {
  const expressionContext = new ExpressionContext((param) => ensure(args[param])());
  return function(value) {
    if (value instanceof Promise)
      throw new AssertionError();
    return value;
  }(evaluator.evaluate(expression.expr, expressionContext));
}
async function evaluateActionExpression(expression, args) {
  const expressionContext = new ExpressionContext((param) => actionArgumentToExpressionVariable(args[param]));
  return evaluator.evaluate(expression, expressionContext);
}
async function evaluateExpressionValue(expression, currentObject) {
  const expressionContext = new ExpressionContext((name) => "currentObject" === name ? currentObject : crash(), { trackDependencies: false });
  return evaluator.evaluate(expression, expressionContext);
}
async function evaluateFlowExpression(expr, scope, resultKind) {
  const exprResult = await evaluator.evaluate(expr, new ExpressionContext((name) => scope.get(name), { trackDependencies: false, allowEmptyVariablesAccess: true }));
  switch (resultKind) {
    case "primitive":
      return exprResult;
    case "list":
      return Array.isArray(exprResult) ? getByGuids(exprResult) : void 0 === exprResult ? [] : crash();
    case "object":
      return "string" == typeof exprResult ? getByGuid(exprResult) : void 0 === exprResult ? void 0 : crash();
  }
}
function getFormExpressionResultFromStore$(description, expression, store, extraArgs = {}) {
  return getFormExpressionResult$(description, store, expression, (variable) => getVariableFromStore$(description, store, variable), extraArgs);
}
function getVariableFromStore$(description, store, variable) {
  isStoreVariableSource(variable) || crash();
  const { widget: widgetId, source } = variable, [object$] = store.useSlot(widgetId, source);
  return fromComputation$(`Parameter of ${lowerCaseFirst(description)}: ${toFriendlyId(widgetId)}`, () => object$.dependOn() ?? ("object" === source || "localvariable" === source ? loading() : void 0));
}
function isStoreVariableSource(variable) {
  return "actionvariable" !== variable.source;
}
function getFormExpressionResult$(description, store, expression, resolveWidgetVariable, extraArgs = {}) {
  const objectArgs = mapValues(expression.args, resolveWidgetVariable), [recomputationTrigger$, triggerRecomputation] = useValue(`Dependencies of ${lowerCaseFirst(description)}`, {}), resultAndDependencies$ = fromRequest$(`Computation of ${lowerCaseFirst(description)}`, () => {
    recomputationTrigger$.dependOn();
    const dependencies = [], expressionContext = new ExpressionContext((param) => {
      if (containsKey(param, extraArgs)) {
        const extraArg = ensure(extraArgs[param]);
        return dependencies.push(() => extraArg.dependOn()), readUntracked(extraArg);
      }
      const expressionArg = ensure(objectArgs[param]);
      dependencies.push(() => expressionArg.dependOn());
      const expressionArgValue = readUntracked(expressionArg);
      if (expressionArgValue && "object" == typeof expressionArgValue && "status" in expressionArgValue) {
        if ("loading" === expressionArgValue.status)
          throw new LoadingVariableError();
        return "available" === expressionArgValue.status ? expressionArgValue.value instanceof MxObject && expressionArgValue.value.isUnavailable() ? void 0 : expressionArgValue.value : void 0;
      }
      return expressionArgValue;
    });
    try {
      const result = evaluator.evaluate(expression.expr, expressionContext);
      return result instanceof Promise ? [toResult(loading()), result.then((r) => toResult(available(r)), onError)] : toResult(available(result));
    } catch (e) {
      return onError(e);
    }
    function toResult(result) {
      return dependencies.push(...expressionContext.getDependencies().map((sub) => () => dependOnSubscription(sub, store))), available(tuple(result, dependencies));
    }
    function onError(e) {
      return e instanceof LoadingVariableError ? toResult(loading()) : e instanceof AccessDeniedError || e instanceof EmptyVariableAccessError ? (logger$3.debug(`An error occurred while evaluating ${lowerCaseFirst(description)}: ${e.message}`), toResult(unavailable())) : (handleError(new Error(`An error occurred while evaluating ${lowerCaseFirst(description)}: ${e instanceof Error ? e.message : e}`)), toResult(unavailable()));
    }
  }), previousResultAndDependencies$ = getPreviousValue$(resultAndDependencies$);
  return fromComputation$(description, () => {
    const resultAndDependencies = resultAndDependencies$.dependOn();
    if ("available" !== resultAndDependencies.status)
      throw new AssertionError();
    return resultAndDependencies.value[1].forEach((dep) => dep()), resultAndDependencies === previousResultAndDependencies$.dependOn() && scheduleSideEffect(action(() => triggerRecomputation({}))), resultAndDependencies.value[0];
  });
}
class LoadingVariableError extends Error {
  constructor() {
    super(), Object.setPrototypeOf(this, LoadingVariableError.prototype);
  }
}

const expressionTokens = createExpressionTokens(() => /* @__PURE__ */ new Date());
function toQueryFilter(constraint, getVariable) {
  switch (constraint.type) {
    case "attribute":
      return constraint;
    case "function":
      return { type: "function", name: constraint.name, parameters: constraint.parameters.map((p) => toQueryFilter(p, getVariable)) };
    case "literal":
      return { type: "value", ...toQueryFilterValue(constraint.value) };
    case "token":
      const expressionValue = ensure(expressionTokens[constraint.name])();
      return { type: "value", value: expressionValue, isGuid: "string" == typeof expressionValue };
    case "variable":
      return { type: "value", ...toQueryFilterValue(getVariable(constraint.name), constraint.attribute) };
    case "relatedEntity":
      return { ...constraint, next: void 0 !== constraint.next ? toQueryFilter(constraint.next, getVariable) : void 0 };
  }
}
function toQueryFilterValue(source, attribute) {
  if (null == source)
    return { value: void 0, isGuid: false };
  if ("string" == typeof source || "boolean" == typeof source || source instanceof Date || source instanceof Big)
    return { value: source, isGuid: false };
  if ("number" == typeof source)
    return { value: new Big(source), isGuid: false };
  if (source instanceof MxObject) {
    if (void 0 !== attribute) {
      const attributeType = source.getAttributeType(attribute);
      return { value: clientToAttributeValue(runtimeValueToClientValue(source.getRawValue(attribute), attributeType), attributeType), isGuid: "ObjectReference" === attributeType };
    }
    return { value: source.getGuid(), isGuid: true };
  }
  throw new AssertionError(`Cannot use value '${source}' in query filter`);
}
function toXpathConstraint(filter) {
  switch (filter.type) {
    case "attribute":
      return filter.attribute;
    case "value":
      const value = filter.value;
      if (void 0 === value)
        return "empty";
      if ("string" == typeof value)
        return `'${escapeXml(value)}'`;
      if ("boolean" == typeof value)
        return value ? "true()" : "false()";
      if (value instanceof Big)
        return value.toString();
      if (value instanceof Date)
        return value.getTime().toString();
      throw new AssertionError();
    case "function":
      const association = filter.parameters.find((p) => "association" === p.type);
      return association ? function(association2, filter2) {
        const literal = filter2.parameters.find((p) => "value" === p.type);
        if (!literal)
          return getFunctionConstraint(filter2);
        const assocConstraint = toXpathConstraint(association2), literalValue = literal.value;
        if (void 0 === literalValue)
          switch (filter2.name) {
            case "=":
              return `not(${assocConstraint})`;
            case "!=":
              return assocConstraint;
            default:
              crash();
          }
        switch (filter2.name) {
          case "=":
            break;
          case "!=":
            return `(${assocConstraint} != ${toXpathConstraint(literal)} or not(${assocConstraint}))`;
          case "contains":
            if ("ReferenceSet" === association2.associationType)
              return Array.isArray(literalValue) ? `(${literalValue.map((guid) => `${assocConstraint} = '${guid}'`).join(" and ")})` : `(${assocConstraint} = ${toXpathConstraint(literal)})`;
            break;
          default:
            crash();
        }
        return getFunctionConstraint(filter2);
      }(association, filter) : getFunctionConstraint(filter);
    case "association":
      return filter.associationPath;
    case "relatedEntity":
      const associationStep = "id" === filter.left.attribute ? filter.right.attribute : filter.left.attribute, [entity, rightPart] = "id" !== filter.left.attribute && "id" !== filter.right.attribute ? [getEntityMeta(filter.rightEntity).attributes[filter.right.attribute].referenceEntity, `/${filter.rightEntity}/${filter.right.attribute}`] : [filter.rightEntity, ""], firstPart = `${associationStep}/${entity}${rightPart}`;
      return "function" === filter.next?.type && ["and", "or", "not"].includes(filter.next.name) ? `${firstPart}[${toXpathConstraint(filter.next)}]` : void 0 === filter.next ? firstPart : `${firstPart}/${toXpathConstraint(filter.next)}`;
  }
}
function getFunctionConstraint(filter) {
  return /^(\W+|and|or)$/.test(filter.name) ? "(" + filter.parameters.map(toXpathConstraint).join(` ${filter.name} `) + ")" : `${filter.name}(` + filter.parameters.map(toXpathConstraint).join(", ") + ")";
}
function gatherRuntimeArgumentsFor(constraint, getVariable) {
  switch (constraint.type) {
    case "function":
      const result = {};
      return constraint.parameters.forEach((param) => Object.assign(result, gatherRuntimeArgumentsFor(param, getVariable))), result;
    case "variable":
      const attribute = constraint.attribute && "id" !== constraint.attribute ? constraint.attribute : void 0, runtimeName = constraint.name + (attribute ? "$" + attribute : ""), variable = getVariable(constraint.name), argument = variable instanceof MxObject && attribute ? toRuntimeArgument(variable, attribute) : expressionVariableToRuntimeArgument(variable);
      return void 0 !== argument ? { [runtimeName]: argument } : {};
    default:
      return {};
  }
}

let ui$1;
function getUI() {
  return ensure(ui$1);
}
function setUI(s) {
  ui$1 = s;
}

class ObjectValidation {
  constructor(guid, fields) {
    this.guid = guid, this.fields = fields;
  }
  getGuid() {
    return this.guid;
  }
  getAttributes() {
    return Object.keys(this.fields).map((name) => ({ name, reason: this.fields[name] }));
  }
  getFields() {
    return this.getAttributes();
  }
  addAttribute(attr, message) {
    return !(attr in this.fields) && (this.fields[attr] = message, true);
  }
  addField(attr, message) {
    return this.addAttribute(attr, message);
  }
  removeAttribute(attr) {
    return attr in this.fields && (delete this.fields[attr], true);
  }
  removeField(attr) {
    return this.removeAttribute(attr);
  }
  getErrorReason(attr) {
    return this.fields[attr];
  }
  getReasonByAttribute(attr) {
    return this.getErrorReason(attr);
  }
  clone() {
    return new ObjectValidation(this.guid, { ...this.fields });
  }
  toString() {
    return Object.keys(this.fields).map((attr) => `${attr} ${this.fields[attr]}`).join("; ");
  }
  static describe(validations) {
    const list = [];
    for (let i = 0; void 0 !== validations[i]; i++) {
      const fields = validations[i].getFields();
      for (let x = 0; void 0 !== fields[x]; x++)
        list.push(translate("mendix.lib.Validations", "field_issue", fields[x].name, fields[x].reason));
    }
    return list.join("\n");
  }
  static fromResponse(dataValidations) {
    return dataValidations.map(({ guid, errorFields }) => {
      const fieldMap = {};
      return errorFields.forEach(({ name, message }) => {
        fieldMap[name] = message;
      }), new ObjectValidation(guid, fieldMap);
    });
  }
}

class FakePerformanceTracker {
  begin() {
  }
  end() {
  }
}
class WebPerformanceTracker {
  begin(name) {
    performance.mark(name);
  }
  end(name) {
    performance.measure(name, name);
  }
}
function isPerformanceTrackingEnabled() {
  return window?.MX_ENABLE_PERFORMANCE_TRACKING && "undefined" != typeof performance;
}
function getNanoflow(nanoflowId) {
  return nanoflowId();
}
var AggregateFunction;
function getInstructionDescription(instruction) {
  switch (instruction.type) {
    case "nanoflowCall":
      return `Call nanoflow: ${getNanoflow(instruction.flow).name}`;
    case "microflowCall":
      return `Call microflow: ${instruction.operationId}`;
    case "javaScriptActionCall":
      return "string" == typeof instruction.action ? `Call JavaScript Action: ${instruction.action}` : "Call JavaScript Action";
    case "openForm":
      return "Show page" + instruction.path;
    case "aggregate":
      return `Aggregate list $${instruction.inputVar}`;
    case "sortList":
      return `Sort list $${instruction.inputVar}`;
    case "filterListByExpression":
    case "filterList":
      return `Filter list $${instruction.inputVar}`;
    case "rangeFromList":
      return `Range from list $${instruction.inputVar}`;
    case "setVariable":
      return `Set variable $${instruction.outputVar}`;
    case "synchronize":
      const variables = "specific" === instruction.syncType ? `: ${instruction.variableNames.map((x) => `$${x}`).join(", ")}` : "";
      return `Synchronize ${instruction.syncType} objects${variables}`;
    case "associationRetrieve":
      return `Retrieve $${instruction.inputVar}/${instruction.association}`;
    case "databaseRetrieve":
      return `Retrieve ${instruction.entity} from database`;
    case "createObject":
      return `Create object $${instruction.outputVar}`;
    case "changeObject":
      return `Change object $${instruction.inputVar}/${instruction.member}`;
    case "commitObjects":
      return `Commit object(s) $${instruction.inputVar}`;
    case "deleteObjects":
      return `Delete object(s) $${instruction.inputVar}`;
    case "rollbackObjects":
      return `Rollback object(s) $${instruction.inputVar}`;
    case "whileLoop":
      return "Loop (while)";
    case "listLoop":
      return `Loop list $${instruction.listVar}`;
    default:
      return instruction.type.charAt(0).toUpperCase() + instruction.type.slice(1);
  }
}
!function(AggregateFunction2) {
  AggregateFunction2.Sum = "Sum", AggregateFunction2.Average = "Average", AggregateFunction2.Count = "Count", AggregateFunction2.Minimum = "Minimum", AggregateFunction2.Maximum = "Maximum", AggregateFunction2.All = "All", AggregateFunction2.Any = "Any", AggregateFunction2.Reduce = "Reduce";
}(AggregateFunction || (AggregateFunction = {}));
class AggregateExecutor {
  constructor(evaluateExp) {
    this.evaluateExp = evaluateExp, this.instructionType = "aggregate";
  }
  async execute(instruction, context) {
    const inputList = context.getScope().get(instruction.inputVar);
    if (!isMxObjectArray(inputList))
      throw new AssertionError();
    const scope = context.getScope();
    if (instruction.operation !== AggregateFunction.Count)
      if (instruction.useExpression) {
        const reducer = /* @__PURE__ */ function(context2, evaluateFlowExpression2, inputList2, expression, exposeCurrentResult) {
          return async (resultOnEmpty, fun, initialValue = void 0) => {
            if (0 === inputList2.length)
              return resultOnEmpty;
            const scope2 = context2.getScope();
            let res = initialValue !== firstFlag ? initialValue : void 0;
            try {
              initialValue === firstFlag && (scope2.set("currentObject", inputList2[0]), exposeCurrentResult && scope2.set("currentResult", res), res = await evaluateFlowExpression2(expression, scope2, "primitive"));
              for (const obj of inputList2) {
                scope2.set("currentObject", obj), exposeCurrentResult && scope2.set("currentResult", res);
                res = fun(res, await evaluateFlowExpression2(expression, scope2, "primitive"));
              }
            } finally {
              scope2.set("currentObject", void 0), scope2.set("currentResult", void 0);
            }
            return res;
          };
        }(context, this.evaluateExp, inputList, ensure(instruction.expression), instruction.operation === AggregateFunction.Reduce), value = await async function(reducer2, instruction2, inputList2, context2, evaluateFlowExpression2) {
          switch (instruction2.operation) {
            case AggregateFunction.Sum:
              return reducer2(Big(0), (a, b) => a.plus(b), Big(0));
            case AggregateFunction.Average:
              const sumResult = await reducer2(void 0, (a, b) => a.plus(b), Big(0));
              if (void 0 === sumResult)
                return;
              return sumResult.div(inputList2.length);
            case AggregateFunction.Minimum:
              return reducer2(void 0, (a, b) => a.lt(b) ? a : b, firstFlag);
            case AggregateFunction.Maximum:
              return reducer2(void 0, (a, b) => a.gt(b) ? a : b, firstFlag);
            case AggregateFunction.All:
              return reducer2(true, (a, b) => a && b, true);
            case AggregateFunction.Any:
              return reducer2(false, (a, b) => Boolean(a) || Boolean(b), false);
            case AggregateFunction.Reduce:
              const scope2 = context2.getScope(), init = await evaluateFlowExpression2(ensure(instruction2.initialExpression), scope2, "primitive");
              return reducer2(init, (_, a) => a, init);
            default:
              return;
          }
        }(reducer, instruction, inputList, context, this.evaluateExp);
        scope.set(instruction.outputVar, value);
      } else
        scope.set(instruction.outputVar, function(inputList2, operation, member) {
          const inputValues = inputList2.map((obj) => obj.get2(member)).filter((val) => val instanceof Big);
          switch (operation) {
            case AggregateFunction.Minimum:
              return 0 === inputValues.length ? void 0 : inputValues.reduce((curMin, curVal) => curVal.lt(curMin) ? curVal : curMin, ensure(inputValues[0]));
            case AggregateFunction.Maximum:
              return 0 === inputValues.length ? void 0 : inputValues.reduce((curMax, curVal) => curVal.gt(curMax) ? curVal : curMax, ensure(inputValues[0]));
            case AggregateFunction.Average:
              return 0 === inputValues.length ? void 0 : sum(inputValues).div(inputValues.length);
            case AggregateFunction.Sum:
              return sum(inputValues);
            default:
              return;
          }
        }(inputList, instruction.operation, ensure(instruction.member)));
    else
      scope.set(instruction.outputVar, new Big(inputList.length));
  }
}
function sum(values) {
  return values.reduce((sumValue, curValue) => sumValue.plus(curValue), new Big(0));
}
const firstFlag = Symbol("first");
class CopyVariableExecutor {
  constructor() {
    this.instructionType = "copyVariable";
  }
  async execute(instruction, context) {
    const input = context.getScope().get(instruction.inputVar);
    context.getScope().set(instruction.outputVar, input);
  }
}
class FilterListByExpressionExecutor {
  constructor(evaluateExp) {
    this.evaluateExp = evaluateExp, this.instructionType = "filterListByExpression";
  }
  async execute(instruction, context) {
    const input = context.getScope().get(instruction.inputVar);
    let result;
    const scope = context.getScope();
    try {
      if (!isMxObjectArray(input))
        throw new AssertionError();
      if (instruction.retrieveSingleObject)
        for (const obj of input) {
          scope.set("currentObject", obj);
          if (await this.evaluateExp(instruction.expr, context.getScope(), "primitive")) {
            result = obj;
            break;
          }
        }
      else {
        result = [];
        for (const obj of input) {
          scope.set("currentObject", obj);
          await this.evaluateExp(instruction.expr, context.getScope(), "primitive") && result.push(obj);
        }
      }
    } finally {
      scope.set("currentObject", void 0);
    }
    scope.set(instruction.outputVar, result);
  }
}
const isEqual = getExpressionFunction("=");
class FilterListExecutor {
  constructor(evaluateExp) {
    this.evaluateExp = evaluateExp, this.instructionType = "filterList";
  }
  async execute(instruction, context) {
    const input = context.getScope().get(instruction.inputVar), expected = await this.evaluateExp(instruction.expectedValue, context.getScope(), "primitive");
    if (!isMxObjectArray(input))
      throw new AssertionError();
    function equalsExpected(obj) {
      const value = obj.get2(instruction.attribute);
      return isEqual(value, expected);
    }
    instruction.retrieveSingleObject ? context.getScope().set(instruction.outputVar, input.find(equalsExpected)) : context.getScope().set(instruction.outputVar, input.filter(equalsExpected));
  }
}
class InheritanceSwitchExecutor {
  constructor() {
    this.instructionType = "inheritanceSwitch";
  }
  async execute(instruction, context) {
    const obj = context.getScope().get(instruction.inputVar);
    if (void 0 === obj)
      return { goto: ensure(instruction.targets[""]) };
    if (!(obj instanceof MxObject))
      throw new AssertionError();
    const target = [obj.getEntity(), ...obj.getSuperEntities()].find((t) => t in instruction.targets);
    if (!target)
      throw new AssertionError();
    return { goto: ensure(instruction.targets[target]) };
  }
}
function collectObjects(inputVar, context) {
  const variable = context.getScope().get(inputVar);
  if (variable instanceof MxObject)
    return [variable];
  if (isMxObjectArray(variable) || void 0 === variable)
    return variable;
  throw new AssertionError();
}
class JavaScriptActionExecutor {
  constructor(evaluateExp, executeNanoflow, executeMicroflow) {
    this.evaluateExp = evaluateExp, this.executeNanoflow = executeNanoflow, this.executeMicroflow = executeMicroflow, this.instructionType = "javaScriptActionCall";
  }
  async execute(instruction, context) {
    const resolvedParameters = await Promise.all(instruction.parameters.map(async (param) => {
      switch (param.kind) {
        case "nanoflowId":
          return this.createNanoflowWrapper(param.value, context);
        case "microflowId":
          return this.createMicroflowWrapper(param.value, context);
        default:
          return this.evaluateExp(param.value, context.getScope(), param.kind);
      }
    })), action = await async function(jsActionId) {
      return jsActionId();
    }(instruction.action), result = await action(...resolvedParameters);
    instruction.outputVar && context.getScope().set(instruction.outputVar, anyToExpressionVariable(result));
  }
  createNanoflowWrapper(nanoflowId, context) {
    if (void 0 !== nanoflowId)
      return (args = {}) => {
        const flatArgs = Object.keys(args).map((name) => ({ name, value: anyToExpressionVariable(args[name]) }));
        return this.executeNanoflow(nanoflowId, flatArgs, context);
      };
  }
  createMicroflowWrapper(operationId, context) {
    if (void 0 !== operationId)
      return async (args = {}) => {
        const microflowParameters = function(args2) {
          const result = {};
          for (const key of Object.keys(args2)) {
            const value = args2[key];
            if (null != value)
              if ("string" == typeof value || "boolean" == typeof value)
                result[key] = { value };
              else if ("number" == typeof value)
                result[key] = { value: new Big(value).toString() };
              else if (value instanceof Big)
                result[key] = { value: value.toString() };
              else if (value instanceof Date)
                result[key] = { value: value.getTime() };
              else if (value instanceof MxObject)
                result[key] = { guid: value.getGuid() };
              else {
                if (!Array.isArray(value))
                  throw new AssertionError("Invalid value in 'anyToRuntimeArguments': " + value);
                result[key] = { guids: value.map((v) => {
                  if (v instanceof MxObject)
                    return v.getGuid();
                  throw new AssertionError("Invalid array element in 'anyToRuntimeArguments': " + v);
                }) };
              }
          }
          return result;
        }(args);
        return this.executeMicroflow(operationId, microflowParameters, context.currentForm);
      };
  }
}
class JumpExecutor {
  constructor() {
    this.instructionType = "jump";
  }
  async execute(instruction, _context) {
    return { goto: instruction.target };
  }
}
class ListLoopExecutor {
  constructor(executeInstructions) {
    this.executeInstructions = executeInstructions, this.instructionType = "listLoop", this.currentIndexVariable = "currentIndex";
  }
  async execute(instruction, context) {
    const scope = context.getScope(), list = scope.get(instruction.listVar);
    if (!Array.isArray(list))
      throw new AssertionError();
    const parentCurrentIndex = scope.has(this.currentIndexVariable) ? scope.get(this.currentIndexVariable) : void 0;
    let currentIndex = new Big(0);
    for (const obj of list) {
      if (scope.set(instruction.iteratorVar, obj), scope.set(this.currentIndexVariable, currentIndex), await this.executeInstructions(instruction.body, context))
        break;
      currentIndex = currentIndex.plus(1);
    }
    void 0 !== parentCurrentIndex && scope.set(this.currentIndexVariable, parentCurrentIndex);
  }
}
class MicroflowCallExecutor {
  constructor(evaluateFlowExpression2, executeMicroflow) {
    this.evaluateFlowExpression = evaluateFlowExpression2, this.executeMicroflow = executeMicroflow, this.instructionType = "microflowCall", this.logger = LogManager.get().getLogger(LogNode.Nanoflow);
  }
  async execute({ operationId, parameters, outputVar }, context) {
    const stopwatch = new Stopwatch();
    this.logger.debug(`[${context.executionId}] Starting microflow call ${operationId}.`);
    const microflowParameters = await async function(parameters2, evaluateFlowExpression2, context2) {
      const result2 = {};
      for (const { name, value, kind } of parameters2) {
        const expressionResult = await evaluateFlowExpression2(value, context2.getScope(), kind);
        if ("object" === kind && expressionResult instanceof MxObject)
          result2[name] = { guid: expressionResult.getGuid() };
        else if ("list" === kind && isMxObjectArray(expressionResult))
          result2[name] = { guids: expressionResult.map((mxobj) => mxobj.getGuid()) };
        else if ("primitive" === kind) {
          const runtimeValue = expressionVariableToRuntimeValue(expressionResult);
          null !== runtimeValue && (result2[name] = { value: runtimeValue });
        }
      }
      return result2;
    }(parameters, this.evaluateFlowExpression, context), result = await this.executeMicroflow(operationId, microflowParameters, context.currentForm);
    void 0 !== outputVar && context.getScope().set(outputVar, result), this.logger.debug(`[${context.executionId}] Finished microflow call ${operationId} in ${stopwatch.measure()} milliseconds.`);
  }
}
class NanoflowCallExecutor {
  constructor(evaluateExpression, executeNanoflow) {
    this.evaluateExpression = evaluateExpression, this.executeNanoflow = executeNanoflow, this.instructionType = "nanoflowCall";
  }
  async execute({ flow, parameters, outputVar }, context) {
    const args = await Promise.all(parameters.filter((parameter) => "type" in parameter.value).map(async (parameter) => ({ name: parameter.name, value: await this.evaluateExpression(parameter.value, context.getScope(), parameter.kind) }))), result = await this.executeNanoflow(flow, args, context);
    void 0 !== outputVar && context.getScope().set(outputVar, result);
  }
}
class AssociationRetrieveExecutor {
  constructor() {
    this.instructionType = "associationRetrieve";
  }
  async execute(instruction, context) {
    const { inputVar, association, entity, retrieveSingleObject, direction, outputVar, operationId } = instruction, obj = context.getScope().get(inputVar);
    if (void 0 === obj)
      return void context.getScope().set(outputVar, retrieveSingleObject ? void 0 : []);
    if (!(obj instanceof MxObject))
      throw new AssertionError();
    const mxobjs = mx.isOffline() ? await async function(mxobj, path, entity2, direction2) {
      return new Promise((resolve, reject) => {
        getData().get({ guid: mxobj.getGuid(), path, entity: entity2, direction: direction2, callback: resolve, error: reject });
      });
    }(obj, association, entity, direction) : (await onlineData().retrieveByPathUsingOperationIdOrCache(obj.getGuid(), association, direction, entity, operationId)).mxObjects;
    context.getScope().set(outputVar, retrieveSingleObject ? mxobjs[0] : mxobjs);
  }
}
class ChangeObjectExecutor {
  constructor(evaluateExp) {
    this.evaluateExp = evaluateExp, this.instructionType = "changeObject";
  }
  async execute(instruction, context) {
    const obj = context.getScope().get(instruction.inputVar);
    if (void 0 === obj)
      return;
    if (!(obj instanceof MxObject))
      throw new AssertionError();
    if (obj.isReadonlyAttr(instruction.member))
      throw new Error(`Cannot set $${instruction.inputVar}/${instruction.member} because it is read-only`);
    const exprValue = await this.evaluateExp(instruction.value, context.getScope(), "primitive");
    obj.set2(instruction.member, exprValue instanceof Big ? exprValue.round(8) : exprValue);
  }
}
class CommitObjectsExecutor {
  constructor() {
    this.instructionType = "commitObjects";
  }
  async execute(instruction, context) {
    const objectsToCommit = collectObjects(instruction.inputVar, context);
    if (void 0 === objectsToCommit || 0 === objectsToCommit.length)
      return;
    const uniqueObjectToCommit = uniqueBy(objectsToCommit, (obj) => obj.getGuid()), entity = ensure(uniqueObjectToCommit[0]).getEntity();
    mx.isOffline(entity) ? await new Promise((resolve, reject) => getData().commit({ mxobjs: objectsToCommit, callback: resolve, error: reject })) : await onlineData().executeObjectAction(instruction.operationId, "commit", objectsToCommit);
  }
}
class CreateObjectExecutor {
  constructor() {
    this.instructionType = "createObject";
  }
  async execute(instruction, context) {
    let obj;
    obj = mx.isOffline(instruction.objectType) ? await offlineData().create(instruction.objectType) : await onlineData().createObject(instruction.objectType, instruction.operationId), context.getScope().set(instruction.outputVar, obj);
  }
}
class DatabaseRetrieveExecutor {
  constructor(evaluateExp) {
    this.evaluateExp = evaluateExp, this.instructionType = "databaseRetrieve";
  }
  async execute(instruction, context) {
    const { entity, constraints, limitExpr, offsetExpr, takeFirst, sort, outputVar, operationId } = instruction, scope = context.getScope(), limit = limitExpr ? await this.evaluateExp(limitExpr, scope, "primitive") : void 0, offset = offsetExpr ? await this.evaluateExp(offsetExpr, scope, "primitive") : void 0, options = { ...offset ? { offset: Number(offset) } : {}, ...limit ? { amount: Number(limit) } : {}, ...sort ? { sort } : {} }, { mxObjects } = mx.isOffline(entity) ? await offlineData().retrieve(entity, constraints ? toQueryFilter(constraints, (name) => scope.get(name)) : void 0, options) : await onlineData().retrieveByXPath(operationId, constraints ? gatherRuntimeArgumentsFor(constraints, (name) => scope.get(name)) : {}, "", options, false);
    scope.set(outputVar, takeFirst ? mxObjects[0] : mxObjects);
  }
}
class DeleteObjectsExecutor {
  constructor() {
    this.instructionType = "deleteObjects";
  }
  async execute(instruction, context) {
    const variable = context.getScope().get(instruction.inputVar);
    let objectsToDelete = [];
    if (variable instanceof MxObject)
      objectsToDelete = [variable];
    else {
      if (!isMxObjectArray(variable)) {
        if (void 0 === variable)
          return;
        throw new AssertionError();
      }
      if (0 === variable.length)
        return;
      objectsToDelete = uniqueBy(variable, (obj) => obj.getGuid());
    }
    const entity = ensure(objectsToDelete[0]).getEntity();
    mx.isOffline(entity) ? await offlineData().delete(objectsToDelete) : await onlineData().executeObjectAction(instruction.operationId, "delete", objectsToDelete);
  }
}
class RollbackObjectsExecutor {
  constructor() {
    this.instructionType = "rollbackObjects";
  }
  async execute(instruction, context) {
    const objectsToRollback = collectObjects(instruction.inputVar, context);
    if (void 0 === objectsToRollback || 0 === objectsToRollback.length)
      return;
    const uniqueObjectToRollback = uniqueBy(objectsToRollback, (obj) => obj.getGuid()), entity = ensure(uniqueObjectToRollback[0]).getEntity();
    mx.isOffline(entity) ? await new Promise((resolve, reject) => getData().rollback({ mxobjs: objectsToRollback, callback: resolve, error: reject })) : await onlineData().executeObjectAction(instruction.operationId, "rollback", objectsToRollback);
  }
}
class ClearFromClientExecutor {
  constructor() {
    this.instructionType = "clearFromClient";
  }
  async execute(instruction, _context) {
    if (!mx.isOffline())
      return;
    const { entity } = instruction;
    await offlineData().clearFromClient(entity);
  }
}
class SynchronizeExecutor {
  constructor() {
    this.instructionType = "synchronize";
  }
  async execute(instruction, context) {
    if (mx.isOffline())
      switch (instruction.syncType) {
        case "all":
          await offlineData().runFullSynchronization();
          break;
        case "unsynchronized":
          const { dirtyObjects } = await offlineData().retrieveDirtyObjects(true), deletesToBeSynced = await offlineData().retrieveDeletes();
          (dirtyObjects.length > 0 || Object.keys(deletesToBeSynced).length > 0) && await offlineData().selectiveSync(dirtyObjects, deletesToBeSynced);
          break;
        case "specific":
          const { variableNames } = instruction, allObjects = variableNames.flatMap((name) => {
            const value = context.getScope().get(name);
            if (value instanceof MxObject || isMxObjectArray(value))
              return value;
            if (void 0 === value)
              return [];
            throw new AssertionError();
          });
          allObjects.length > 0 && await offlineData().selectiveSync(uniqueBy(allObjects, (obj) => obj.getGuid()));
      }
  }
}
class RangeFromListExecutor {
  constructor(evaluateExp) {
    this.evaluateExp = evaluateExp, this.instructionType = "rangeFromList";
  }
  async execute(instruction, context) {
    const input = context.getScope().get(instruction.inputVar);
    if (!Array.isArray(input))
      throw new AssertionError();
    const offsetValue = toNumber(await this.evaluateExp(instruction.offset, context.getScope(), "primitive")), limitValue = toNumber(await this.evaluateExp(instruction.limit, context.getScope(), "primitive")), offset = offsetValue <= 0 ? 0 : offsetValue, limit = limitValue <= 0 ? Number.MAX_SAFE_INTEGER : limitValue;
    context.getScope().set(instruction.outputVar, input.slice(offset, offset + limit));
  }
}
class ReturnExecutor {
  constructor(evaluateExp) {
    this.evaluateExp = evaluateExp, this.instructionType = "return";
  }
  async execute(instruction, context) {
    return { result: await this.evaluateExp(instruction.result, context.getScope(), instruction.resultKind) };
  }
}
class SetVariableExecutor {
  constructor(evaluateExp) {
    this.evaluateExp = evaluateExp, this.instructionType = "setVariable";
  }
  async execute(instruction, context) {
    context.getScope().set(instruction.outputVar, await this.evaluateExp(instruction.value, context.getScope(), instruction.outputKind));
  }
}
class SortListExecutor {
  constructor() {
    this.instructionType = "sortList";
  }
  async execute(instruction, context) {
    const input = context.getScope().get(instruction.inputVar);
    if (!isMxObjectArray(input))
      throw new AssertionError();
    let arrCopy = input.slice();
    const meta = getEntityMeta(instruction.entity);
    instruction.items.slice().reverse().forEach((item) => {
      const dataType = meta?.attributes[item.attribute]?.type ?? "String", [validObjs, emptyObjs] = partition((arrItem) => {
        const attr = arrItem.get2(item.attribute);
        return "" !== attr && null != attr;
      }, arrCopy);
      switch (dataType) {
        case "DateTime":
          validObjs.sort(applyOrdering(item.order, (a, b) => attributeToClientValue(a.get2(item.attribute)) - attributeToClientValue(b.get2(item.attribute))));
          break;
        case "String":
        case "Enum":
        case "HashString":
          validObjs.sort(applyOrdering(item.order, (a, b) => {
            const aAttr = a.get2(item.attribute).toLowerCase(), bAttr = b.get2(item.attribute).toLowerCase();
            return (aAttr > bAttr ? 1 : 0) - (bAttr > aAttr ? 1 : 0);
          }));
          break;
        case "AutoNumber":
        case "Long":
        case "Integer":
        case "Decimal":
          validObjs.sort(applyOrdering(item.order, (a, b) => {
            const aAttr = a.get2(item.attribute), bAttr = b.get2(item.attribute);
            return aAttr.cmp(bAttr);
          }));
          break;
        case "Boolean":
          validObjs.sort(applyOrdering(item.order, (a, b) => {
            const aAttr = a.get2(item.attribute);
            return aAttr === b.get2(item.attribute) ? 0 : aAttr ? 1 : -1;
          }));
          break;
        default:
          throw new Error("Unsupported data type");
      }
      arrCopy = validObjs.concat(emptyObjs);
    }), context.getScope().set(instruction.outputVar, arrCopy);
  }
}
function applyOrdering(ordering, compareFn) {
  return (a, b) => {
    const result = compareFn(a, b);
    return "desc" === ordering ? -1 * result : result;
  };
}
class SwitchExecutor {
  constructor(exprEvaluator) {
    this.exprEvaluator = exprEvaluator, this.instructionType = "switch";
  }
  async execute(instruction, context) {
    const value = await this.exprEvaluator(instruction.condition, context.getScope(), "primitive"), valueString = void 0 !== value ? value.toString() : "";
    if (!(valueString in instruction.targets))
      throw new AssertionError();
    return { goto: ensure(instruction.targets[valueString]) };
  }
}
class FlowScope {
  constructor() {
    this.locks = /* @__PURE__ */ new Map(), this.map = {}, this.lockManager = ObjectLockManager.getInstance(), this.map.latestError = void 0;
  }
  set(name, value) {
    this.map[name] = value, value instanceof MxObject ? this.lockObjects(name, [value]) : isMxObjectArray(value) && this.lockObjects(name, value);
  }
  has(name) {
    return name in this.map;
  }
  get(name) {
    if (!(name in this.map))
      throw new AssertionError();
    const value = this.map[name];
    return value instanceof MxObject && value.isUnavailable() ? void 0 : isMxObjectArray(value) ? value.filter((v) => !v.isUnavailable()) : value;
  }
  all() {
    return Object.keys(this.map);
  }
  destroy() {
    this.locks.forEach((release) => release()), this.locks.clear();
  }
  lockObjects(name, objs) {
    this.locks.get(name)?.(), this.locks.set(name, this.lockManager.lock(objs.map((o) => o.getGuid())));
  }
}
class TryCatchExecutor {
  constructor(executeInstructions) {
    this.executeInstructions = executeInstructions, this.instructionType = "tryCatch";
  }
  async execute(instruction, context) {
    try {
      return void await this.executeInstructions(instruction.body, context);
    } catch (e) {
      return e instanceof Error ? context.getScope().set("latestError", e.message) : null != e ? context.getScope().set("latestError", String(e)) : context.getScope().set("latestError", void 0), { goto: instruction.catchTarget };
    }
  }
}
class CloseFormExecutor {
  constructor(evaluateExp) {
    this.evaluateExp = evaluateExp, this.instructionType = "closeForm";
  }
  async execute(instruction, context) {
    const numberOfPagesToClose = instruction.numberOfPagesToClose ? toNumber(await this.evaluateExp(instruction.numberOfPagesToClose, context.getScope(), "primitive")) : 1;
    if (numberOfPagesToClose < 1)
      throw new Error(`The number of pages to close evaluated to ${numberOfPagesToClose}. It must be at least 1.`);
    const { currentForm } = context;
    if (void 0 === currentForm)
      throw new DescribedError("Cannot close the current page. No open page found.");
    currentForm.closePage(numberOfPagesToClose).catch((e) => handleError(e));
  }
}
class OpenFormExecutor {
  constructor(evaluateExp) {
    this.evaluateExp = evaluateExp, this.instructionType = "openForm";
  }
  async execute(instruction, context) {
    const title = instruction.title ? await this.evaluateExp(instruction.title, context.getScope(), "primitive") ?? "" : void 0, formParameters = (await Promise.all(Object.entries(instruction.inputArgs ?? {}).map(([name, expr]) => this.evaluateExp(expr, context.getScope(), "object").then((value) => tuple(name, value?.getGuid()))))).reduce((prev, [name, guid]) => ({ ...prev, [name]: guid }), {}), numberOfPagesToClose = instruction.numberOfPagesToClose ? toNumber(await this.evaluateExp(instruction.numberOfPagesToClose, context.getScope(), "primitive")) : 0, ui = getUI();
    await ui.openForm2(instruction.path, formParameters, title, context.currentForm, instruction.params, numberOfPagesToClose);
  }
}
class ShowMessageExecutor {
  constructor(evaluateExp) {
    this.evaluateExp = evaluateExp, this.instructionType = "showMessage";
  }
  async execute(instruction, context) {
    const expressionResult = await this.evaluateExp(instruction.message, context.getScope(), "primitive"), message = void 0 === expressionResult ? "" : expressionResult;
    getUI().showMessage(instruction.messageType, message, instruction.blocking);
  }
}
class ShowValidationExecutor {
  constructor(evaluateExp) {
    this.evaluateExp = evaluateExp, this.instructionType = "showValidation";
  }
  async execute(instruction, context) {
    const variable = context.getScope().get(instruction.inputVar);
    if (void 0 === variable)
      throw new Error(`Cannot refresh $${instruction.inputVar} as it is empty`);
    if (!(variable instanceof MxObject))
      throw new AssertionError();
    const expressionResult = await this.evaluateExp(instruction.text, context.getScope(), "primitive"), validationText = void 0 === expressionResult ? "" : expressionResult, existingValidations = function(scope, guid) {
      const validationMap = scope[symbol] ?? (scope[symbol] = {});
      return validationMap[guid] ?? (validationMap[guid] = {});
    }(context.getScope(), variable.getGuid());
    existingValidations[instruction.member] = validationText;
    const ov = new ObjectValidation(variable.getGuid(), existingValidations);
    await getData().sendValidationUpdates([ov]);
  }
}
const symbol = Symbol("validations");
class WriteLogExecutor {
  constructor(evaluateExp) {
    this.evaluateExp = evaluateExp, this.instructionType = "writeLog";
  }
  async execute(instruction, context) {
    const message = await this.evaluateExp(instruction.message, context.getScope(), "primitive");
    LogManager.get().getLogger(LogNode.Nanoflow).log(instruction.level, message);
  }
}
class WhileLoopExecutor {
  constructor(executeInstructions, exprEvaluator) {
    this.executeInstructions = executeInstructions, this.exprEvaluator = exprEvaluator, this.instructionType = "whileLoop", this.currentIndexVariable = "currentIndex";
  }
  async execute(instruction, context) {
    const scope = context.getScope(), parentCurrentIndex = scope.has(this.currentIndexVariable) ? scope.get(this.currentIndexVariable) : void 0;
    let currentIndex = Big(0);
    for (scope.set(this.currentIndexVariable, currentIndex); await this.exprEvaluator(instruction.condition, scope, "primitive") && !await this.executeInstructions(instruction.body, context); )
      currentIndex = currentIndex.plus(1), scope.set(this.currentIndexVariable, currentIndex);
    void 0 !== parentCurrentIndex && scope.set(this.currentIndexVariable, parentCurrentIndex);
  }
}
class NanoflowDebugger {
  constructor(connection, getNanoflow2, logManager = LogManager.get()) {
    let breakpointsReady;
    this.connection = connection, this.getNanoflow = getNanoflow2, this.breakpoints = /* @__PURE__ */ new Map(), this.debuggedNanoflows = {}, this.logger = logManager.getLogger(LogNode.NanoflowDebugger), this.breakpointsReadyPromise = new Promise((resolve) => {
      breakpointsReady = resolve;
    }), connection.onInstruction("set_breakpoints", (instruction) => {
      this.breakpoints.clear();
      for (const { label, condition } of instruction.breakpoints)
        this.breakpoints.set(label, condition);
      breakpointsReady();
    }), connection.onInstruction("debugger_step", (instruction) => {
      ensure(this.debuggedNanoflows[instruction.executionId]).handleInstruction(instruction);
    }), connection.onInstruction("get_debugger_variable", ({ executionId, variableName, index }) => {
      const variable = ensure(this.debuggedNanoflows[executionId]).context.getScope().get(variableName);
      this.send({ type: "debugger_variable", data: this.serializeVariableContent(variable, index) });
    }), connection.onConnect(() => {
      Object.keys(this.debuggedNanoflows).forEach((executionId) => this.send({ type: "paused_nanoflow", data: this.createPausedNanoflow(ensure(this.debuggedNanoflows[executionId]).context) }));
    });
  }
  async waitForBreakpoints() {
    return this.breakpointsReadyPromise;
  }
  async handleInstruction({ context, instruction }) {
    if (await this.shouldBreak(instruction, context)) {
      const debuggerInstruction = await this.activateDebugger(instruction, context), debuggedNf = ensure(this.debuggedNanoflows[context.executionId]);
      switch (debuggerInstruction.mode) {
        case "continue":
          debuggedNf.maxStackDepthToPause = -1 / 0;
          break;
        case "step_into":
          debuggedNf.maxStackDepthToPause = 1 / 0;
          break;
        case "step_over":
          debuggedNf.maxStackDepthToPause = context.getStackSize();
          break;
        case "step_out":
          debuggedNf.maxStackDepthToPause = context.getStackSize() - 1;
      }
    }
  }
  handleNanoflowCompletion({ executionId }) {
    delete this.debuggedNanoflows[executionId];
  }
  async shouldBreak(instruction, context) {
    if (void 0 === instruction.label || "jump" === instruction.type)
      return false;
    if (this.breakpoints.has(instruction.label)) {
      const condition = this.breakpoints.get(instruction.label);
      if (!condition)
        return true;
      try {
        return true === await evaluateFlowExpression(condition, context.getScope(), "primitive");
      } catch (e) {
        return this.logger.error(`Failed to evaluate breakpoint expression: ${e instanceof Error ? e.message : e}`), false;
      }
    }
    const debuggedNanoflow = this.debuggedNanoflows[context.executionId];
    return void 0 !== debuggedNanoflow && context.getStackSize() <= debuggedNanoflow.maxStackDepthToPause;
  }
  async activateDebugger(instruction, context) {
    const nanoflow = this.getNanoflow(context.getCurrentNanoflowId());
    return this.debuggedNanoflows[context.executionId] = { context, maxStackDepthToPause: 1 / 0, nanoflow: nanoflow.name, objectId: instruction.label, handleInstruction: () => {
    } }, new Promise((resolve) => {
      ensure(this.debuggedNanoflows[context.executionId]).handleInstruction = resolve, this.send({ type: "paused_nanoflow", data: this.createPausedNanoflow(context) });
    });
  }
  createPausedNanoflow(context) {
    const { executionId } = context, { nanoflow, objectId } = ensure(this.debuggedNanoflows[executionId]);
    return { nanoflow, objectId, executionId, variables: this.getVariables(context.getScope()) };
  }
  getVariables(scope) {
    const variables = {};
    for (const name of scope.all().filter((n) => "latestError" !== n)) {
      const variable = scope.get(name);
      switch (typeof variable) {
        case "boolean":
          variables[name] = { type: "boolean", value: variable };
          break;
        case "string":
          variables[name] = { type: "string", value: variable };
          break;
        case "undefined":
          variables[name] = { type: "null" };
          break;
        case "object":
          variable instanceof Date ? variables[name] = { type: "date_time", ...formatDate(variable) } : variable instanceof Big ? variables[name] = { type: "decimal", value: variable.toString() } : Array.isArray(variable) ? variables[name] = { type: "list", size: variable.length } : variables[name] = this.serializeObject(variable, false);
          break;
        default:
          this.logger.error("Unknown variable type: " + typeof variable), variables[name] = { type: "unknown", value: variable };
      }
    }
    return variables;
  }
  serializeVariableContent(variable, index) {
    return variable instanceof MxObject ? this.serializeObject(variable, true) : Array.isArray(variable) && void 0 === index ? { objects: variable.map((obj) => this.serializeObject(obj, false)) } : Array.isArray(variable) && void 0 !== index && variable[index] instanceof MxObject ? this.serializeObject(variable[index], true) : { type: "null" };
  }
  serializeObject(variable, createMembers) {
    if (variable instanceof MxObject) {
      const guid = variable.getGuid(), obj = { type: "object", id: guid, entity: variable.getEntity(), state: getData().isNew(guid) ? "INSTANTIATED" : "NORMAL" };
      if (createMembers) {
        const members = {}, attrs = getAttributesMeta(variable.getEntity()).filter((attrMeta) => variable.has(attrMeta.name));
        for (const attr of attrs) {
          const value = variable.get2(attr.name);
          switch (attr.type) {
            case "AutoNumber":
              members[attr.name] = { type: "auto_number", value };
              break;
            case "Binary":
              members[attr.name] = { type: "binary" };
              break;
            case "Boolean":
              members[attr.name] = { type: "boolean", value };
              break;
            case "DateTime":
              {
                const member = { type: "date_time" };
                value && Object.assign(member, formatDate(value)), members[attr.name] = member;
              }
              break;
            case "Decimal":
              members[attr.name] = { type: "decimal", value };
              break;
            case "Enum":
              members[attr.name] = { type: "enum", value, enumeration_name: ensure(attr.enumeration) };
              break;
            case "HashString":
              members[attr.name] = { type: "hash_string", value };
              break;
            case "Integer":
              members[attr.name] = { type: "integer", value };
              break;
            case "Long":
              members[attr.name] = { type: "long", value };
              break;
            case "ObjectReference":
              {
                const type = ensure(attr.referenceEntity), member = { type: "reference" };
                value && (member.value = { type: String(type), object_id: value.toString() }), members[attr.name] = member;
              }
              break;
            case "ObjectReferenceSet":
              {
                const type = ensure(attr.referenceEntity), member = { type: "reference_set", value: [] };
                value && (member.value = value.map((object_id) => ({ type: String(type), object_id }))), members[attr.name] = member;
              }
              break;
            case "String":
              members[attr.name] = { type: "string", value };
              break;
            default:
              this.logger.error(`Unknown attribute type: ${attr.type}`), members[attr.name] = { type: "unknown", value: String(value) };
          }
        }
        return { ...obj, members };
      }
      return obj;
    }
    return { type: "null" };
  }
  send(message) {
    this.connection.send(JSON.stringify(message));
  }
}
function formatDate(date) {
  return { value: format(localizeDate(date), "yyyy-MM-dd HH:mm:ss.SSS"), session_time: format(date, "yyyy-MM-dd HH:mm:ss.SSS xxxx") };
}
class DescribedNanoflowError extends DescribedError {
  constructor(message, stack, nanoflowStack) {
    super(`${message}

Nanoflow stack:
${nanoflowStack}`), this.nanoflowStack = nanoflowStack, Object.setPrototypeOf(this, DescribedNanoflowError.prototype), this.description = message, this.stack = stack;
  }
}
class FlowContext {
  constructor(currentForm, nanoflowId = void 0, scope = void 0, executionId = newId("flow"), depth = 0, parentContext = void 0) {
    this.currentForm = currentForm, this.nanoflowId = nanoflowId, this.scope = scope, this.executionId = executionId, this.depth = depth, this.parentContext = parentContext;
  }
  getScope() {
    return this.scope;
  }
  getCurrentNanoflowId() {
    return this.nanoflowId ?? this.parentContext?.getCurrentNanoflowId();
  }
  getStackSize() {
    return this.depth;
  }
  getCurrentInstruction() {
    return this.currentInstruction;
  }
  setCurrentInstruction(instruction) {
    this.currentInstruction = instruction;
  }
  getLeafContext() {
    return this.childContext?.getLeafContext() ?? this;
  }
  getParentContext() {
    return this.parentContext;
  }
  async insideNewStack(operation, nanoflowId) {
    const scope = void 0 !== nanoflowId ? new FlowScope() : this.scope;
    this.childContext = new FlowContext(this.currentForm, nanoflowId ?? this.nanoflowId, scope, this.executionId, this.depth + 1, this);
    try {
      return await operation(this.childContext);
    } finally {
      void 0 !== nanoflowId && scope.destroy(), this.childContext = void 0;
    }
  }
}
class NanoflowError extends Error {
  constructor(innerError, nanoflowStack) {
    super(`${innerError instanceof Error ? innerError.message : String(innerError)}

Nanoflow stack:
${nanoflowStack}`), this.innerError = innerError, this.nanoflowStack = nanoflowStack, Object.setPrototypeOf(this, NanoflowError.prototype), innerError instanceof Error && (this.stack = innerError.stack);
  }
}
function isReturn(value) {
  return "object" == typeof value && "result" in value;
}
class NanoflowPerformanceTracker {
  constructor() {
    this.performanceTracker = isPerformanceTrackingEnabled() ? new WebPerformanceTracker() : new FakePerformanceTracker();
  }
  startTracking(nanoflowEngine2) {
    nanoflowEngine2.onNanoflowExecutionEvent("nanoflowStart", this.onNanoflowStart.bind(this)), nanoflowEngine2.onNanoflowExecutionEvent("nanoflowEnd", this.onNanoflowEnd.bind(this)), nanoflowEngine2.onNanoflowExecutionEvent("instructionStart", this.onInstructionStart.bind(this)), nanoflowEngine2.onNanoflowExecutionEvent("instructionEnd", this.onInstructionEnd.bind(this));
  }
  onNanoflowStart({ nanoflowId }) {
    const nanoflowName = NanoflowPerformanceTracker.getNanoflowName(nanoflowId);
    this.performanceTracker.begin(`Nanoflow: ${nanoflowName}`);
  }
  onNanoflowEnd({ nanoflowId }) {
    const nanoflowName = NanoflowPerformanceTracker.getNanoflowName(nanoflowId);
    this.performanceTracker.end(`Nanoflow: ${nanoflowName}`);
  }
  onInstructionStart({ instruction }) {
    const instructionDescription = getInstructionDescription(instruction);
    this.performanceTracker.begin(instructionDescription);
  }
  onInstructionEnd({ instruction }) {
    const instructionDescription = getInstructionDescription(instruction);
    this.performanceTracker.end(instructionDescription);
  }
  static getNanoflowName(nanoflowId) {
    if ("string" == typeof nanoflowId)
      return nanoflowId;
    if ("name" in nanoflowId)
      return nanoflowId.name;
    throw new AssertionError("Nanoflow could not be identified");
  }
}
function toMapEntry(flowExecutor) {
  return [flowExecutor.instructionType, flowExecutor];
}
const nanoflowEngine = new class {
  constructor(lazyExecutors, getNanoflowFromRegistry, expressionEvaluator) {
    this.getNanoflowFromRegistry = getNanoflowFromRegistry, this.expressionEvaluator = expressionEvaluator, this.executionEventHandlers = { nanoflowStart: [], nanoflowEnd: [], instructionStart: [], instructionEnd: [] }, this.runningNanoflows = new Array(), this.logger = LogManager.get().getLogger(LogNode.Nanoflow);
    this.executors = lazyExecutors((instructions, context) => context.insideNewStack((newContext) => this.executeInstructions(instructions, newContext)), this.executeInstructions.bind(this), this.executeNanoflow.bind(this), this.executeMicroflow.bind(this));
  }
  async execute(nanoflowId, args, currentForm) {
    const context = new FlowContext(currentForm, nanoflowId), nanoflowName = this.getNanoflowFromRegistry(nanoflowId).name, stopwatch = new Stopwatch();
    this.logger.debug(`[${context.executionId}] Starting execution of nanoflow ${nanoflowName}.`), this.runningNanoflows.push(context), await this.raiseEvent("nanoflowStart", { nanoflowId, executionId: context.executionId });
    try {
      return await wait(0), await this.executeNanoflow(nanoflowId, args, context);
    } finally {
      this.runningNanoflows.splice(this.runningNanoflows.indexOf(context), 1), this.logger.debug(`[${context.executionId}] Finished execution of nanoflow ${nanoflowName}. Execution took ${stopwatch.measure()} milliseconds.`), await this.raiseEvent("nanoflowEnd", { nanoflowId, executionId: context.executionId });
    }
  }
  onNanoflowExecutionEvent(type, handler) {
    const handlers = this.executionEventHandlers[type];
    return handlers.push(handler), { unsubscribe() {
      const idx = handlers.indexOf(handler);
      idx > -1 && handlers.splice(idx, 1);
    } };
  }
  generateCallStackOfExecutingNanoflows() {
    return this.runningNanoflows.map((context) => [this.getNanoflowFromRegistry(context.getCurrentNanoflowId()).name, this.generateCallStack(context)]);
  }
  generateCallStack(context) {
    const nfStack = new Array();
    let currentContext = context.getLeafContext(), indent = 0;
    for (; void 0 !== currentContext?.getCurrentInstruction(); )
      nfStack.push(`${indent > 0 ? new Array(indent).fill(" ").join("") : ""} "${getInstructionDescription(currentContext.getCurrentInstruction())}" in nanoflow "${this.getNanoflowFromRegistry(currentContext.getCurrentNanoflowId()).name}"`), currentContext = currentContext.getParentContext(), indent++;
    return nfStack.join("\n");
  }
  async raiseEvent(type, args) {
    const handlers = this.executionEventHandlers[type];
    handlers.length > 0 && await Promise.all(handlers.map((handler) => handler(args)));
  }
  getRunningNanoflows() {
    return [...this.runningNanoflows];
  }
  async executeMicroflow(operationId, microflowParameters, currentForm) {
    return mx.isOffline() ? offlineData().executeMicroflow(operationId, microflowParameters, currentForm) : onlineData().executeMicroflow(operationId, microflowParameters, currentForm);
  }
  async executeNanoflow(nanoflowId, args, context) {
    return context.insideNewStack(async (newContext) => {
      const nanoflow = this.getNanoflowFromRegistry(nanoflowId), argMap = new Map(args.map((arg) => [arg.name, arg.value]));
      return await Promise.all(nanoflow.optionalParameters?.map(async (param) => {
        if (!argMap.has(param.name)) {
          const defaultValue = await this.expressionEvaluator(param.value, newContext.getScope(), param.kind);
          argMap.set(param.name, defaultValue);
        }
      }) ?? []), argMap.forEach((value, name) => {
        newContext.getScope().set(name, value);
      }), this.executeInstructions(nanoflow.instructions, newContext);
    }, nanoflowId);
  }
  async executeInstructions(instructions, context) {
    let index = 0;
    for (; index < instructions.length; ) {
      const instruction = ensure(instructions[index]), executor = this.executors.get(instruction.type);
      if (void 0 === executor)
        throw new AssertionError();
      let executorResult;
      await this.raiseEvent("instructionStart", { context, instruction }), context.setCurrentInstruction(instruction);
      try {
        executorResult = await executor.execute(instruction, context);
      } catch (e) {
        throw e instanceof NanoflowError || e instanceof DescribedNanoflowError || e instanceof ConnectionError ? e : e instanceof DescribedError ? new DescribedNanoflowError(e.message, e.stack, this.generateCallStack(context)) : new NanoflowError(e, this.generateCallStack(context));
      } finally {
        await this.raiseEvent("instructionEnd", { context, instruction });
      }
      if ("object" == typeof (value = executorResult) && "goto" in value) {
        const goto = executorResult.goto;
        if (index = instructions.findIndex((i) => i.label === goto), -1 === index)
          throw new AssertionError();
      } else {
        if (isReturn(executorResult))
          return executorResult.result;
        index++;
      }
    }
    var value;
    throw new AssertionError();
  }
}((executeInstructionsInNewStack, executeInstructions, executeNanoflow, executeMicroflow) => new Map([toMapEntry(new JumpExecutor()), toMapEntry(new SwitchExecutor(evaluateFlowExpression)), toMapEntry(new InheritanceSwitchExecutor()), toMapEntry(new ListLoopExecutor(executeInstructionsInNewStack)), toMapEntry(new WhileLoopExecutor(executeInstructionsInNewStack, evaluateFlowExpression)), toMapEntry(new TryCatchExecutor(executeInstructions)), toMapEntry(new ReturnExecutor(evaluateFlowExpression)), toMapEntry(new CreateObjectExecutor()), toMapEntry(new ClearFromClientExecutor()), toMapEntry(new ChangeObjectExecutor(evaluateFlowExpression)), toMapEntry(new CommitObjectsExecutor()), toMapEntry(new DeleteObjectsExecutor()), toMapEntry(new RollbackObjectsExecutor()), toMapEntry(new SetVariableExecutor(evaluateFlowExpression)), toMapEntry(new CopyVariableExecutor()), toMapEntry(new OpenFormExecutor(evaluateFlowExpression)), toMapEntry(new CloseFormExecutor(evaluateFlowExpression)), toMapEntry(new ShowValidationExecutor(evaluateFlowExpression)), toMapEntry(new DatabaseRetrieveExecutor(evaluateFlowExpression)), toMapEntry(new AssociationRetrieveExecutor()), toMapEntry(new WriteLogExecutor(evaluateFlowExpression)), toMapEntry(new JavaScriptActionExecutor(evaluateFlowExpression, executeNanoflow, executeMicroflow)), toMapEntry(new SynchronizeExecutor()), toMapEntry(new FilterListExecutor(evaluateFlowExpression)), toMapEntry(new FilterListByExpressionExecutor(evaluateFlowExpression)), toMapEntry(new RangeFromListExecutor(evaluateFlowExpression)), toMapEntry(new SortListExecutor()), toMapEntry(new AggregateExecutor(evaluateFlowExpression)), toMapEntry(new ShowMessageExecutor(evaluateFlowExpression)), toMapEntry(new NanoflowCallExecutor(evaluateFlowExpression, executeNanoflow)), toMapEntry(new MicroflowCallExecutor(evaluateFlowExpression, executeMicroflow))]), getNanoflow, evaluateFlowExpression);
if (isPerformanceTrackingEnabled()) {
  new NanoflowPerformanceTracker().startTracking(nanoflowEngine);
}
let nanoflowDebugger;
function initializeNanoflowDebugger(connection, logManager) {
  if (void 0 !== nanoflowDebugger)
    throw new AssertionError();
  nanoflowDebugger = new NanoflowDebugger(connection, getNanoflow, logManager), nanoflowEngine.onNanoflowExecutionEvent("instructionStart", nanoflowDebugger.handleInstruction.bind(nanoflowDebugger)), nanoflowEngine.onNanoflowExecutionEvent("nanoflowEnd", nanoflowDebugger.handleNanoflowCompletion.bind(nanoflowDebugger));
}
async function waitForNFDebuggerBreakpoints() {
  return Promise.race([ensure(nanoflowDebugger).waitForBreakpoints(), wait(500)]);
}

let namePrefix = "";
const getUserScopedNamePrefix = () => namePrefix, setUserScopedNamePrefix = (value) => {
  namePrefix = value;
}, toUserScopedName = (name) => namePrefix ? `${namePrefix}$${name}` : name;

var tablePrefix = /*#__PURE__*/Object.freeze({
	__proto__: null,
	getUserScopedNamePrefix: getUserScopedNamePrefix,
	setUserScopedNamePrefix: setUserScopedNamePrefix,
	toUserScopedName: toUserScopedName
});

const METADATA_TABLE = "_guidToTable", TOMBSTONE_TABLE = "_tombstoneTable", GUID_COLUMN = "guid", TABLE_NAME_COLUMN = "tableName", READONLY_COLUMN = "readonlyAttrs", SYNC_ID_COLUMN = "syncId", METADATA_COLUMNS = ["guid", "tableName", "readonlyAttrs", "syncId"], DB_META_TABLE = "_db_meta", DB_NAME_COLUMN = "name", DB_VALUE_COLUMN = "value", DB_VERSION_KEY = "version", DB_COUNTER_KEY = "cnt", DB_OFFLINE_METADATA_KEY = "offline_metadata", CHANGED_DATE_COLUMN = "changedDate", HAS_CONTENTS_COLUMN = "HasContents";
function createGetDbMetaValue(key) {
  return ['SELECT value FROM "_db_meta" WHERE "name" = ?', [key]];
}
function createUpdateDbMetaValue(key, value) {
  return ['UPDATE "_db_meta" SET "value" = ? WHERE name = ?', [value, key]];
}
function createUpdateCounterValue(count) {
  return [`UPDATE "_db_meta" SET "value" = "value" + ${count} WHERE name = ?`, ["cnt"]];
}
function getRequestData(objectCache, guidsToSend) {
  const requestChanges = {};
  guidsToSend.filter((guid) => objectCache.hasChanges(guid)).forEach((guid) => {
    requestChanges[guid] = objectCache.getChanges(guid);
  });
  const requestJson = guidsToSend.filter((guid) => objectCache.has(guid)).map((guid) => objectCache.getObject(guid)).filter((mxobj) => !mxobj.isPersistable() || objectCache.isNew(mxobj.getGuid())).map((mxobj) => mxobj.jsonData);
  return [requestChanges, requestJson];
}
function getImplicitMicroflowParameters() {
  const session = getSession();
  return [session.getUserId(), session.getSessionObjectId()];
}
class LabeledGraph {
  constructor() {
    this.labels = [], this.labelMap = {}, this.graph = [];
  }
  addEdge(fromLabel, toLabel) {
    const fromIdx = this.getOrCreateLabelIndex(fromLabel), toIdx = this.getOrCreateLabelIndex(toLabel), destinationIndices = this.graph[fromIdx];
    destinationIndices.includes(toIdx) || destinationIndices.push(toIdx);
  }
  neighborsOf(label) {
    const idx = this.getOrCreateLabelIndex(label);
    return this.graph[idx].map((neighborIdx) => this.indexToLabel(neighborIdx));
  }
  reachableLabels(sourceLabels) {
    const sourceIndices = sourceLabels.map((label) => this.getOrCreateLabelIndex(label));
    return function(graph, start) {
      const visited = new Array(graph.length);
      !function visitEdges(edges) {
        for (const idx of edges) {
          if (idx < 0 || idx >= visited.length)
            throw new Error(`graph: index ${idx} out of bounds in graph of size ${graph.length}`);
          visited[idx] || (visited[idx] = true, visitEdges(graph[idx]));
        }
      }(start);
      const result = [];
      for (let i = 0; i < visited.length; ++i)
        visited[i] && result.push(i);
      return result;
    }(this.graph, sourceIndices).map((idx) => this.indexToLabel(idx));
  }
  indexToLabel(idx) {
    return this.labels[idx];
  }
  getOrCreateLabelIndex(label) {
    if (label in this.labelMap)
      return this.labelMap[label];
    this.labels.push(label), this.graph.push([]);
    const newIdx = this.labels.length - 1;
    return this.labelMap[label] = newIdx, newIdx;
  }
}
function findReachableGuidsToRetain(mxObjs, rootGuids) {
  return buildRetainmentGraph(mxObjs, rootGuids).reachableLabels(Array.from(rootGuids));
}
function findReachableGuidsForRequest(mxObjs, startGuids, associationsToFollow) {
  const objectMap = indexByKey((mxObj) => mxObj.getGuid())(mxObjs), associations = null != associationsToFollow ? function(mxObjs2, associationsToFollow2) {
    const associations2 = [];
    return mxObjs2.forEach((mxObj) => {
      associationsToFollow2.forEach((asf) => {
        if (!mxObj.has(asf.association))
          return;
        const associationOwner = computeSupermostEntityWithAttribute(mxObj.getEntity(), asf.association), selectorEntity = mxObj.getSelectorEntity(asf.association);
        asf.fromEntity === associationOwner && getAllReferences(mxObj, asf.association).forEach((refGuid) => associations2.push({ from: mxObj.getGuid(), to: refGuid })), asf.fromEntity === selectorEntity && getAllReferences(mxObj, asf.association).forEach((refGuid) => associations2.push({ from: refGuid, to: mxObj.getGuid() }));
      });
    }), associations2;
  }(mxObjs, associationsToFollow) : getAllAssociations(mxObjs);
  return createGraph(associations).reachableLabels(startGuids).filter((l) => objectMap[l]);
}
function findChangedReachableGuidsForRequest(objectCache, mxObjs, startGuids) {
  const objectMap = indexByKey((mxObj) => mxObj.getGuid())(mxObjs), associations = function(objectCache2, mxObjs2) {
    const associations2 = [], referenceAttributesEntityMap = getReferenceAttributesEntityMap(mxObjs2);
    return mxObjs2.forEach((mxObj) => {
      referenceAttributesEntityMap.get(mxObj.getEntity()).forEach((association) => {
        mxObj.has(association) && Object.prototype.hasOwnProperty.call(objectCache2.getChanges(mxObj.getGuid()), association) && getAllReferences(mxObj, association).forEach((refGuid) => {
          objectCache2.isNew(refGuid) && associations2.push({ from: mxObj.getGuid(), to: refGuid }), objectCache2.getObject(refGuid)?.has(association) && associations2.push({ to: mxObj.getGuid(), from: refGuid });
        });
      });
    }), associations2;
  }(objectCache, mxObjs);
  return createGraph(associations).reachableLabels(startGuids).filter((l) => objectMap[l]);
}
function findDeletableReachableGuidsForRequest(mxObjs, startGuids) {
  const objectMap = indexByKey((mxObj) => mxObj.getGuid())(mxObjs), associations = function(mxObjs2) {
    const associations2 = [], referenceAttributesEntityMap = getReferenceAttributesEntityMap(mxObjs2);
    return mxObjs2.forEach((mxObj) => {
      referenceAttributesEntityMap.get(mxObj.getEntity()).forEach((association) => {
        const deleteBehavior = mxObj.metaData.deleteBehavior;
        deleteBehavior?.[association]?.sendChildren && getAllReferences(mxObj, association).forEach((refGuid) => associations2.push({ from: mxObj.getGuid(), to: refGuid })), (mxObj.has(association) || deleteBehavior?.[association]?.sendParents) && getAllReferences(mxObj, association).forEach((refGuid) => associations2.push({ from: refGuid, to: mxObj.getGuid() }));
      });
    }), associations2;
  }(mxObjs);
  return createGraph(associations).reachableLabels(startGuids).filter((l) => objectMap[l]);
}
function buildRetainmentGraph(mxObjs, rootGuids) {
  mxObjs = mxObjs.filter((mxObj) => !mxObj.isPersistable() || mxObj.hasChanges() || mxObj.isNew() || rootGuids.has(mxObj.getGuid()));
  const objectMap = indexByKey((mxObj) => mxObj.getGuid())(mxObjs);
  return createGraph(getAllAssociations(mxObjs).filter(({ from, to }) => isRetained(from) && isRetained(to)));
  function isRetained(guid) {
    return rootGuids.has(guid) || guid in objectMap;
  }
}
function getAllAssociations(mxObjs) {
  const associations = [], referenceAttributesEntityMap = getReferenceAttributesEntityMap(mxObjs);
  return mxObjs.forEach((mxObj) => {
    referenceAttributesEntityMap.get(mxObj.getEntity()).forEach((association) => {
      mxObj.has(association) && getAllReferences(mxObj, association).forEach((refGuid) => associations.push({ from: refGuid, to: mxObj.getGuid() }, { from: mxObj.getGuid(), to: refGuid }));
    });
  }), associations;
}
function getReferenceAttributesEntityMap(mxObjs) {
  const referenceAttributesEntityMap = /* @__PURE__ */ new Map();
  for (const mxObj of mxObjs)
    referenceAttributesEntityMap.has(mxObj.getEntity()) || referenceAttributesEntityMap.set(mxObj.getEntity(), getAttributesMeta(mxObj.getEntity()).filter((attr) => ("ObjectReference" === attr.type || "ObjectReferenceSet" === attr.type) && attr.name !== SystemAttribute.Owner && attr.name !== SystemAttribute.ChangedBy).map((association) => association.name));
  return referenceAttributesEntityMap;
}
function getAllReferences(mxObj, attr) {
  return mxObj.getReferences(attr).concat(mxObj.getOriginalReferences(attr));
}
function createGraph(associations) {
  const labeledGraph = new LabeledGraph();
  return associations.forEach(({ from, to }) => labeledGraph.addEdge(from, to)), labeledGraph;
}
function getRequestDataForMicroflow(objectCache, operationId, mfGuids) {
  const microflowInfo = getMicroflowInfo(operationId), guidsToSend = findReachableGuidsForRequest(objectCache.getAllObjects(), mfGuids, microflowInfo?.followedAssociations);
  return mfGuids.filter((guid) => !guidsToSend.includes(guid)).forEach((guid) => guidsToSend.push(guid)), getRequestData(objectCache, guidsToSend);
}
const objectIdCache = /* @__PURE__ */ new Map(), OBJECT_ID_BITS_BI = BigInt(48), MAX_OBJECT_NR = 65535, OBJECT_ID_MASK = BigInt(MAX_OBJECT_NR);
function createMendixGuid(entity) {
  if (void 0 === entity.maxObjectId)
    throw new AssertionError(`Can't create a Mendix guid for "${entity.name}"`);
  const entityId = entity.entityId ?? deriveEntityId(entity.maxObjectId), objectId = objectIdCache.get(entity.name) ?? getObjectId(entity.maxObjectId);
  if (objectId > MAX_OBJECT_NR)
    throw new AssertionError(`Max object ID exceeds allowed amount for ${entity.name}.`);
  objectIdCache.set(entity.name, objectId - 1);
  return (BigInt(entityId) << OBJECT_ID_BITS_BI | BigInt(objectId)).toString();
}
function dehydrateObjectIdCache() {
  const obj = {};
  return objectIdCache.forEach((val, entity) => obj[entity] = val.toString()), obj;
}
function hydrateObjectIdCache(dehydratedCache) {
  Object.entries(dehydratedCache).forEach(([entity, id]) => {
    objectIdCache.set(entity, getObjectId(id));
  });
}
function getObjectId(id) {
  return Number(BigInt(id) & OBJECT_ID_MASK);
}
function actionMatcher(...actions) {
  const actionsToCheck = 0 === actions.length ? [void 0] : actions;
  return (request) => {
    const currentAction = actions.length > 0 && isJson(request.body) ? request.body.action : void 0;
    return actionsToCheck.includes(currentAction);
  };
}
function createRetryMiddleware(retries, ...actions) {
  return createRetryMiddlewarePredicate(retries, actionMatcher(...actions));
}
function createRetryMiddlewarePredicate(retries, predicate) {
  return async (request, next) => {
    let attempts = retries;
    const logger = LogManager.get().getLogger(LogNode.Network);
    try {
      return await next(request);
    } catch (e) {
      return async function retry(e2) {
        const shouldRetry = e2 instanceof ConnectionError && attempts-- > 0;
        if (shouldRetry) {
          const method = request.init.method?.toUpperCase();
          logger.trace(`Retrying ${method} ${request.url}. Attempts left: ${attempts}`);
        }
        return shouldRetry && predicate(request) ? next(request).catch(retry) : Promise.reject(e2);
      }(e);
    }
  };
}
MAX_OBJECT_NR.toString();
const memoized = {};
async function memoizeConcurrent(key, computation) {
  const keyStr = JSON.stringify(key);
  return keyStr in memoized ? memoized[keyStr] : memoized[keyStr] = withFinally(computation(key), () => {
    delete memoized[keyStr];
  });
}
function createMemoizedCache(genFn) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (key, ...args) => (key in cache || (cache[key] = genFn(key, ...args)), cache[key]);
}
function toSafeKey(key) {
  return key.replace(".", "$");
}
function fromSafeKey(key) {
  return key.replace("$", ".");
}
function toSafeAlias(alias) {
  return alias?.replace(".", "$");
}
function attributeToSql(value) {
  if (void 0 === value)
    return null;
  if (value instanceof Big)
    return bigToSql(value);
  if (value instanceof Date)
    return Number(value);
  if ("boolean" == typeof value)
    return /* @__PURE__ */ function(x) {
      return x ? 1 : 0;
    }(value);
  if (Array.isArray(value))
    throw new AssertionError();
  return value;
}
function sqlToRuntime(value, type) {
  if (null === value)
    return null;
  switch (type) {
    case "DateTime":
      return value;
    case "Boolean":
      return Boolean(value);
    case "Decimal":
    case "Integer":
    case "Long":
      return function(x) {
        const sign = x.startsWith("-") ? "-" : "", meaningfulDigits = x.replace(/^-?0*/, "");
        return sign + ("" !== meaningfulDigits ? meaningfulDigits : "0");
      }(value);
    case "ObjectReferenceSet":
      return "" === value ? null : value.split(",");
    default:
      return String(value);
  }
}
function runtimeToSql(value, type) {
  switch (type) {
    case "AutoNumber":
    case "Binary":
    case "HashString":
    case "Enum":
    case "ObjectReference":
    case "ObjectReferenceSet":
    case "String":
      return null != value ? String(value) : null;
    case "DateTime":
      return null != value ? Number(value) : null;
    case "Boolean":
      return Number(value);
    case "Decimal":
    case "Integer":
    case "Long":
      return function(x) {
        if (null == x)
          return null;
        return bigToSql(new Big(x));
      }(value);
    default:
      throw new AssertionError();
  }
}
function bigToSql(x) {
  const nrOfZeroes = 20 - Math.max(0, x.e) - 1;
  return (x.s < 0 ? "-" : "") + new Array(nrOfZeroes + 1).join("0") + x.abs().toFixed();
}
class GuidMapping {
  constructor() {
    this.guidMap = {};
  }
  add(from, to) {
    this.guidMap[from] = to;
  }
  has(from) {
    return from in this.guidMap;
  }
  remove(key) {
    delete this.guidMap[key];
  }
  map(guidOrGuids) {
    return Array.isArray(guidOrGuids) ? guidOrGuids.map(this.mapGuid.bind(this)) : this.mapGuid(guidOrGuids);
  }
  mapChange(change, entityMeta) {
    const mappedChange = {};
    return Object.entries(change).forEach(([attr, entry]) => {
      if (void 0 !== entry.value) {
        const value = "ObjectReference" === entityMeta.attributes[attr]?.type && null != entry.value ? this.map(entry.value) : entry.value;
        mappedChange[attr] = { ...entry, value };
      } else
        mappedChange[attr] = { ...entry };
    }), mappedChange;
  }
  mapMxObjectJSON(obj) {
    const meta = getEntityMeta(obj.objectType), attributes = {};
    return Object.entries(obj.attributes).forEach(([attr, value]) => {
      isReferenceAttribute(meta, attr) ? attributes[attr] = { ...value, value: this.map(value.value) } : attributes[attr] = value;
    }), { ...obj, guid: this.map(obj.guid), attributes };
  }
  import(...mappings) {
    mappings.forEach((mapping) => Object.entries(mapping.guidMap).forEach(([key, value]) => this.add(key, value)));
  }
  entries() {
    return Object.entries(this.guidMap);
  }
  testClear() {
    Object.keys(this.guidMap).forEach((key) => delete this.guidMap[key]);
  }
  reverseCopyTo(guidMapping) {
    Object.keys(this.guidMap).forEach((from) => guidMapping.add(this.map(from), from));
  }
  mapGuid(guid) {
    return this.guidMap[guid] ?? guid;
  }
}
class OfflineToRuntimeGuidMapping extends GuidMapping {
  add(offlineGuid, runtimeGuid) {
    if (isRuntimeGuid(offlineGuid) || !isRuntimeGuid(runtimeGuid))
      throw new AssertionError();
    super.add(offlineGuid, runtimeGuid);
  }
  reverse() {
    const map = new RuntimeToOfflineGuidMapping();
    return super.reverseCopyTo(map), map;
  }
}
class RuntimeToOfflineGuidMapping extends GuidMapping {
  add(runtimeGuid, offlineGuid) {
    if (!isRuntimeGuid(runtimeGuid) || isRuntimeGuid(offlineGuid))
      throw new AssertionError();
    super.add(runtimeGuid, offlineGuid);
  }
  reverse() {
    const map = new OfflineToRuntimeGuidMapping();
    return super.reverseCopyTo(map), map;
  }
}
const syncedObjsRuntimeToOfflineMap = new RuntimeToOfflineGuidMapping();
function getRuntimeGuid(offlineGuid) {
  return syncedObjsRuntimeToOfflineMap.reverse().map(offlineGuid);
}
function chunkParameters(arr, amountPerItem = 1) {
  const actualChunkSize = Math.floor(999 / amountPerItem), result = [];
  for (let i = 0; i < arr.length; i += actualChunkSize)
    result.push(arr.slice(i, i + actualChunkSize));
  return result;
}
function toSqlFilter(filter, tableName, mainQuery) {
  switch (filter.type) {
    case "attribute":
      return { type: "Boolean" === filter.attributeType || "DateTime" === filter.attributeType ? "int" : "string", expr: `${toSafeAlias(filter.context) ?? tableName}.[${"id" !== filter.attribute ? toSafeKey(filter.attribute) : "guid"}]`, params: [] };
    case "value":
      const value = filter.isGuid ? getRuntimeGuid(filter.value) : attributeToSql(filter.value);
      return null === value ? { type: "null", expr: "NULL", params: [] } : { type: "number" == typeof value ? "int" : "string", expr: "?", params: [value] };
    case "function":
      const args = filter.parameters.map((p) => toSqlFilter(p, tableName, mainQuery)), joinsFromArgs = args.flatMap((a) => a.joins ?? []);
      switch (filter.name) {
        case "true":
          return ONE;
        case "false":
          return ZERO;
        case "not": {
          const arg12 = toIntOrStringResult(ensure(args[0]));
          return { type: "int", expr: `(not ${arg12.expr})`, params: arg12.params, joins: joinsFromArgs };
        }
        case "or":
        case "and": {
          const fixedArgs = args.map(toIntOrStringResult);
          return { type: "int", expr: "(" + fixedArgs.map((a) => a.expr).join(` ${filter.name} `) + ")", params: combineParams(...fixedArgs), joins: joinsFromArgs };
        }
        case "=":
        case "!=":
        case ">":
        case ">=":
        case "<":
        case "<=": {
          let [arg12, arg2] = args.some((a) => "int" === a.type) ? args.map(castAsInt) : args;
          const operation = "=" === filter.name ? "is" : "!=" === filter.name ? "is not" : filter.name;
          return arg12 = ensure(arg12), arg2 = ensure(arg2), { type: "int", expr: `(${arg12.expr} ${operation} ${arg2.expr})`, params: combineParams(arg12, arg2), joins: joinsFromArgs };
        }
        case "contains":
        case "starts-with":
        case "ends-with": {
          const arg12 = ensure(args[0]), arg2 = ensure(args[1]);
          if ("null" === arg2.type)
            return ONE;
          if ("null" === arg12.type)
            return ZERO;
          const expected = `replace(replace(replace(${arg2.expr}, '${escapeChar = "~"}', '${escapeChar + escapeChar}'), '%', '${escapeChar + "%"}'), '_', '${escapeChar + "_"}')`, like = "starts-with" === filter.name ? `${expected} || '%'` : "ends-with" === filter.name ? `'%' || ${expected}` : `'%' || ${expected} || '%'`;
          return { type: "int", expr: `(${arg12.expr} like ${like} escape '~')`, params: arg12.params.concat(arg2.params), joins: joinsFromArgs };
        }
        case "length":
        case "string-length":
          const arg1 = ensure(args[0]);
          return "null" === arg1.type ? ZERO : { type: "int", expr: `length(${arg1.expr})`, params: arg1.params, joins: joinsFromArgs };
        case "in":
          const attribute = ensure(args[0]), values = ensure(args[1]);
          if (!Array.isArray(values.params[0]))
            throw new AssertionError("'in' function expect array of values");
          return { type: "string", expr: `${attribute.expr} in (${new Array(values.params[0].length).fill("?").join(",")})`, params: values.params[0], joins: joinsFromArgs };
        default:
          throw new AssertionError(`Operator ${filter.name} is not yet supported`);
      }
    case "association":
      const association = filter.associationPath.split("/")[0];
      return { type: "string", expr: `${toSafeAlias(filter.context) ?? tableName}.[${toSafeKey(association)}]`, params: [] };
    case "relatedEntity":
      const subqueryTableAlias = toSafeAlias(filter.rightEntityAlias), subqueryTableName = toUserScopedName(toSafeKey(filter.rightEntity)), subqueryFilter = void 0 === filter.next ? ZERO : toSqlFilter(filter.next, subqueryTableAlias, false), joinsAsSql = subqueryFilter.joins?.join("") ?? "", leftAttr = toSqlFilter(filter.left, tableName, mainQuery).expr, rightAttr = toSqlFilter(filter.right, subqueryTableAlias, mainQuery).expr;
      return mainQuery ? { type: "int", expr: [`${leftAttr} IN (`, `SELECT ${rightAttr}`, ` FROM ${subqueryTableName} AS ${subqueryTableAlias}`, joinsAsSql, void 0 === filter.next ? "" : ` WHERE ${subqueryFilter.expr}`, ")"].join(""), params: subqueryFilter.params } : { ...subqueryFilter, joins: (subqueryFilter.joins ?? []).concat(` INNER JOIN ${subqueryTableName} AS ${subqueryTableAlias} ON ${rightAttr} = ${leftAttr}`) };
  }
  var escapeChar;
}
const ONE = { type: "int", expr: "1", params: [] }, ZERO = { type: "int", expr: "0", params: [] };
function toIntOrStringResult(result) {
  return "null" === result.type ? ZERO : result;
}
function castAsInt(result) {
  return "string" === result.type ? { type: "int", expr: `cast(${result.expr} as integer)`, params: result.params } : result;
}
function combineParams(...args) {
  return [].concat(...args.map((a) => a.params));
}
function convertToSpecializationFilter(generalization, specialization, filter) {
  if (generalization === specialization)
    return filter;
  switch (filter?.type) {
    case "attribute":
      return { type: "attribute", attribute: filter.attribute, attributeType: filter.attributeType, context: replaceContext(generalization, specialization, filter.context) };
    case "association":
      return { type: "association", associationPath: filter.associationPath, associationType: filter.associationType, context: replaceContext(generalization, specialization, filter.context) };
    case "relatedEntity":
      return { type: "relatedEntity", left: convertToSpecializationFilter(generalization, specialization, filter.left), rightEntity: replaceEntity(generalization, specialization, filter.rightEntity), rightEntityAlias: replaceContext(generalization, specialization, filter.rightEntityAlias), right: convertToSpecializationFilter(generalization, specialization, filter.right), next: convertToSpecializationFilter(generalization, specialization, filter.next) };
    case "function":
      return { type: "function", name: filter.name, parameters: filter.parameters.map((p) => convertToSpecializationFilter(generalization, specialization, p)) };
    case "value":
    case void 0:
      return filter;
  }
}
function replaceContext(generalization, specialization, context) {
  return context?.startsWith(generalization) ? `${specialization}${context.slice(generalization.length)}` : context;
}
function replaceEntity(generalization, specialization, entity) {
  return entity === generalization ? specialization : entity;
}
function createGetEntitiesSql(guids) {
  return 0 === guids.length ? [] : chunkParameters(guids).map((value) => {
    const guidPlaceholders = new Array(value.length).fill("?").join(", ");
    return [`SELECT "guid", "tableName" FROM "${toUserScopedName("_guidToTable")}" WHERE "guid" IN (${guidPlaceholders})`, value];
  });
}
function createGetDirtyObjectsMetadataSql(excludedEntities = /* @__PURE__ */ new Set()) {
  const excludeCondition = excludedEntities.size > 0 ? ` AND "tableName" NOT IN (${Array.from(excludedEntities).map((e) => `'${e}'`).join(", ")})` : "";
  return [`SELECT "guid", "tableName" FROM "${toUserScopedName("_guidToTable")}" WHERE "syncId" IS NOT NULL${excludeCondition}`, []];
}
function createGetSyncIdsSqlQueries(guids) {
  return chunkParameters(guids).map((value) => {
    const guidPlaceholders = new Array(value.length).fill("?").join(", ");
    return [`SELECT "guid", "syncId" FROM "${toUserScopedName("_guidToTable")}" WHERE "guid" IN (${guidPlaceholders})`, value];
  });
}
function createClearDirtyGuidsSqlQueries(guids) {
  if (0 === guids.length)
    throw new AssertionError("No guids specified");
  return chunkParameters(guids).map((value) => {
    const guidPlaceholders = new Array(value.length).fill("?").join(", ");
    return [`UPDATE "${toUserScopedName("_guidToTable")}" SET "syncId" = NULL WHERE "guid" IN (${guidPlaceholders})`, value];
  });
}
function createCheckTableExistSqlQuery(tableName) {
  return ["SELECT COUNT(name) as cnt FROM sqlite_master WHERE type='table' AND name=?", [tableName]];
}
function createDeleteEntitiesMetaSqlQueries(entities) {
  return chunkParameters(entities).map((value) => {
    const tablePlaceholders = new Array(value.length).fill("?").join(", ");
    return [`DELETE FROM "${toUserScopedName("_guidToTable")}" WHERE "tableName" IN (${tablePlaceholders})`, value];
  });
}
function getEntityAssociationsPairs(targetEntity, entities, includeReferenceSets = true) {
  const targetEntityWithSupers = /* @__PURE__ */ new Set([targetEntity, ...getEntityMeta(targetEntity)?.generalizations ?? []]);
  return Object.assign({}, ...entities.map((entity) => {
    const meta = getEntityMeta(entity), associationsReferencingObjectType = Object.values(meta?.attributes ?? {}).filter((attrMeta) => attrMeta.referenceEntity && targetEntityWithSupers.has(attrMeta.referenceEntity) && (includeReferenceSets || "ObjectReferenceSet" !== attrMeta.type)).map((attrMeta) => attrMeta.name);
    return associationsReferencingObjectType.length > 0 ? { [entity]: associationsReferencingObjectType } : {};
  }));
}
const clone = (objectToClone) => {
  if (null === objectToClone || "object" != typeof objectToClone)
    return objectToClone;
  const objectClone = Array.isArray(objectToClone) ? [] : {};
  return Object.keys(objectToClone).forEach((prop) => objectClone[prop] = clone(objectToClone[prop])), objectClone;
};
async function executeNoImpactInstructions(instructions) {
  const ui = getUI();
  for (const instruction of instructions ?? [])
    switch (instruction.type) {
      case "logout":
        mx.logout();
        break;
      case "show_login":
        ui.showLogin();
        break;
      case "download_file":
        const obj = await getByGuid(instruction.args.FileDocumentGuid);
        ui.downloadFile({ mxobject: ensure(obj), target: instruction.args.Target });
        break;
      case "text_message":
        ui.showMessage(instruction.args.MessageType, instruction.args.MessageContent, instruction.args.MessageBlock);
    }
}
function gatherUpdates(objectCache, json) {
  const changedAttrs = Object.entries(json.changes ?? {}).map(([guid, objChanges]) => Object.keys(objChanges).map((attr) => ({ guid, attr }))), resetAttrs = Object.entries(json.resets ?? {}).map(([guid, attributes]) => attributes.map((attr) => ({ guid, attr }))), attrsChangedByObjects = (json.objects ?? []).map((objectJson) => {
    const obj = objectCache.getObject(objectJson.guid);
    return null !== obj ? function(cachedObj, incomingJson) {
      const incomingObj = MxObject.fromJson(incomingJson);
      return getAttributesMeta(incomingJson.objectType).map((attrMeta) => attrMeta.name).filter((attr) => !function(lhsObj, rhsObj, attr2) {
        if (lhsObj.isReadonlyAttr(attr2) !== rhsObj.isReadonlyAttr(attr2))
          return false;
        if (lhsObj.isReference(attr2)) {
          if (attr2 === SystemAttribute.ChangedBy || attr2 === SystemAttribute.Owner)
            return true;
          return lhsObj.getOriginalReferences(attr2).sort((a, b) => a.localeCompare(b)).join(",") === rhsObj.getOriginalReferences(attr2).sort((a, b) => a.localeCompare(b)).join(",");
        }
        const lhsValue = lhsObj.getOriginalValue(attr2), rhsValue = rhsObj.getOriginalValue(attr2);
        return lhsValue === rhsValue || null != lhsValue && null != rhsValue && lhsValue.valueOf() === rhsValue.valueOf();
      }(cachedObj, incomingObj, attr));
    }(obj, objectJson).map((attr) => ({ guid: objectJson.guid, attr })) : [];
  }), refreshedGuids = unique(concat((json.instructions ?? []).map(getRefreshGuids)).concat(json.deletes ?? [])), attrUpdates = uniqueBy([changedAttrs, resetAttrs, attrsChangedByObjects].flat(2), (x) => `${x.guid}:${x.attr}`).map(({ guid, attr }) => ({ guid, attr })).filter(({ guid }) => !refreshedGuids.includes(guid) && objectCache.has(guid)), objUpdates = refreshedGuids.filter((guid) => objectCache.has(guid)).map((guid) => ({ guid })), entityUpdates = unique(concat((json.instructions ?? []).map((i) => "refresh_class" === i.type ? i.args.classnames : []))).map((entity) => ({ entity }));
  return concat([attrUpdates, objUpdates, entityUpdates]);
}
function getRefreshGuids(i) {
  return "refresh_object_list" === i.type ? i.args.ObjectIds : [];
}
async function handleRuntimeSuccess(objectCache, lockManager, json, options) {
  return handleRuntimeSuccessResponse(objectCache, lockManager, json, gatherUpdates(objectCache, json), options);
}
async function handleRuntimeSuccessResponse(objectCache, lockManager, json, updates, options) {
  const release = function(lockManager2, { objects = [], committedObjectsOmitted = false, commits = [] }) {
    const objectGuids = objects.map((o) => o.guid), omittedGuids = committedObjectsOmitted ? commits.filter((guid) => !objects.some((obj) => obj.guid === guid)) : [];
    return lockManager2.lock(objectGuids.concat(omittedGuids));
  }(lockManager, json);
  try {
    await async function(objectCache2, lockManager2, { objects = [], changes = {}, newpersistable = [], commits = [], deletes = [], resets = {}, committedObjectsOmitted = false }) {
      objectCache2.removeChanges(resets), objectCache2.addChanges(changes);
      const creates = objects.filter((objJson) => isUncached(objJson)).filter((objJson) => isPersistable(objJson) ? newpersistable.includes(objJson.guid) : !commits.includes(objJson.guid)).map((obj) => obj.guid);
      if (objectCache2.onCreate(creates), objectCache2.onDelete(deletes), objectCache2.onCommit(commits), objectCache2.setMxObjects(objects), committedObjectsOmitted) {
        const committedGuidsInStaleCache = commits.filter((guid) => objectCache2.has(guid) && !objects.some((obj) => obj.guid === guid));
        if (committedGuidsInStaleCache.length > 0) {
          const json2 = await retrieveByIds(committedGuidsInStaleCache, {});
          await handleRuntimeSuccess(objectCache2, lockManager2, json2);
        }
      }
      function isUncached(jsonObj) {
        return !objectCache2.has(jsonObj.guid);
      }
      function isPersistable(jsonObj) {
        return Boolean(getEntityMeta(jsonObj.objectType)?.isPersistable);
      }
    }(objectCache, lockManager, json);
    const closeInstructions = (json.instructions ?? []).filter((i) => "close" === i.type), openInstructions = (json.instructions ?? []).filter((i) => "open_form" === i.type), suspendClosePageUpdate = openInstructions.some((i) => "content" === i.args.FormTarget);
    if (function(instructions, targetForm, suspendClosePageUpdate2) {
      if (0 === instructions.length || !targetForm)
        return;
      const numberOfPagesToClose = instructions.reduce((totalPagesToClose, currentInstruction) => totalPagesToClose + currentInstruction.args.NumberOfPagesToClose, 0);
      if (numberOfPagesToClose < 1)
        throw new AssertionError(`The number of pages to close evaluated to ${numberOfPagesToClose}. It must be at least 1.`);
      targetForm.setSuspend(true), targetForm.closePage(numberOfPagesToClose, true, suspendClosePageUpdate2).finally(() => {
        targetForm.setSuspend(false);
      }).catch((error) => {
        handleError(error);
      });
    }(closeInstructions, options?.targetForm, suspendClosePageUpdate), await publish(...updates), await async function(instructions, targetForm) {
      const openFormPromises = [], lastOpenPageInstruction = [...instructions].reverse().find((i) => "content" === i.args.FormTarget);
      for (const instruction of instructions) {
        const location = instruction.args.FormTarget, pageUpdateSuspended = "content" === location && instruction !== lastOpenPageInstruction, ui = getUI();
        openFormPromises.push(ui.openForm2(instruction.args.FormPath, mapValues(instruction.args.FormParameters, (v) => v ?? void 0), instruction.args.FormTitle, targetForm, { location, url: instruction.args.FormUrl, queryString: instruction.args.QueryString, width: instruction.args.FormWidth, height: instruction.args.FormHeight, resizable: instruction.args.FormResizable, pageUpdateSuspended, preferUnderlyingModalOverLastFocusedElement: true }));
      }
      await Promise.all(openFormPromises);
    }(openInstructions), await executeNoImpactInstructions(json.instructions), await handleValidations(json.datavalidation), !options?.autoRelease)
      return release;
  } catch {
    options?.autoRelease || release();
  } finally {
    options?.autoRelease && release();
  }
}
async function handleRuntimeError(objectCache, e, onValidation) {
  if (e instanceof ValidationError) {
    const json = e.original, updates = gatherUpdates(objectCache, json).filter((u) => !("attr" in u));
    await publish(...updates), await executeNoImpactInstructions(json.instructions), await handleValidations(json.datavalidation, onValidation);
  }
}
async function handleValidations(datavalidations, onValidation) {
  const validations = ObjectValidation.fromResponse(datavalidations ?? []);
  await getData().sendValidationUpdates(validations), validations.length > 0 && onValidation && onValidation(validations);
}
class SynchronizationError extends HandledError {
  constructor(message = "Could temporarily not synchronize data. Please try again later.") {
    super(message), Object.setPrototypeOf(this, SynchronizationError.prototype);
  }
}
class NotImplementedError extends Error {
  constructor(what = "") {
    super("Not implemented" + ("" !== what ? ": " + what : "")), Object.setPrototypeOf(this, NotImplementedError.prototype);
  }
}
class _DataBackend {
  getByGuid(guids, filter) {
    return Promise.reject(new NotImplementedError("getByGuid"));
  }
  getByPath(guid, path, entity, direction) {
    return Promise.reject(new NotImplementedError("getByPath"));
  }
  getByXPath(xpath, filter, wantCount) {
    return Promise.reject(new NotImplementedError("getByXPath"));
  }
  action(params, context, targetForm, async, onValidation) {
    return Promise.reject(new NotImplementedError("action"));
  }
  create(entity) {
    return Promise.reject(new NotImplementedError("create"));
  }
  commit(guids, context, targetForm, onValidation) {
    return Promise.reject(new NotImplementedError("commit"));
  }
  rollback(guids) {
    return Promise.reject(new NotImplementedError("rollback"));
  }
  remove(guids) {
    return Promise.reject(new NotImplementedError("remove"));
  }
  validate(guids) {
    return Promise.reject(new NotImplementedError("validate"));
  }
  saveDocument(guid, name, params, blob) {
    return Promise.reject(new NotImplementedError("saveDocument"));
  }
  getDocumentUrl(guid, changedDate, isThumb) {
    throw new NotImplementedError("getDocumentUrl");
  }
  getImageUrl(url) {
    return Promise.reject(new NotImplementedError("getImageUrl"));
  }
  cleanup() {
    return Promise.reject(new NotImplementedError("cleanup"));
  }
}

function getStaticResourceUrl(url) {
  if (url.startsWith("data:"))
    return url;
  var path;
  /^\w+:\/\//.test(url) || (url = (path = url).startsWith("data:") ? path : mx.appUrl + path);
  const cacheBust = getSession().getConfig("cachebust");
  return url.startsWith(mx.appUrl) && !url.endsWith(cacheBust) && (url += (url.includes("?") ? "&" : "?") + cacheBust), url;
}
function getRemoteDynamicResourceUrl(guid, changedDate, isThumb, fileName) {
  return `${mx.remoteUrl}file?guid=${guid}` + (changedDate ? `&changedDate=${changedDate}` : "") + (isThumb ? "&thumb=true" : "") + (fileName ? `&name=${encodeURIComponent(fileName)}` : "");
}

function injectLoggerIntoDatabase(database, logManager) {
  const dbLogger = logManager.getLogger(LogNode.Database);
  database.registerQueryListener((queryDescription) => {
    const stopwatch = new Stopwatch();
    return [(results) => {
      const resultArray = Array.isArray(results) ? results : [results];
      dbLogger.debounced.trace(`SQL request was completed in ${stopwatch.measure()} milliseconds. Rows count: ${resultArray.length}. Query: "${queryDescription}`);
    }, (error) => {
      dbLogger.warn(`SQL request was failed in ${stopwatch.measure()} milliseconds. Error: ${error.message}. Query: "${queryDescription}`);
    }];
  });
}
function convertLoggerArgument(arg) {
  if ("string" == typeof arg)
    return arg;
  if (arg instanceof Error) {
    const message = `${arg.message} ${arg.stack}`;
    return `${2 === (message.match(/Nanoflow stack:/g) ?? []).length ? message.replace(/^Nanoflow stack:\n(.*\n)*$/m, "") : message}`;
  }
  if (arg?.outerHTML)
    return arg.outerHTML;
  try {
    return JSON.stringify(arg);
  } catch {
    return "[Unserializable data. See browser console for the details]";
  }
}

var Access;
function accessible(value, access = Access.Write) {
  return { access, value };
}
function notAccessible() {
  return { access: Access.None };
}
function getSubscribedObjectState$(store, sourceWidget) {
  const [state$] = store.useSlot(sourceWidget, "object");
  return getSubscribedObject$(sourceWidget, state$, store);
}
function getSubscribedObject$(sourceWidget, state$, store) {
  return fromComputation$(`Object of ${sourceWidget}`, () => flatMapL(state$.dependOn() ?? loading(), (stateObj) => (dependOnSubscription({ guid: stateObj.getGuid(), tag: sourceWidget }, store), stateObj.isUnavailable() ? unavailable() : available(stateObj))));
}
function withObjectKeeping$(widgetId, store, value$, getObjects) {
  return fromComputation$(`Subscribe to objects of ${widgetId}`, () => {
    const value = value$.dependOn();
    return "available" === value.status && getObjects(value.value).filter(shouldSubscribeTo).forEach((fullObject) => dependOnSubscription({ tag: widgetId, guid: fullObject.getGuid() }, store)), value;
  });
}
function shouldSubscribeTo(mxObject) {
  const guid = mxObject.getGuid(), data = getData();
  return !mxObject.isPartial() || data.isNew(guid) || Object.keys(data.getChanges(guid)).length;
}
function getObjectByPath$(rootObject$, path, store, onlyFromCache = false) {
  const objectsByPath$ = getObjectsByPath$(rootObject$, path, store, onlyFromCache);
  return fromComputation$(`Get single object from retrieve by ${path}`, () => flatMapL(objectsByPath$.dependOn(), (objectsByPath) => "cacheMiss" !== objectsByPath ? 1 === objectsByPath.length ? available(objectsByPath[0]) : 0 === objectsByPath.length ? unavailable() : crash() : available("cacheMiss")));
}
function getObjectsByPath$(rootObject$, path, store, onlyFromCache = false) {
  const pathSteps = path.split("/");
  let objectsSoFar$ = fromComputation$(`Root object to fetch ${path} from`, () => mapL(rootObject$.dependOn(), (rootObject) => [rootObject]));
  for (; pathSteps.length > 0; ) {
    const [association, entity] = pathSteps.splice(0, 2), previousObjects$ = objectsSoFar$, fetchResult$ = fromRequest$(`Fetch ${association} of ${path}`, () => {
      const previousObjects = previousObjects$.dependOn();
      if ("available" !== previousObjects.status || "cacheMiss" === previousObjects.value)
        return previousObjects;
      const unavailableGuids = /* @__PURE__ */ new Set(), cachedObjects = /* @__PURE__ */ new Set();
      let schemaObjects = [];
      for (const previousObject of previousObjects.value) {
        if (previousObject.isPartial() || (dependOnSubscription({ guid: previousObject.getGuid() }, store), dependOnSubscription({ guid: previousObject.getGuid(), attr: association }, store)), !previousObject.has(association))
          return unavailable();
        const children = previousObject.getChildren(association);
        if (children.length)
          schemaObjects.push(...children);
        else
          for (const reference of previousObject.getReferences(association)) {
            const cachedObject = getData().getCachedObject(reference);
            cachedObject ? cachedObjects.add(cachedObject) : unavailableGuids.add(reference);
          }
      }
      const cachedGuids = new Set(Array.from(cachedObjects).map((o) => o.getGuid()));
      for (const schemaObjectGuid of schemaObjects.map((o) => o.getGuid())) {
        (unavailableGuids.has(schemaObjectGuid) || cachedGuids.has(schemaObjectGuid) || schemaObjects.filter((o) => o.getGuid() === schemaObjectGuid).length > 1) && (schemaObjects = schemaObjects.filter((o) => o.getGuid() !== schemaObjectGuid), cachedGuids.has(schemaObjectGuid) || unavailableGuids.add(schemaObjectGuid));
      }
      return 0 === unavailableGuids.size ? available(schemaObjects.concat(...cachedObjects)) : onlyFromCache ? available("cacheMiss") : getByGuids(Array.from(unavailableGuids)).then((mxobjs) => available(mxobjs.concat(...schemaObjects, ...cachedObjects)));
    });
    objectsSoFar$ = fromComputation$(`Cast fetch result of ${association} in ${path}`, () => {
      const fetchResult = fetchResult$.dependOn();
      return "available" !== fetchResult.status || "cacheMiss" === fetchResult.value ? fetchResult : (fetchResult.value.forEach((obj) => dependOnSubscription({ guid: obj.getGuid() }, store)), available(fetchResult.value.filter((obj) => !obj.isUnavailable() && obj.isA(entity))));
    });
  }
  return objectsSoFar$;
}
function getAccessibleAttribute(object, attribute, store) {
  return object.isPartial() || (dependOnSubscription({ guid: object.getGuid() }, store), dependOnSubscription({ guid: object.getGuid(), attr: attribute }, store)), object.has(attribute) ? accessible(object.get2(attribute), object.isReadonlyAttr(attribute) ? Access.Read : Access.Write) : notAccessible();
}
function getAttribute$(objects$, attribute, store) {
  return fromComputation$(`Value of ${attribute}`, () => mapL(objects$.dependOn(), (objects) => Array.isArray(objects) ? function(objects2, attribute2, store2) {
    const accs = objects2.map((object) => getAccessibleAttribute(object, attribute2, store2));
    return accs.every((a) => a.access === Access.None) ? notAccessible() : accessible(accs.filter((acc) => acc.access !== Access.None).map((acc) => acc.value), Access.Read);
  }(objects, attribute, store) : getAccessibleAttribute(objects, attribute, store)));
}
function withFormSuspension$(store, widgetId, fetchTrigger$, loadedCallback) {
  const [formSuspended$] = store.useSlot(pageScope, "formSuspended"), [firstLoadDone$] = store.useSlot(widgetId, "firstLoadDone");
  let lastUnsuppressedTrigger;
  return fromComputation$(`Load trigger when not suspended of data source of ${widgetId}`, () => {
    const formSuspended = formSuspended$.dependOn(), latestTrigger = fetchTrigger$.dependOn(), isFirstLoad = true !== readUntracked(firstLoadDone$);
    return formSuspended && loadedCallback?.(), formSuspended && !isFirstLoad && void 0 !== lastUnsuppressedTrigger || (lastUnsuppressedTrigger = latestTrigger), lastUnsuppressedTrigger;
  });
}
!function(Access2) {
  Access2[Access2.None = 0] = "None", Access2[Access2.Read = 1] = "Read", Access2[Access2.Write = 2] = "Write";
}(Access || (Access = {}));

const UNAVAILABLE = { status: "unavailable", value: void 0 }, LOADING = { status: "loading", value: void 0 };
function dynAvailable(value) {
  return { status: "available", value };
}
function dynUnavailable() {
  return UNAVAILABLE;
}
function fromLoadable(loadable) {
  switch (loadable.status) {
    case "available":
      return dynAvailable(loadable.value);
    case "unavailable":
      return dynUnavailable();
    case "loading":
      return void 0 === value ? LOADING : { status: "loading", value };
  }
  var value;
}
function asDynamicValue$(value$) {
  return asReloadable$(fromComputation$(`Dynamic ${lowerCaseFirst(value$.name)}`, () => fromLoadable(value$.dependOn())), (v) => ({ value: v.value }));
}
const DEBOUNCE_DELAY = 100;
function asReloadable$(value$, rememberFunc) {
  let lastReturnedValue, debounceHandle, lastAvailableValue = {};
  const [debounceElapsed$, elapseDebounce] = useDependency(`Reloadable monitor of ${lowerCaseFirst(value$.name)}`), previousValue$ = getPreviousValue$(value$);
  return fromComputation$(`Reloadable ${lowerCaseFirst(value$.name)}`, () => {
    debounceElapsed$.dependOn();
    const newValue = value$.dependOn(), triggeredByTimer = newValue === previousValue$.dependOn();
    switch (function(handle) {
      if (void 0 === handle || handle >= scheduledReloadables.length)
        return;
      scheduledReloadables[handle] = void 0;
    }(debounceHandle), newValue.status) {
      case "available":
        return lastAvailableValue = rememberFunc(newValue), lastReturnedValue = newValue;
      case "unavailable":
        return lastAvailableValue = {}, lastReturnedValue = newValue;
      case "loading":
        return lastReturnedValue ? (triggeredByTimer || (debounceHandle = function(action) {
          const handle = scheduledReloadables.length;
          scheduledReloadables.push(action), 1 === scheduledReloadables.length && setTimeout(() => runInAction(() => scheduledReloadables.splice(0).forEach((f) => f?.())), DEBOUNCE_DELAY);
          return handle;
        }(() => {
          lastReturnedValue = { ...newValue, ...lastAvailableValue }, elapseDebounce(), debounceHandle = void 0;
        })), lastReturnedValue) : lastReturnedValue = newValue;
    }
  });
}
const scheduledReloadables = [];

function getActionArguments$(argMap, store, widgetId, predefinedArguments, allowEmptyMultiSelect = true, allowEmptyValues = false) {
  const params$ = mapValues(argMap, (arg) => {
    if ("expression" in arg)
      return toExpressionArgument$(store, arg, widgetId, attributeValueToActionArgument, predefinedArguments, allowEmptyValues);
    {
      const { widget, source } = arg, actionArgument = toActionArgument$(store, source, widget, allowEmptyMultiSelect);
      return fromComputation$(`action argument for ${widgetId}`, () => {
        const sourceMap = (predefinedArguments?.dependOn() ?? {})[widget] ?? {};
        return source in sourceMap ? available(sourceMap[source]) : actionArgument.dependOn();
      });
    }
  });
  return fromComputation$("Load action parameters", () => mapValues(params$, (p$) => p$.dependOn()));
}
function toActionArgument$(store, source, sourceWidget, allowEmptyMultiSelect = true) {
  switch (source) {
    case "object":
      return function(store2, sourceWidget2) {
        const subscribedObject$ = getSubscribedObjectState$(store2, sourceWidget2);
        return fromComputation$(`Load object of ${sourceWidget2}`, () => mapL(subscribedObject$.dependOn(), (obj) => ({ object: obj })));
      }(store, sourceWidget);
    case "selection":
      return function(store2, sourceWidget2, allowEmptyMultiSelect2) {
        const [selection$] = store2.useSlot(sourceWidget2, "selection");
        return fromComputation$(`Load selection of ${sourceWidget2}`, () => {
          const selection = selection$.dependOn();
          return selection && (allowEmptyMultiSelect2 || selection.length > 0) ? Array.isArray(selection) ? available({ ids: selection }) : available({ id: selection }) : unavailable();
        });
      }(store, sourceWidget, allowEmptyMultiSelect);
    case "localvariable":
      return function(store2, sourceWidget2) {
        const [localVariable$] = store2.useSlot(sourceWidget2, "localvariable");
        return fromComputation$(`Load variable of ${sourceWidget2}`, () => {
          const localVariable = localVariable$.dependOn();
          return void 0 === localVariable ? unavailable() : "available" === localVariable.status ? void 0 === localVariable.value ? unavailable() : available({ primitive: localVariable.value }) : localVariable;
        });
      }(store, sourceWidget);
    default:
      crash();
  }
}
function toExpressionArgument$(store, arg, widgetId, convertToArgument, predefinedArguments, allowEmptyValues = false) {
  const description = `Value of ${toFriendlyId(widgetId)}`, dynamicValue$ = asDynamicValue$(getFormExpressionResult$(description, store, arg.expression, (variable) => {
    const predefinedArgument$ = fromComputation$("widget variable computation", () => {
      const preDefs = predefinedArguments?.dependOn() ?? {};
      return function(widgetId2, arg2, predefinedArguments2) {
        const { widget, source } = arg2, sourceMap = predefinedArguments2?.[widget] ?? {};
        return sourceMap[source];
      }(0, variable, preDefs);
    }), storeVariable$ = isStoreVariableSource(variable) ? getVariableFromStore$(description, store, variable) : fromConstant$(void 0);
    return fromComputation$("widget or store variable", () => actionArgumentToWidgetVariable(predefinedArgument$.dependOn()) ?? storeVariable$.dependOn());
  }));
  return fromComputation$("Load expression argument", () => flatMapL(dynamicValue$.dependOn(), (value) => allowEmptyValues || void 0 !== value ? available(convertToArgument(value, arg.kind)) : unavailable()));
}
function toRuntimeArguments(actionArguments) {
  const result = {};
  return Object.keys(actionArguments).forEach((name) => {
    const value = actionArguments[name];
    value && (result[name] = "objects" in value ? { guids: value.objects.map((mxobj) => mxobj.getGuid()) } : "object" in value ? { guid: value.object.getGuid() } : "id" in value ? { guid: value.id } : "ids" in value ? { guids: value.ids } : "primitive" in value ? { value: attributeValueToRuntimeValue(value.primitive) } : value);
  }), result;
}
async function toNanoflowArguments(actionArguments) {
  const objectGuidsToFetch = /* @__PURE__ */ new Set();
  Object.keys(actionArguments).forEach((name) => {
    const arg = actionArguments[name];
    if (void 0 === arg)
      return;
    ("object" in arg ? [arg.object] : "objects" in arg ? arg.objects : []).filter((o) => o.isPartial()).forEach((o) => objectGuidsToFetch.add(o.getGuid())), "id" in arg ? objectGuidsToFetch.add(arg.id) : "ids" in arg && arg.ids.forEach((guid) => objectGuidsToFetch.add(guid));
  });
  const fullObjects = toObjectByKey(await getByGuids(Array.from(objectGuidsToFetch)), (o) => o.getGuid());
  function mapToFullObject(o) {
    return "string" == typeof o ? fullObjects[o] : o.isPartial() ? fullObjects[o.getGuid()] : o;
  }
  function mapToFullObjects(objects) {
    return objects.map(mapToFullObject).filter((o) => o);
  }
  return Object.keys(actionArguments).map((name) => {
    const arg = actionArguments[name];
    return { name, value: arg && ("object" in arg ? mapToFullObject(arg.object) : "objects" in arg ? mapToFullObjects(arg.objects) : "id" in arg ? mapToFullObject(arg.id) : "ids" in arg ? mapToFullObjects(arg.ids) : "primitive" in arg ? arg.primitive : crash()) };
  });
}
function getGuidsFromRuntimeArguments(args) {
  const mfGuids = [];
  return Object.values(args).forEach((mfParam) => {
    "guid" in mfParam ? mfGuids.push(mfParam.guid) : "guids" in mfParam && mfGuids.push(...mfParam.guids);
  }), mfGuids;
}
function getNanoflowArguments$(argMap, store, widgetId, description, fetchOnlyWithAllParams = false) {
  const parametersValues$ = Object.entries(argMap).map((arg) => {
    const [name, nanoFlowArg] = arg;
    let argument$;
    if ("expression" in nanoFlowArg)
      argument$ = toExpressionArgument$(store, { ...nanoFlowArg }, widgetId, attributeValueToActionArgument);
    else {
      const { widget, source } = nanoFlowArg;
      argument$ = toActionArgument$(store, source, widget);
    }
    return { name, value$: fromRequest$(`Parameter ${name} of ${description}`, () => {
      const argument = argument$.dependOn();
      if ("available" !== argument.status)
        return argument;
      const value = argument.value;
      return void 0 !== value ? "object" in value ? available(value.object) : "objects" in value ? available(value.objects) : "id" in value ? getSelection(value.id) : "ids" in value ? getSelection(value.ids) : "primitive" in value ? available(value.primitive) : crash() : crash();
    }) };
  });
  async function getSelection(selection) {
    return Array.isArray(selection) ? async function(selection2) {
      return getByGuids(selection2).then((mxObjects) => {
        const objectsById = toObjectByKey(mxObjects, (o) => o.getGuid());
        return selection2.map((guid) => objectsById[guid]).filter((o) => o);
      });
    }(selection).then((mxObjects) => available(mxObjects)) : getByGuid(selection).then((mxObject) => mxObject ? available(mxObject) : unavailable());
  }
  return fromComputation$(`Parameters of ${description}`, () => {
    const values = parametersValues$.map(({ name, value$ }) => ({ name, value: value$.dependOn() }));
    return values.every(({ value }) => "loading" !== value.status) ? fetchOnlyWithAllParams && values.some(({ value }) => "available" !== value.status) ? unavailable() : available(values.map(({ name, value }) => ({ name, value: getOrElseL(value, void 0) }))) : loading();
  });
}
function getRuntimeArguments$(argMap, store, widgetId, fetchOnlyWithAllParams = false) {
  const description = `data source of ${widgetId}`, parametersValues$ = Object.entries(argMap).map(([name, param]) => ({ name, value$: "expression" in param ? toExpressionArgument$(store, param, widgetId, attributeValueToRuntimeArgument) : toRuntimeArgument$(name, param) }));
  return fromComputation$(`Parameters of ${description}`, () => {
    const values = parametersValues$.map(({ name, value$ }) => ({ name, value: value$.dependOn() }));
    return values.every(({ value }) => "loading" !== value.status) ? fetchOnlyWithAllParams && values.some(({ value }) => "available" !== value.status) ? unavailable() : available(Object.fromEntries(values.filter(({ value }) => "available" === value.status).map(({ name, value }) => tuple(name, getOrCrashL(value))))) : loading();
  });
  function toRuntimeArgument$(name, param) {
    const descr = `Value of ${name} parameter of ${description}`, argument$ = toActionArgument$(store, param.source, param.widget);
    return fromComputation$(descr, () => mapL(argument$.dependOn(), (arg) => void 0 !== arg ? "object" in arg ? { guid: arg.object.getGuid() } : "objects" in arg ? { guids: arg.objects.map((o) => o.getGuid()) } : "id" in arg ? { guid: arg.id } : "ids" in arg ? { guids: arg.ids } : "primitive" in arg ? { value: attributeValueToRuntimeValue(arg.primitive) } : crash() : crash()));
  }
}

function getRequestDataForGuidsReachableFrom(objectCache, guids) {
  const session = getSession(), implicitInputGuids = [session.getUserId(), session.getSessionObjectId()], cachedObjects = objectCache.getAllObjects(), guidsToSend = findReachableGuidsForRequest(cachedObjects, guids.concat(implicitInputGuids));
  return getRequestData(objectCache, guidsToSend);
}
function getRequestDataForObjectAction(objectCache, guids, event) {
  const guidsToSend = /* @__PURE__ */ new Set(), cachedObjects = objectCache.getAllObjects(), [guidsNeedingReachability, otherGuids] = partition((guid) => {
    const mxobj = objectCache.getObject(guid);
    return mxobj?.metaData.needsReachableState[event] ?? false;
  }, guids);
  if (0 !== guidsNeedingReachability.length) {
    const session = getSession(), implicitInputGuids = [session.getUserId(), session.getSessionObjectId()];
    addToSet(guidsToSend, findReachableGuidsForRequest(cachedObjects, guidsNeedingReachability.concat(implicitInputGuids)));
  }
  const cachedNewObjects = cachedObjects.filter((mxobj) => objectCache.isNew(mxobj.getGuid())), newGuids = otherGuids.filter((guid) => objectCache.isNew(guid));
  switch (addToSet(guidsToSend, otherGuids), event) {
    case "commit":
      addToSet(guidsToSend, findReachableGuidsForRequest(cachedNewObjects, newGuids)), addToSet(guidsToSend, findChangedReachableGuidsForRequest(objectCache, cachedObjects, otherGuids));
      break;
    case "delete":
      addToSet(guidsToSend, findDeletableReachableGuidsForRequest(cachedObjects, otherGuids));
      break;
    case "rollback":
      addToSet(guidsToSend, findDeletableReachableGuidsForRequest(cachedObjects, newGuids));
  }
  return getRequestData(objectCache, Array.from(guidsToSend));
}
function addToSet(set, itemsToAdd) {
  itemsToAdd.forEach((item) => set.add(item));
}
function handleUncachedObjects(objectCache, mxObjs, result) {
  const { commits = [], deletes = [] } = result;
  mxObjs.forEach((mxObj) => {
    const guid = mxObj.getGuid();
    if (commits.includes(guid)) {
      const cachedMxObj = objectCache.getObject(guid);
      if (!cachedMxObj)
        throw new Error("inconsistent response: committed object is missing from response and cache");
      mxObj.resetFromJSON(cachedMxObj.jsonData);
    } else
      deletes.includes(guid) && mxObj.markAsUnavailable();
  });
}
function removeObjectKeepChanges(lockManager, objectCache, guid) {
  lockManager.getLockedGuids().has(guid) || objectCache.removeObjectKeepChanges(guid);
}
function createUpdateSqlQuery(entityMeta, updates, whereAttributeName, whereAttributeValue) {
  if (0 === Object.keys(updates).length)
    throw new AssertionError("No updates specified.");
  const params = [], updateStrings = [];
  Object.entries(updates).forEach(([attribute, value]) => {
    updateStrings.push(`"${toSafeKey(attribute)}" = ?`), params.push(runtimeToSql(value, "guid" === attribute ? "String" : ensure(entityMeta.attributes[attribute]?.type)));
  });
  const tableName = toUserScopedName(toSafeKey(entityMeta.name)), whereExpr = `WHERE ${tableName}.[${toSafeKey(whereAttributeName)}] = ?`;
  return [`UPDATE ${tableName} SET ${updateStrings.join(", ")} ${whereExpr}`, [...params, attributeToSql(whereAttributeValue)]];
}
class FormBase {
  constructor(place) {
    this.place = place, this.listeners = {}, this.suspended = false, this.title = "", this.historyId = newId("form");
  }
  getTitle() {
    return this.title;
  }
  setSuspend(suspend) {
    this.suspended !== suspend && (this.suspended = suspend);
  }
  isSuspended() {
    return this.suspended;
  }
  publish(event, callback, error) {
    const list = (this.listeners[event] ?? []).slice();
    !function next() {
      list.length ? (next.data = callback?.data, list.pop()(next, error ?? handleError)) : void 0 !== callback && callback();
    }();
  }
  listen(event, handler) {
    const list = this.listeners[event] ?? [];
    return this.listeners[event] = list, list.push(handler), () => list.splice(list.indexOf(handler), 1);
  }
  unlisten(handler) {
    handler();
  }
  close(callback, error) {
    this.closePage(1, false).then(callback).catch((e) => {
      error && error(e);
    });
  }
  getHistoryId() {
    return this.historyId;
  }
}
class FormWithStore extends FormBase {
  constructor(args) {
    super("content"), this.storeBackend = args.storeBackend, this.historyId = args.historyId, this.name = args.name, this.title = args.title, this.pageContent = args.pageContent, this.formParameters = args.formParameters, this.setFormSuspended = (value) => this.storeBackend.set(pageScope, "formSuspended", rootPath, value), runInAction(() => {
      this.storeBackend.set(pageScope, "form", rootPath, [this, this.getHistoryId()]), Object.keys(this.formParameters).forEach((param) => {
        this.storeBackend.set(param, "firstLoadDone", rootPath, false);
      }), this.setFormSuspended(false);
    }), getByGuids(this.getParameterGuids()).then((objs) => runInAction(() => this.setFormParameters(objs)), (e) => handleError(e));
  }
  getStoreBackend() {
    return this.storeBackend;
  }
  getName() {
    return this.name;
  }
  getParameterGuids() {
    return Object.values(this.formParameters).filter((g) => g);
  }
  setSuspend(suspend) {
    super.setSuspend(suspend), runInAction(() => this.setFormSuspended(suspend));
  }
  getSubmitObjects() {
    const objects = readUntracked(this.storeBackend.getAllEntries$("editableObject")).map(({ value }) => value ? getOrElseL(value, void 0) : void 0).filter((s) => s);
    return unique(objects);
  }
  async triggerValidation() {
    this.storeBackend.set(pageScope, "validationRequest", rootPath, newId("validation_request")), await wait(0);
    if (readUntracked(this.storeBackend.getAllEntries$("isInvalid")).some(({ value }) => value))
      throw new ValidationError();
  }
  getPlaceholderContent(placeholderId) {
    return this.pageContent[placeholderId] ?? null;
  }
  setFormParameters(mxobjs) {
    Object.keys(this.formParameters).forEach((param) => {
      const guid = this.formParameters[param], mxobj = mxobjs.find((o) => o.getGuid() === guid), scope = param;
      this.storeBackend.set(scope, "object", rootPath, mxobj ? available(mxobj) : unavailable()), this.storeBackend.set(scope, "firstLoadDone", rootPath, true);
    });
  }
}
const logger$2 = LogManager.get().getLogger();
let idCounter = 0;
class MxContext {
  constructor(kwArgs) {
    this.id = this.ident = ++idCounter, this.trackId = "", this.trackEntity = "", this.trackObject = null, this.localParams = {}, this.constraintby = [], this._entityToGuid = {}, this._mxidToObject = {}, kwArgs && (kwArgs.mxcontext && this.dupFrom(kwArgs.mxcontext), kwArgs.classname && kwArgs.mendixguid ? this.setContext(kwArgs.classname, kwArgs.mendixguid) : kwArgs.entity && kwArgs.guid && this.setContext(kwArgs.entity, kwArgs.guid));
  }
  hasTrackEntity() {
    return "" !== this.trackEntity;
  }
  hasTrackId() {
    return !!this.trackId;
  }
  hasTrackObject() {
    return !!this.trackObject;
  }
  getTrackEntity() {
    return this.trackEntity;
  }
  getTrackId() {
    return this.trackId;
  }
  getTrackObject() {
    return this.trackObject;
  }
  setTrackObject(obj) {
    obj && this.setContext(obj.getEntity(), obj.getGuid()), this.trackObject = obj;
  }
  getObject() {
    return this.trackObject;
  }
  setConstraints(constraints) {
    null != constraints && "" !== constraints && 0 !== constraints.length && (this.constraintby = "string" == typeof constraints ? constraints.split(",") : constraints);
  }
  getConstraints() {
    for (var t = [], i = 0; i < this.constraintby.length; i++)
      t.push(this.constraintby[i]);
    return t;
  }
  hasBacktrack() {
    return 0 !== this.constraintby.length;
  }
  getEntities() {
    return Object.keys(this._entityToGuid).filter((e) => void 0 !== e && "" !== this._entityToGuid[e]);
  }
  setContext(entity, guid) {
    if (1 === arguments.length && arguments[0] instanceof MxObject) {
      var mxobj = arguments[0];
      entity = mxobj.getEntity(), guid = mxobj.getGuid();
    }
    this.trackEntity = null == entity ? "" : entity, this.trackId = null == guid ? "" : guid, this.trackObject = null, this._entityToGuid[this.trackEntity] = this.trackId;
  }
  unsetContext(entity) {
    if ("string" != typeof entity)
      throw new Error("mendix/lib/MxContext.unsetContext: parameter entity is not of type String");
    delete this._entityToGuid[entity];
  }
  getContext(entity) {
    if ("string" != typeof entity)
      throw new Error("mendix/lib/MxContext.getContext: parameter entity is not of type String");
    if (entity in this._entityToGuid)
      return this._entityToGuid[entity];
    var meta = getEntityMeta(entity), result = null;
    return (meta?.specializations ?? []).some((subEntity) => subEntity in this._entityToGuid && (result = this._entityToGuid[subEntity], true)), result;
  }
  hasContext(entity) {
    if ("string" != typeof entity)
      throw new Error("mendix/lib/MxContext.hasContext: parameter entity is not of type String");
    return null != this.getContext(entity);
  }
  reset() {
    this._entityToGuid = {}, this._mxidToObject = {}, this.trackId = null, this.trackEntity = "", this.trackObject = null;
  }
  dupFrom(context) {
    this.reset(), this.mixin(context);
  }
  mixin(context) {
    if (context)
      context.getEntities().forEach((e) => this.setContext(e, context.getContext(e))), context.getWidgetIds().forEach((mxid) => this.setWidgetObject(mxid, context.getWidgetObject(mxid))), this.setParams(context.getParams()), this.setConstraints(context.getConstraints()), this.setContext(context.getTrackEntity(), context.getTrackId()), this.setTrackObject(context.getTrackObject());
    else {
      const entity = this.getTrackEntity();
      entity && this.unsetContext(entity), this.setContext(null, null);
    }
  }
  hasParam(key) {
    return key in this.localParams;
  }
  getParam(key) {
    return this.hasParam(key) ? this.localParams[key] : null;
  }
  getParams() {
    return this.localParams;
  }
  setParam(key, value) {
    if (null == key)
      throw new Error("mendix/lib/MxContext[" + this.ident + "].setParam key is null");
    this.localParams[key] = value;
  }
  setParams(obj) {
    if ("object" != typeof obj)
      throw new Error("mendix/lib/MxContext[" + this.ident + "].setParams requires an Object.");
    for (var i in obj)
      this.localParams[i] = obj[i];
  }
  unsetParam(key) {
    delete this.localParams[key];
  }
  resetParams() {
    this.localParams = {};
  }
  isEmpty() {
    for (var j in this._entityToGuid)
      return true;
    return false;
  }
  getGuids() {
    for (var contexts = this.getEntities(), trackId = this.getTrackId(), contextIds = trackId ? [trackId] : [], i = 0, l = contexts.length; i < l; i++) {
      var c = contexts[i];
      if (c !== SystemAttribute.Owner && c !== SystemAttribute.ChangedBy) {
        var guid = this.getContext(c);
        guid !== trackId && contextIds.push(guid);
      }
    }
    return contextIds;
  }
  getWidgetIds() {
    return Object.keys(this._mxidToObject);
  }
  getWidgetObject(widgetId) {
    return this._mxidToObject[widgetId];
  }
  setWidgetObject(widgetId, object, trackObject = true) {
    trackObject && this.setTrackObject(object), this._mxidToObject[widgetId] = object;
  }
  getWidgetObjectMap() {
    return { ...this._mxidToObject };
  }
  freeze() {
    this.setTrackObject = this.setConstraints = this.setContext = this.unsetContext = this.reset = this.dupFrom = this.setParam = this.setParams = this.unsetParam = this.setWidgetObject = this.resetParams = function() {
      return logger$2.error("mendix/lib/MxContext[" + this.ident + "].freeze: context is readonly"), false;
    };
  }
}
class NotAllowedInStrictModeError extends Error {
  constructor(operation) {
    super(`${operation} is disabled`), Object.setPrototypeOf(this, NotAllowedInStrictModeError.prototype);
  }
}
const restrictInStrictMode = (name) => {
  if (getSession().isStrictModeEnabled() && !isOffline())
    throw new NotAllowedInStrictModeError(name);
}, isGetByGuid = (args) => "guid" in args && null !== args.guid || "guids" in args && void 0 !== args.guids, isGetByPath = (args) => "path" in args, isGetByEntity = (args) => "entity" in args, isGetByMicroflow = (args) => "microflow" in args, OLD_TO_NEW_NAME = { equals: "=", lessThan: "<", lessThanOrEquals: "<=", greaterThan: ">", greaterThanOrEquals: ">=", contains: "contains" };
function legacyConstraintsToQueryFilter(entity, constraints) {
  const queries = legacyConstraintsToQueryFilters(getEntityMeta(entity), constraints);
  return queries.length > 1 ? { type: "function", name: "and", parameters: queries } : queries[0];
}
function legacyConstraintsToQueryFilters(entityMeta, constraints) {
  return constraints.map((constraint) => {
    switch (constraint.operator) {
      case "and":
      case "or":
        return { type: "function", name: constraint.operator, parameters: legacyConstraintsToQueryFilters(entityMeta, constraint.constraints) };
      default:
        const attributeType = entityMeta?.attributes[constraint.attribute]?.type ?? "String", result = { type: "function", name: OLD_TO_NEW_NAME[constraint.operator], parameters: [{ type: "attribute", attribute: constraint.attribute, attributeType }, { type: "value", value: legacyConstraintValueToFilterValue(constraint.value, attributeType), isGuid: "ObjectReference" === attributeType }] };
        return constraint.negate ? { type: "function", name: "not", parameters: [result] } : result;
    }
  });
}
function legacyConstraintValueToFilterValue(value, attributeType) {
  if (null != value)
    switch (attributeType) {
      case "Boolean":
        return "true" === value;
      case "DateTime":
        return new Date(Number(value));
      case "Decimal":
      case "Integer":
      case "Long":
        return new Big(String(value));
      default:
        return String(value);
    }
}
const emptyResult = { mxobjs: [], count: 0 };
class Data {
  constructor(objectCache, lockManager, onlineDataBackend, garbageCollector, offlineDataBackend) {
    this.objectCache = objectCache, this.lockManager = lockManager, this.onlineDataBackend = onlineDataBackend, this.garbageCollector = garbageCollector, this.offlineDataBackend = offlineDataBackend, this.name = "mendix.sys.Data", this.validationSubscriptions = [], this.sendValidationUpdates = action(async (validations) => {
      const remainingValidations = [];
      validations.forEach((validation) => {
        const unhandledVal = validation.clone();
        this.validationSubscriptions.filter((s) => "guid" in s && s.guid === validation.getGuid()).forEach(({ callback }) => {
          const trackValidation = validation.clone();
          callback([trackValidation]);
          const leftAttrs = trackValidation.getAttributes().map((a) => a.name);
          unhandledVal.getAttributes().forEach(({ name: attr }) => {
            leftAttrs.includes(attr) || unhandledVal.removeAttribute(attr);
          });
        }), remainingValidations.push(unhandledVal);
      });
      const updatesToPublish = validations.flatMap((val) => val.getAttributes().map(({ name: attr, reason }) => ({ guid: val.getGuid(), attr, val: reason }))), { handled } = await publish(...updatesToPublish);
      handled.filter((msg) => "guid" in msg && "attr" in msg).forEach(({ guid, attr }) => {
        remainingValidations.find((val) => val.getGuid() === guid).removeAttribute(attr);
      });
      const lostValidations = remainingValidations.filter((val) => val.getAttributes().length);
      if (lostValidations.length) {
        const validationsText = ObjectValidation.describe(lostValidations);
        getUI().showMessage("error", validationsText, false);
      }
    });
  }
  getBacktrack(guid, paths, callback, errorCallbackOrScope, scope) {
    let errorCallback;
    if ("function" != typeof errorCallbackOrScope ? (scope = errorCallbackOrScope, errorCallback = null) : errorCallback = errorCallbackOrScope, !paths || 0 === paths.length)
      return void callback.call(scope, "", true);
    let mxobj = null;
    const constraints = [];
    let pathIndex = 0, allMatched = true;
    const self = this, fetchConstraints = function() {
      const path = paths[pathIndex++];
      path ? self.runMapPath(mxobj, path, (constraint) => {
        constraint ? constraints.push(constraint) : allMatched = false, fetchConstraints();
      }, self.createErrorHandler(errorCallback, scope)) : callback.call(scope, constraints.join(""), allMatched);
    };
    guid ? self.get({ guid, callback(obj) {
      obj ? (mxobj = obj, fetchConstraints()) : callback.call(scope, "", false);
    }, error: self.createErrorHandler(errorCallback, scope) }) : callback.call(scope, "", false);
  }
  toString() {
    return this.name;
  }
  startup() {
    this.garbageCollector.initialize();
  }
  subscribe(args, scope) {
    if (!("val" in args) || "attr" in args)
      return subscribe$1({ ...args, callback: () => {
        if (args.callback) {
          if ("entity" in args)
            return args.callback.apply(scope, [args.entity]);
          if ("attr" in args) {
            const object = this.objectCache.getObject(args.guid), val = null != object ? object.get(args.attr) : null;
            return args.callback.apply(scope, [args.guid, args.attr, val ?? ""]);
          }
          return "guid" in args ? args.callback.apply(scope, [args.guid]) : args.callback.apply(scope);
        }
      } });
    const subscription = { ...args, callback(...callbackArgs) {
      args.callback && args.callback.apply(scope, callbackArgs);
    } };
    this.validationSubscriptions.push(subscription);
    const release = this.lockManager.lock([args.guid]);
    return { unsubscribe: () => {
      const index = this.validationSubscriptions.indexOf(subscription);
      release(), -1 !== index && this.validationSubscriptions.splice(index, 1);
    } };
  }
  unsubscribe(handle) {
    if (!("unsubscribe" in handle))
      throw new AssertionError("Trying to unsubscribe using an invalid subscription handle");
    handle.unsubscribe();
  }
  updateInCache(json) {
    return this.objectCache.removeAllChanges([json.guid]), this.objectCache.setMxObjects([json]), this.objectCache.getObject(json.guid);
  }
  removeChanges(guid) {
    this.objectCache.removeAllChanges([guid]);
  }
  action(args) {
    restrictInStrictMode("mx.data.action"), this.onlineDataBackend.action(args.params, args.context ?? new MxContext(), args.origin, !!args.async, args.onValidation).then(args.callback, this.createErrorHandler(args.error, null));
  }
  callNanoflow({ nanoflow, context, origin, callback, error }) {
    const self = this;
    (async function() {
      const nanoflowId = nanoflow.nanoflow, paramsSpec = nanoflow.paramsSpec, paramNameToGuids = Object.keys(paramsSpec).map((paramName) => ({ name: paramName, guid: context.getContext(paramsSpec[paramName]) })), allGuids = paramNameToGuids.filter((x) => Boolean(x.guid)).map((x) => x.guid), allObjects = await async function(guids) {
        return new Promise((resolve, reject) => {
          self.get({ guids, callback: (result) => resolve(result && Array.isArray(result) ? result : []), error: reject });
        });
      }(allGuids), args = paramNameToGuids.map(({ name: paramName, guid }) => ({ name: paramName, value: allObjects.find((o) => o.getGuid() === guid) }));
      try {
        return await nanoflowEngine.execute(nanoflowId, args, origin);
      } catch (e) {
        throw await handleRuntimeError(self.objectCache, e), e;
      }
    })().then((result) => this.runCallback(callback, null, result), this.createErrorHandler(error, null));
  }
  get(args, scope = null) {
    ("xpath" in args || "microflow" in args || "path" in args) && restrictInStrictMode("mx.data.get");
    const callback = args.callback;
    if ("guid" in args && null == args.guid)
      return void this.runCallback(args.callback, scope, null);
    if (!(((args2) => "xpath" in args2)(args) || isGetByPath(args) || isGetByGuid(args) || isGetByEntity(args) || isGetByMicroflow(args)))
      throw new AssertionError("xpath, guid|guids and microflow arguments are undefined");
    if ("function" != typeof callback)
      throw new AssertionError("callback is not a function");
    if ("error" in args && "function" != typeof args.error)
      throw new AssertionError("error is not a function");
    "filter" in args && args.filter?.limit && (args.filter.amount = args.filter.limit, delete args.filter.limit);
    const filter = this.mixinParams({}, args.filter, "guid" in args && null !== args.guid ? { id: null } : { id: null, attributes: null, offset: null, sort: null, amount: null, distinct: null, references: null });
    filter.id && "guids" in args && !("guid" in args) && delete filter.id, filter.id && (delete filter.attributes, delete filter.distinct), args.filter = filter, isGetByMicroflow(args) ? this.getByMicroflow(args, scope) : isGetByPath(args) ? this.getByPath(args, scope) : isGetByGuid(args) ? this.getByGuid(args, scope) : isGetByEntity(args) ? this.getByEntity(args, scope) : this.getByXPath(args, scope);
  }
  getByMicroflow(args, scope) {
    const ids = Data.extractGuids(args);
    let params = { actionname: args.microflow, applyto: "none" };
    ids ? params = { actionname: args.microflow, applyto: "selection", guids: ids } : args.xpath && (params = { actionname: args.microflow, applyto: "set", xpath: args.xpath }, args.filter?.sort && (params.sort = args.filter.sort));
    const context = args.context ?? new MxContext();
    this.action({ params, context, callback: (...callbackArgs) => this.runCallback(args.callback, scope, ...callbackArgs), error: args.error });
  }
  getByPath(args, scope) {
    const ids = Data.extractGuids(args);
    if (1 !== ids?.length)
      throw new AssertionError("path can only be used with a single guid");
    const guid = ids[0], direction = args.direction ?? "reverse";
    ("direct" === direction && isObjectOffline(guid) || "reverse" === direction && isOffline(args.entity) ? this.offlineDataBackend.getByPath(guid, args.path, args.entity, direction, (guids) => this.getByGuids(guids)) : this.onlineDataBackend.getByPath(guid, args.path, args.entity, direction)).then(({ mxobjs, count }) => {
      this.runCallback(args.callback, scope, mxobjs, { count });
    }, this.createErrorHandler(args.error, scope));
  }
  getByGuid(args, scope) {
    const id = "guid" in args ? args.guid : null, ids = Data.extractGuids(args);
    ids && 0 !== ids.length ? this.getByGuids(ids, args.filter).then(({ mxobjs, count }) => {
      if (id) {
        const result = args.filter?.id ? mxobjs.find((mxobj) => mxobj.getGuid() === id) : mxobjs[0];
        this.runCallback(args.callback, scope, result ?? null, { count });
      } else
        this.runCallback(args.callback, scope, mxobjs, { count });
    }, args.error) : id ? this.runCallback(args.callback, scope, null, { count: 0 }) : this.runCallback(args.callback, scope, [], { count: 0 });
  }
  async getByGuids(ids, filter) {
    return ids.every((guid) => this.objectCache.has(guid)) ? Promise.resolve(this.getFromCache(ids, filter)) : (async (guids) => {
      const [offlineGuids, onlineGuids] = partition(isObjectOffline, guids);
      return (await Promise.all([offlineGuids.length > 0 ? this.offlineDataBackend.getByGuid(offlineGuids, filter) : Promise.resolve(emptyResult), onlineGuids.length > 0 ? this.onlineDataBackend.getByGuid(onlineGuids, filter) : Promise.resolve(emptyResult)])).reduce((acc, result) => ({ mxobjs: [...acc.mxobjs, ...result.mxobjs], count: acc.count + result.count }), emptyResult);
    })(ids);
  }
  getByEntity(args, scope) {
    const entity = args.entity, filter = args.filter ?? {};
    isOffline(entity) ? offlineData().retrieveUncached(entity, void 0, filter).then(({ mxObjects, count }) => {
      this.runCallback(args.callback, scope, mxObjects, { count });
    }, args.error) : this.onlineDataBackend.getByXPath(`//${entity}`, filter, args.count).then(({ mxobjs, count, hasMoreItems }) => {
      this.runCallback(args.callback, scope, mxobjs, { count, hasMoreItems });
    }, args.error);
  }
  getByXPath(args, scope) {
    this.onlineDataBackend.getByXPath(args.xpath, args.filter, args.count).then(({ mxobjs, count, hasMoreItems, aggregates }) => {
      this.runCallback(args.callback, scope, mxobjs, { count, hasMoreItems, aggregates });
    }, args.error);
  }
  getOffline(entity, constraints, filter, callback, error) {
    const fixedFilter = { offset: filter.offset, sort: filter.sort, amount: filter.limit };
    offlineData().retrieveUncached(entity, legacyConstraintsToQueryFilter(entity, constraints), fixedFilter).then(({ mxObjects, count }) => {
      this.runCallback(callback, null, mxObjects, count);
    }).catch(this.createErrorHandler(error, null));
  }
  create(args, scope = null) {
    if (restrictInStrictMode("mx.data.create"), "function" != typeof args.callback)
      throw new AssertionError("callback is not a function");
    if (args.error && "function" != typeof args.error)
      throw new AssertionError("error is not a function");
    if ("string" != typeof args.entity)
      throw new AssertionError("entity is not a string");
    (isOffline(args.entity) ? offlineData().create(args.entity) : this.onlineDataBackend.create(args.entity)).then(function(mxObj) {
      args.context && self.setObjectToContext(mxObj, args.context);
      self.runCallback(args.callback, scope, mxObj);
    }, this.createErrorHandler(args.error, scope));
    const self = this;
  }
  remove(args) {
    restrictInStrictMode("mx.data.remove");
    const guids = Data.extractGuids(args);
    if ("guids" in args && !Array.isArray(args.guids))
      throw new AssertionError("parameter guids set but not of type Array");
    if (args.error && "function" != typeof args.error)
      throw new AssertionError("parameter error set but not of type Function");
    if (args.callback && "function" != typeof args.callback)
      throw new AssertionError("parameter callback set but not of type Function");
    const errorHandler = this.createErrorHandler(args.error, null), [offlineGuids, onlineGuids] = partition(isObjectOffline, guids);
    (onlineGuids.length > 0 ? this.onlineDataBackend.remove(onlineGuids) : CommitRollbackResultHelper.emptyResolved).then(() => {
      (offlineGuids.length > 0 ? this.offlineDataBackend.remove(offlineGuids) : CommitRollbackResultHelper.emptyResolved).then(() => this.runCallback(args.callback), errorHandler);
    }, errorHandler);
  }
  validate(mxobjs, callback, error) {
    if (0 === mxobjs.length)
      return void this.runCallback(callback);
    const onlineGuids = mxobjs.map((mxObj) => mxObj.getGuid()).filter((guid) => !isObjectOffline(guid)), result = onlineGuids.length > 0 ? this.onlineDataBackend.validate(onlineGuids) : Promise.resolve({}), errorHandler = this.createErrorHandler(error, null);
    result.then(() => this.runCallback(callback, errorHandler), errorHandler);
  }
  commit(args, scope) {
    restrictInStrictMode("mx.data.commit");
    const successHandler = () => this.runCallback(args.callback, scope), errorHandler = this.createErrorHandler(args.error, scope), mxobjs = this.normalizeArguments(args);
    if (0 === mxobjs.length)
      return void successHandler();
    const context = args.context ?? new MxContext(), guids = mxobjs.map((mxobj) => mxobj.getGuid()), [offlineGuids, onlineGuids] = partition(isObjectOffline, guids);
    (onlineGuids.length > 0 ? this.onlineDataBackend.commit(onlineGuids, context, args.store, args.onValidation) : CommitRollbackResultHelper.emptyResolved).then((onlineResults) => {
      (offlineGuids.length > 0 ? this.offlineDataBackend.commit(offlineGuids, context) : CommitRollbackResultHelper.emptyResolved).then((offlineResults) => function(results) {
        const result = results.reduce(CommitRollbackResultHelper.combine, CommitRollbackResultHelper.empty);
        handleUncachedObjects(self.objectCache, mxobjs, result);
        const entityUpdates = unique(mxobjs.filter((mxObj) => self.objectCache.has(mxObj.getGuid()))).map((mxObj) => ({ entity: mxObj.getEntity() })), objectUpdates = unique(mxobjs.map((mxObj) => mxObj.getGuid())).map((guid) => ({ guid })), updates = entityUpdates.concat(objectUpdates);
        publish(...updates).then(successHandler, errorHandler);
      }([onlineResults, offlineResults]), errorHandler);
    }, errorHandler);
    const self = this;
  }
  rollback(args, scope) {
    restrictInStrictMode("mx.data.rollback");
    const errorHandler = this.createErrorHandler(args.error, scope), callingMxObjs = this.normalizeArguments(args);
    if (0 === callingMxObjs.length)
      return void this.runCallback(args.callback, scope);
    const entityUpdates = unique(callingMxObjs.map((mxObj) => mxObj.getEntity())).map((entity) => ({ entity })), guids = callingMxObjs.map((mxobj) => mxobj.getGuid()), [offlineGuids, onlineGuids] = partition(isObjectOffline, guids);
    (onlineGuids.length > 0 ? this.onlineDataBackend.rollback(onlineGuids) : CommitRollbackResultHelper.emptyResolved).then((onlineResults) => {
      (offlineGuids.length > 0 ? this.offlineDataBackend.rollback(offlineGuids) : CommitRollbackResultHelper.emptyResolved).then((offlineResults) => function(results) {
        const result = results.reduce(CommitRollbackResultHelper.combine, CommitRollbackResultHelper.empty);
        handleUncachedObjects(self.objectCache, callingMxObjs, result);
        const objectUpdates = unique(callingMxObjs.filter((mxObj) => self.objectCache.has(mxObj.getGuid()))).map((mxObj) => ({ guid: mxObj.getGuid() })), updates = entityUpdates.concat(objectUpdates);
        publish(...updates).then(() => self.runCallback(args.callback, scope), errorHandler);
      }([onlineResults, offlineResults]), errorHandler);
    }, errorHandler);
    const self = this;
  }
  async synchronizeOffline({ fullReset, incompatibleEntities } = { fullReset: false }) {
    isOffline() && await offlineData().runFullSynchronization(fullReset, incompatibleEntities);
  }
  saveDocument(guid, fileName, params, blob, callback, error) {
    const errorHandler = this.createErrorHandler(error, null);
    (isObjectOffline(guid) ? this.offlineDataBackend.saveDocument(guid, fileName, params, blob) : this.onlineDataBackend.saveDocument(guid, fileName, params, blob)).then(function() {
      publish({ guid }).then(callback, errorHandler);
    }, errorHandler);
  }
  setObjectToContext(mxObj, context) {
    if ("object" != typeof mxObj)
      throw new AssertionError("parameter mxObj is not of type Object");
    if ("object" != typeof context)
      throw new AssertionError("parameter context is not of type Object");
    const eAttrs = mxObj.getAttributes();
    for (const eAttr of eAttrs)
      if (mxObj.isReference(eAttr)) {
        const entity = mxObj.getSelectorEntity(eAttr);
        if (!entity)
          throw new AssertionError("selectorEntity did not return an entity");
        if (isSystemAttribute(eAttr))
          continue;
        context.hasContext(entity) && mxObj.addReference(eAttr, context.getContext(entity));
        const subtypees = getEntityMeta(entity)?.specializations ?? [];
        for (const item of subtypees)
          context.hasContext(item) && mxObj.addReference(eAttr, context.getContext(item));
      }
  }
  getObjectFromContext(context, callback) {
    const trackObj = context.getObject(), trackId = context.getTrackId();
    trackObj ? callback(trackObj) : trackId ? this.get({ guid: trackId, callback(obj) {
      obj || handleError("Error while fetching object with guid " + trackId), callback(obj);
    }, error(e) {
      handleError(e), callback(null);
    } }, this) : callback(null);
  }
  isNew(guid) {
    return this.objectCache.isNew(guid);
  }
  makeChange(guid, attr, rawValue) {
    this.objectCache.makeChange(guid, attr, rawValue);
  }
  getChanges(guid) {
    return this.objectCache.getChanges(guid);
  }
  getCachedObject(guid) {
    return this.objectCache.getObject(guid);
  }
  dehydrateCache() {
    return { objectCache: this.objectCache.dehydrate(), objectIdCache: dehydrateObjectIdCache() };
  }
  hydrateCache(state) {
    this.objectCache.hydrate(state.objectCache), hydrateObjectIdCache(state.objectIdCache);
  }
  getDocumentUrl(guid, changedDate, isThumb, fileName) {
    return isObjectOffline(guid) ? this.offlineDataBackend.getDocumentUrl(guid, changedDate, isThumb, fileName) : this.onlineDataBackend.getDocumentUrl(guid, changedDate, isThumb, fileName);
  }
  getImageUrl(url, callback, error) {
    this.onlineDataBackend.getImageUrl(url).then(callback, error);
  }
  clear(callback) {
    this.objectCache.clear();
    (isOffline() ? Promise.all([this.offlineDataBackend.cleanup(), this.onlineDataBackend.cleanup()]) : this.onlineDataBackend.cleanup()).then(callback, handleError);
  }
  uninitialize() {
    this.garbageCollector.finalize();
  }
  getObjectsStatistics() {
    return this.objectCache.getAllGuids().map((guid) => {
      const obj = this.objectCache.getObject(guid);
      return { guid, object: obj, changes: clone(this.objectCache.getChanges(guid)), uncommitted: this.objectCache.isNew(guid), subscriptions: getTags(guid).concat(this.validationSubscriptions.filter((v) => "guid" in v && v.guid === guid).map((v) => v.tag)), locks: this.lockManager.getLockCount(guid) };
    });
  }
  createErrorHandler(errorCallback, scope) {
    return (error) => this.runErrorHandler(errorCallback, scope, error);
  }
  runErrorHandler(errorCallback, scope, error) {
    errorCallback ? errorCallback.call(scope, error) : handleError(error);
  }
  runCallback(callback, scope, ...args) {
    try {
      callback && callback.apply(scope, args);
    } catch (e) {
      handleError(e);
    }
  }
  normalizeArguments(args) {
    if ("object" != typeof args)
      throw new AssertionError("args is not an object");
    if ("function" != typeof args.callback)
      throw new AssertionError("callback is not a function");
    if (args.mxobj && !(args.mxobj instanceof MxObject))
      throw new AssertionError("mxobj is not a MxObject");
    if (args.mxobjs && !Array.isArray(args.mxobjs))
      throw new AssertionError("mxobjs is not an Array");
    if (!args.mxobj && !args.mxobjs || args.mxobj && args.mxobjs)
      throw new AssertionError("one of mxobj or mxobjs should be passed");
    return args.mxobj ? [args.mxobj] : args.mxobjs;
  }
  mixinParams(target, source, map) {
    if (!source)
      return target;
    for (const i in map)
      i in source && null != source[i] && (target[i] = source[i]);
    return target;
  }
  getFromCache(guids, filter = {}) {
    let objs = guids.map((guid) => this.objectCache.getObject(guid)).filter((mxobj) => null != mxobj);
    filter.sort && filter.sort.forEach((sort) => {
      const attr = sort[0], dir = sort[1];
      objs = objs.sort((a, b) => {
        const aValue = a.get(attr), bValue = b.get(attr);
        return aValue < bValue ? "asc" === dir ? -1 : 1 : aValue > bValue ? "asc" === dir ? 1 : -1 : 0;
      });
    });
    const offset = filter.offset;
    if (offset) {
      const limit = filter.amount;
      objs = limit ? objs.slice(offset, offset + limit) : objs.slice(offset);
    }
    return { mxobjs: objs, count: objs.length };
  }
  runMapPath(mxobj, path, callback, error) {
    const split = path.split("/"), self = this, fetchDeepRefs = function(objs) {
      let entity = split.shift(), ref = split.shift();
      if (null == objs || 0 === objs.length)
        return void callback(null);
      const carr = [];
      for (const item of objs)
        null != item && carr.push("id='" + item.getGuid() + "'");
      if (!carr.length)
        return void callback(null);
      const constraints = `[${ref}/${entity}[${carr.join(" or ")}]]`;
      1 === split.length ? callback(constraints) : (entity = split.shift(), ref = split.shift(), callback(`[${ref}/${entity}${constraints}]`));
    };
    !function() {
      const entity = split.shift(), ref = split.shift();
      if (1 === split.length) {
        const constraint = `[${ref}='${mxobj.getGuid()}']`;
        return void callback(constraint);
      }
      const meta = getEntityMeta(entity);
      null != meta ? mxobj.isA(entity) ? isReferenceAttribute(meta, ref) ? "" !== mxobj.get(ref) ? self.get({ guids: mxobj.getReferences(ref), callback: fetchDeepRefs, error }) : callback(null) : self.runErrorHandler(error, null, new Error(`Reference ${ref} not found in entity ${entity}`)) : self.runErrorHandler(error, null, new AssertionError(`Entity ${mxobj.getEntity()} is not a ${entity} or one of its subclasses`)) : self.runErrorHandler(error, null, new Error(`Entity ${entity} does not exist`));
    }();
  }
  static extractGuids(args) {
    return !("guids" in args) && "guid" in args && args.guid ? [args.guid] : "guids" in args ? "" === args.guids ? [] : args.guids : void 0;
  }
}
const CommitRollbackResultHelper = function() {
  const empty = {};
  return { empty, emptyResolved: Promise.resolve(empty), combine: (r1, r2) => ({ commits: [...r1.commits ?? [], ...r2.commits ?? []], deletes: [...r1.deletes ?? [], ...r2.deletes ?? []] }) };
}();
class DBModelSyncInstructionBase {
  supported() {
    return false;
  }
  async runTransaction(_) {
    throw new AssertionError("Unsupported instruction has no transaction");
  }
  getDescription() {
    throw new AssertionError("Unsupported instruction has no description");
  }
  async postMigrate() {
    return Promise.resolve();
  }
}
class DBModelSyncRenameEntity extends DBModelSyncInstructionBase {
}
class DBModelSyncCreateEntity extends DBModelSyncInstructionBase {
}
class DBModelSyncRenameAttributes extends DBModelSyncInstructionBase {
}
class DBModelSyncChangeAttributesTypes extends DBModelSyncInstructionBase {
}
class DBModelSyncAddAttributes extends DBModelSyncInstructionBase {
}
class DBModelSyncDropEntity extends DBModelSyncInstructionBase {
  constructor(entity, fileType) {
    super(), this.entity = entity, this.fileType = fileType, this.filesToDelete = [];
  }
  supported() {
    return true;
  }
  getDescription() {
    return `Drop table '${this.entity}'.`;
  }
  async runTransaction(tx) {
    if ("none" !== this.fileType) {
      (await tx.retrieveGuidsAndChangeDatesForFileObjects(this.entity)).forEach(({ guid, changedDate }) => {
        const fileInfo = { guid, changedDate, isThumb: false };
        this.filesToDelete.push(fileInfo), "image" === this.fileType && this.filesToDelete.push({ ...fileInfo, isThumb: true });
      });
    }
    await tx.dropEntityTables([this.entity]);
  }
  async postMigrate() {
    offlineData().deleteFiles(this.filesToDelete);
  }
}
class DBModelSyncDropAttributes extends DBModelSyncInstructionBase {
  constructor(entity, droppedAttributes) {
    super(), this.entity = entity, this.droppedAttributes = droppedAttributes;
  }
  supported() {
    return true;
  }
  getDescription() {
    return `Drop columns (${this.droppedAttributes.join(", ")}) from '${this.entity}'.`;
  }
  async runTransaction(tx) {
    await tx.changeEntityTable(this.entity, [], this.droppedAttributes);
  }
}
class DBModelSyncIndexBase extends DBModelSyncInstructionBase {
  constructor(action2, entity, index) {
    super(), this.action = action2, this.entity = entity, this.index = index;
  }
  supported() {
    return true;
  }
  getDescription() {
    return `${this.action} index (${this.index.attributes.map((a) => `${a.name}_${a.direction}`)}) from '${this.entity}'`;
  }
}
class DBModelSyncAddIndex extends DBModelSyncIndexBase {
  constructor(entity, index) {
    super("Add", entity, index);
  }
  async runTransaction(tx) {
    await tx.createIndex(this.entity, this.index);
  }
}
class DBModelSyncDropIndex extends DBModelSyncIndexBase {
  constructor(entity, index) {
    super("Drop", entity, index);
  }
  async runTransaction(tx) {
    await tx.dropIndex(this.entity, this.index);
  }
}
function getDBModelSyncInstructions(oldMetadata, newMetadata) {
  const indexByModelId = indexByKey((item) => ensure(item.modelId)), oldMetadataIndexedByModelId = indexByModelId(oldMetadata), newMetadataIndexedByModelId = indexByModelId(newMetadata), { droppedMetadata, addedMetadata, comparableMetadata } = function(oldMetadata2, newMetadata2) {
    const oldAndNewUniqueEntityModelIds = /* @__PURE__ */ new Set([...Object.keys(oldMetadata2), ...Object.keys(newMetadata2)]);
    return Array.from(oldAndNewUniqueEntityModelIds).reduce((res, modelId) => (oldMetadata2[modelId] && newMetadata2[modelId] ? res.comparableMetadata.set(modelId, { oldMetadata: oldMetadata2[modelId], newMetadata: newMetadata2[modelId] }) : oldMetadata2[modelId] && !newMetadata2[modelId] ? res.droppedMetadata.push(oldMetadata2[modelId]) : !oldMetadata2[modelId] && newMetadata2[modelId] && res.addedMetadata.push(newMetadata2[modelId]), res), { comparableMetadata: /* @__PURE__ */ new Map(), droppedMetadata: [], addedMetadata: [] });
  }(oldMetadataIndexedByModelId, newMetadataIndexedByModelId), result = [], addedEntities = addedMetadata.map((meta) => meta.objectType);
  0 !== droppedMetadata.length && result.push(...droppedMetadata.map((meta) => new DBModelSyncDropEntity(meta.objectType, getEntityFileType(meta)))), 0 !== addedEntities.length && result.push(...addedEntities.map((_e) => new DBModelSyncCreateEntity()));
  const entitiesChangesResult = function(entityOldNewMetadataMap) {
    const result2 = [];
    for (const [, { oldMetadata: oldMetadata2, newMetadata: newMetadata2 }] of entityOldNewMetadataMap)
      oldMetadata2.objectType !== newMetadata2.objectType && result2.push(new DBModelSyncRenameEntity()), result2.push(...compareAttributeChanges(oldMetadata2.objectType, oldMetadata2.attributes, newMetadata2.attributes)), result2.push(...compareIndexChanges(oldMetadata2.objectType, oldMetadata2.indices, newMetadata2.indices));
    return result2;
  }(comparableMetadata);
  return result.push(...entitiesChangesResult), result;
}
function getEntityFileType(entityMeta) {
  return isFileDocumentType(entityMeta) ? function(entityMeta2) {
    return isFileDocumentType(entityMeta2) && ("System.Image" === entityMeta2.objectType || entityMeta2.properties.superclasses.includes("System.Image"));
  }(entityMeta) ? "image" : "file" : "none";
}
function compareAttributeChanges(oldEntityName, oldAttributesMetadata, newAttributesMetadata) {
  const indexByModelId = indexByKey(([, attrMeta]) => ensure(attrMeta.modelId)), oldAttributesMetadataIndexedByModelId = indexByModelId(Object.entries(oldAttributesMetadata)), newAttributesMetadataIndexedByModelId = indexByModelId(Object.entries(newAttributesMetadata)), oldAndNewUniqueAttributeModelIds = /* @__PURE__ */ new Set([...Object.keys(oldAttributesMetadataIndexedByModelId), ...Object.keys(newAttributesMetadataIndexedByModelId)]), result = [], { droppedAttributes, renamedAttributes, typeChangeAttributes, addedAttributes } = Array.from(oldAndNewUniqueAttributeModelIds).reduce((changes, modelId) => (oldAttributesMetadataIndexedByModelId[modelId] && newAttributesMetadataIndexedByModelId[modelId] ? (oldAttributesMetadataIndexedByModelId[modelId][0] !== newAttributesMetadataIndexedByModelId[modelId][0] && changes.renamedAttributes.push([oldAttributesMetadataIndexedByModelId[modelId][0], newAttributesMetadataIndexedByModelId[modelId][0]]), oldAttributesMetadataIndexedByModelId[modelId][1].type !== newAttributesMetadataIndexedByModelId[modelId][1].type && changes.typeChangeAttributes.push([oldAttributesMetadataIndexedByModelId[modelId][0], oldAttributesMetadataIndexedByModelId[modelId][1].type, newAttributesMetadataIndexedByModelId[modelId][1].type])) : oldAttributesMetadataIndexedByModelId[modelId] && !newAttributesMetadataIndexedByModelId[modelId] ? changes.droppedAttributes.push(oldAttributesMetadataIndexedByModelId[modelId][0]) : !oldAttributesMetadataIndexedByModelId[modelId] && newAttributesMetadataIndexedByModelId[modelId] && changes.addedAttributes.push([newAttributesMetadataIndexedByModelId[modelId][0], newAttributesMetadataIndexedByModelId[modelId][1].type]), changes), { droppedAttributes: [], addedAttributes: [], renamedAttributes: [], typeChangeAttributes: [] });
  return 0 !== droppedAttributes.length && result.push(new DBModelSyncDropAttributes(oldEntityName, droppedAttributes)), 0 !== renamedAttributes.length && result.push(new DBModelSyncRenameAttributes()), 0 !== typeChangeAttributes.length && result.push(new DBModelSyncChangeAttributesTypes()), 0 !== addedAttributes.length && result.push(new DBModelSyncAddAttributes()), result;
}
function compareIndexChanges(objectType, oldIndices, newIndices) {
  const indexByDescription = indexByKey((index) => index.attributes.map((a) => `${a.name}_${a.direction}`).join("-")), oldIndicesByDescription = indexByDescription(oldIndices), newIndicesByDescription = indexByDescription(newIndices), removedDescriptions = Object.keys(oldIndicesByDescription).filter((desc) => !newIndicesByDescription[desc]), addedDescriptions = Object.keys(newIndicesByDescription).filter((desc) => !oldIndicesByDescription[desc]);
  return [...removedDescriptions.map((desc) => oldIndicesByDescription[desc]).map((index) => new DBModelSyncDropIndex(objectType, index)), ...addedDescriptions.map((desc) => newIndicesByDescription[desc]).map((index) => new DBModelSyncAddIndex(objectType, index))];
}
function isFileDocumentType(entityMeta) {
  return "System.FileDocument" === entityMeta.objectType || entityMeta.properties.superclasses.includes("System.FileDocument");
}
function shouldTriggerFullSyncOrDatabaseUpdate(oldOfflineSessionMetadata, newOfflineSessionMetadata) {
  const newSyncConfig = newOfflineSessionMetadata.sync_config;
  if (!newSyncConfig)
    return { shouldSync: false };
  if (!oldOfflineSessionMetadata)
    return { shouldSync: true };
  if (oldOfflineSessionMetadata.bundleVersion === newOfflineSessionMetadata.bundleVersion)
    return { shouldSync: false };
  const oldSyncConfig = oldOfflineSessionMetadata.sync_config, oldOfflineEntities = new Set(ensure(oldSyncConfig?.schema)), oldOfflineMetadata = oldOfflineSessionMetadata.metadata.filter(({ objectType }) => oldOfflineEntities.has(objectType)), newOfflineEntities = new Set(ensure(newSyncConfig.schema)), newOfflineMetadata = newOfflineSessionMetadata.metadata.filter(({ objectType }) => newOfflineEntities.has(objectType));
  if (![...oldOfflineMetadata, ...newOfflineMetadata].every((entityMeta) => void 0 !== entityMeta.modelId && Object.values(entityMeta.attributes).every((attrMeta) => void 0 !== attrMeta.modelId))) {
    const isEqual = comparer.structural;
    return isEqual(oldSyncConfig, newSyncConfig) ? { shouldSync: !newSyncConfig.schema.map((entity) => ({ oldAttrs: oldOfflineSessionMetadata.metadata.find((e) => e.objectType === entity).attributes, newAttrs: newOfflineSessionMetadata.metadata.find((e) => e.objectType === entity).attributes })).every(({ oldAttrs, newAttrs }) => isEqual(oldAttrs, newAttrs)) } : { shouldSync: true };
  }
  const entitiesWithChangedSyncModeToOnline = function(oldOfflineMetadata2, oldSyncConfig2, newOfflineMetadata2, newSyncConfig2) {
    if (!oldSyncConfig2.online)
      return [];
    const newEntitiesWithOnlineSyncMode = new Set(ensure(newSyncConfig2.online)), newEntitiesModelIdsWithOnlineSyncMode = newOfflineMetadata2.reduce((res, { objectType, modelId }) => (newEntitiesWithOnlineSyncMode.has(objectType) && res.add(ensure(modelId)), res), /* @__PURE__ */ new Set()), oldEntitiesWithOnlineSyncMode = new Set(oldSyncConfig2.online), [oldEntitiesModelIdsMap, oldEntitiesModelIdsWithOnlineSyncModeMap] = oldOfflineMetadata2.reduce(([resOldEntitiesModelIds, resOldEntitiesModelIdsWithOnlineSyncMode], { objectType, modelId }) => (resOldEntitiesModelIds.set(ensure(modelId), objectType), oldEntitiesWithOnlineSyncMode.has(objectType) && resOldEntitiesModelIdsWithOnlineSyncMode.set(ensure(modelId), objectType), [resOldEntitiesModelIds, resOldEntitiesModelIdsWithOnlineSyncMode]), [/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]), result = [];
    for (const newModelId of newEntitiesModelIdsWithOnlineSyncMode)
      oldEntitiesModelIdsMap.has(newModelId) && (oldEntitiesModelIdsWithOnlineSyncModeMap.has(newModelId) || result.push(ensure(oldEntitiesModelIdsMap.get(newModelId))));
    return result;
  }(oldOfflineMetadata, ensure(oldSyncConfig), newOfflineMetadata, ensure(newSyncConfig)), oldMetadataIndexedByObjectType = indexByKey((item) => ensure(item.objectType))(oldOfflineMetadata);
  if (entitiesWithChangedSyncModeToOnline.length > 0)
    return { shouldSync: true, cleanupInstructions: entitiesWithChangedSyncModeToOnline.map((e) => new DBModelSyncDropEntity(e, getEntityFileType(ensure(oldMetadataIndexedByObjectType[e])))) };
  const dbModelSyncInstructions = getDBModelSyncInstructions(oldOfflineMetadata, newOfflineMetadata);
  return 0 === dbModelSyncInstructions.length ? { shouldSync: false } : dbModelSyncInstructions.every((instruction) => instruction.supported()) ? { shouldSync: false, dbModelSyncInstructions } : { shouldSync: true };
}
async function handleOfflineStartup(dbModelCheckResult, cachedOfflineMetadata, dbOfflineMetadata, startupLogger) {
  if (dbModelCheckResult.shouldSync)
    await startupFullSynchronization(), dbModelCheckResult.cleanupInstructions && await offlineData().executeDBModelSyncInstructions(dbModelCheckResult.cleanupInstructions, cachedOfflineMetadata);
  else if (dbModelCheckResult.dbModelSyncInstructions) {
    const isPlural = dbModelCheckResult.dbModelSyncInstructions.length > 1;
    startupLogger.info(`Found ${dbModelCheckResult.dbModelSyncInstructions.length} instruction${isPlural ? "s" : ""} to update the local database to match the new domain model.`);
    try {
      const stopwatch = new Stopwatch();
      startupLogger.info("Updating the local database to match the new domain model."), await offlineData().executeDBModelSyncInstructions(dbModelCheckResult.dbModelSyncInstructions, cachedOfflineMetadata);
      const dbMigrateDuration = stopwatch.measure();
      startupLogger.info(`Updating the local database to match the new domain model completed in ${dbMigrateDuration} milliseconds.`);
    } catch (e) {
      startupLogger.warn("An error occurred while updating the local database schema. Falling back to a full startup synchronization.", e), await startupFullSynchronization();
    }
  }
  async function startupFullSynchronization() {
    const stopwatch = new Stopwatch(), incompatibleEntities = getIncompatibleEntities(dbOfflineMetadata, cachedOfflineMetadata);
    await offlineData().runFullSynchronization(true, incompatibleEntities);
    const syncDuration = stopwatch.measure();
    startupLogger.log(syncDuration.ms > SYNC_DURATION_WARNING_THRESHOLD ? "warning" : "info", `Startup synchronization completed in ${syncDuration} milliseconds.`);
  }
}
function callbackToPromiseFactory(callbackFunction, scope = null) {
  return function(...args) {
    return function(callbackFunction2, ...args2) {
      return new Promise((resolve, reject) => {
        const argsWithCallbacks = args2.concat([resolve, reject]);
        callbackFunction2(...argsWithCallbacks);
      });
    }(callbackFunction.bind(scope), ...args);
  };
}
class OnlineDataBackend extends _DataBackend {
  constructor(objectCache, lockManager, config) {
    super(), this._getImageUri = config && config.getImgUriFn ? callbackToPromiseFactory(config.getImgUriFn) : getDefaultImgUri, this._objectCache = objectCache, this._lockManager = lockManager;
  }
  async getByGuid(guids, filter = {}) {
    const json = await memoizeConcurrent({ guids, filter }, () => retrieveByIds(guids, filter)), releaseResponseObjects = await handleRuntimeSuccess(this._objectCache, this._lockManager, json);
    try {
      let mxobjs;
      if (json.resultGuids)
        mxobjs = json.resultGuids.map((guid) => this._objectCache.getObject(guid));
      else {
        const jsonObjs = json.mxobjects || [];
        jsonObjs.map((jsonObj) => jsonObj.guid).forEach((guid) => removeObjectKeepChanges(this._lockManager, this._objectCache, guid)), mxobjs = jsonObjs.map(MxObject.fromJson);
      }
      return { mxobjs, count: mxobjs.length };
    } finally {
      releaseResponseObjects();
    }
  }
  async getByPath(guid, path, entity, direction) {
    const [changes, objects] = getRequestDataForGuidsReachableFrom(this._objectCache, [guid]), json = await memoizeConcurrent({ guid, path, entity }, () => retrieveByPath$1(guid, path, entity, direction, changes, objects)), releaseResponseObjects = await handleRuntimeSuccess(this._objectCache, this._lockManager, json);
    try {
      const guids = json.resultGuids || [];
      return { mxobjs: guids.map((g) => this._objectCache.getObject(g)), count: guids.length };
    } finally {
      releaseResponseObjects();
    }
  }
  async getByXPath(xpath, filter, wantCount) {
    const json = await memoizeConcurrent({ xpath, filter, wantCount }, () => retrieveByXPath$1(xpath, filter, wantCount)), releaseResponseObjects = await handleRuntimeSuccess(this._objectCache, this._lockManager, json);
    try {
      const count = json.count || 0, aggregates = json.aggregates || [], hasMoreItems = json.hasMoreItems;
      let mxobjs;
      if (Array.isArray(json.resultGuids))
        mxobjs = json.resultGuids.map((guid) => this._objectCache.getObject(guid));
      else {
        const jsonObjs = json.mxobjects || [];
        jsonObjs.map((jsonObj) => jsonObj.guid).forEach((guid) => removeObjectKeepChanges(this._lockManager, this._objectCache, guid)), mxobjs = jsonObjs.map(MxObject.fromJson);
      }
      return { mxobjs, count, hasMoreItems, aggregates: aggregates.map(function(agg) {
        return null == agg ? "" : new Big(agg);
      }) };
    } finally {
      releaseResponseObjects();
    }
  }
  async action(params, context, targetForm, async, onValidation) {
    const mfName = params && params.actionname ? params.actionname : null, microflowInfo = getMicroflowInfo(mfName);
    let contextGuids = params && params.guids ? params.guids : [];
    null != context && (contextGuids = contextGuids.concat(null != microflowInfo ? microflowInfo.parameters.map((entity) => context.getContext(entity)).filter((entity) => null != entity) : context.getGuids()));
    const [changes, objects] = getRequestDataForMicroflow(this._objectCache, void 0, contextGuids.concat(getImplicitMicroflowParameters()));
    let json;
    try {
      json = async ? await executeAsync((asyncId) => executeAction(params, context, changes, objects, asyncId)) : await executeAction(params, context, changes, objects);
    } catch (e) {
      throw await handleRuntimeError(this._objectCache, e, onValidation), e;
    }
    const releaseResponseObjects = await handleRuntimeSuccess(this._objectCache, this._lockManager, json, { targetForm });
    try {
      return json.actionResult && Array.isArray(json.actionResult.resultGuids) ? json.actionResult.resultGuids.map((guid) => this._objectCache.getObject(guid)) : json.actionResult;
    } finally {
      releaseResponseObjects();
    }
  }
  async create(entity) {
    const [changes, objects] = getEntityMeta(entity)?.needsReachableState.create ? getRequestDataForGuidsReachableFrom(this._objectCache, []) : getRequestData(this._objectCache, []);
    let json;
    try {
      json = await instantiate(entity, changes, objects);
    } catch (e) {
      throw await handleRuntimeError(this._objectCache, e), e;
    }
    const releaseResponseObjects = await handleRuntimeSuccess(this._objectCache, this._lockManager, json);
    try {
      return this._objectCache.getObject(json.actionResult);
    } finally {
      releaseResponseObjects();
    }
  }
  async commit(guids, context, targetForm, onValidation) {
    const [changes, objects] = getRequestDataForObjectAction(this._objectCache, guids, "commit");
    let json;
    try {
      json = await commit$1(guids, context, changes, objects);
    } catch (e) {
      throw await handleRuntimeError(this._objectCache, e, onValidation), e;
    }
    return await handleRuntimeSuccess(this._objectCache, this._lockManager, json, { targetForm, autoRelease: true }), json;
  }
  async rollback(guids) {
    const [changes, objects] = getRequestDataForObjectAction(this._objectCache, guids, "rollback");
    let json;
    try {
      json = await rollback$1(guids, changes, objects);
    } catch (e) {
      throw await handleRuntimeError(this._objectCache, e), e;
    }
    return await handleRuntimeSuccess(this._objectCache, this._lockManager, json, { autoRelease: true }), json;
  }
  async remove(guids) {
    const [changes, objects] = getRequestDataForObjectAction(this._objectCache, guids, "delete");
    let json;
    try {
      json = await _delete(guids, changes, objects);
    } catch (e) {
      throw await handleRuntimeError(this._objectCache, e), e;
    }
    return await handleRuntimeSuccess(this._objectCache, this._lockManager, json, { autoRelease: true }), json;
  }
  async validate(guids) {
    const [changes, objects] = getRequestData(this._objectCache, guids);
    try {
      return await validate$1(changes, objects);
    } catch (e) {
      throw await handleRuntimeError(this._objectCache, e), e;
    }
  }
  async saveDocument(guid, name, params, blob) {
    const [changes, objects] = getRequestDataForObjectAction(this._objectCache, [guid], "commit");
    let json;
    try {
      json = await upload(guid, name, params, blob, changes, objects);
    } catch (e) {
      throw await handleRuntimeError(this._objectCache, e), e;
    }
    return await handleRuntimeSuccess(this._objectCache, this._lockManager, json, { autoRelease: true }), json;
  }
  getDocumentUrl(guid, changedDate, isThumb, fileName) {
    return getRemoteDynamicResourceUrl(guid, changedDate, isThumb, fileName);
  }
  getImageUrl(url) {
    return this._getImageUri(url);
  }
  cleanup() {
    return Promise.resolve();
  }
}
function getDefaultImgUri(url) {
  return Promise.resolve(url);
}
class RuntimeSocketConnection {
  constructor(url) {
    this.url = url, this.connectHandlers = [], this.instructionHandlers = [], window.setInterval(() => {
      this.send(JSON.stringify({ type: "ping" }));
    }, 1e4);
  }
  isConnected() {
    return void 0 !== this.socket && this.socket.readyState === WebSocket.OPEN;
  }
  onConnect(handler) {
    this.isConnected() ? handler() : this.connectHandlers.push(handler);
  }
  onInstruction(type, handler) {
    this.instructionHandlers.push({ type, handler });
  }
  sendLog(level, node, message) {
    if (this.isConnected()) {
      const maxSendLength = 6e4;
      for (let offset = 0; offset < message.length; offset += maxSendLength) {
        const messagePart = message.substr(offset, maxSendLength);
        this.send(JSON.stringify({ type: "log", node, data: `${level}:${messagePart}` }));
      }
    }
  }
  send(data) {
    this.isConnected() && ensure(this.socket).send(data);
  }
  connect() {
    try {
      this.socket = new WebSocket(this.url), this.socket.onopen = () => {
        this.connectHandlers.forEach((handler) => handler()), this.connectHandlers.splice(0);
      }, this.socket.onmessage = ({ data }) => {
        const instruction = JSON.parse(data);
        this.instructionHandlers.slice().filter(({ type }) => type === instruction.type).forEach(({ handler }) => handler(instruction));
      }, this.socket.onclose = () => this.reconnect();
    } catch {
      this.reconnect();
    }
  }
  reconnect() {
    this.socket = void 0, setTimeout(() => this.connect(), 1e3);
  }
}
class DevTools {
  constructor(remoteUrl, logManager = LogManager.get()) {
    this.reloadHandlers = [], this.updateStylingHandlers = [], this.deploymentId = void 0, this.connection = new RuntimeSocketConnection(remoteUrl.replace(/^http/, "ws") + "mxdevtools/"), this.connection.onInstruction("set_deployment_id", (instruction) => {
      void 0 !== this.deploymentId && instruction.deploymentId !== this.deploymentId && this.reloadHandlers.forEach((handler) => handler(false)), this.deploymentId = instruction.deploymentId;
    }), this.connection.onInstruction("reload", () => {
      this.reloadHandlers.forEach((handler) => handler(true));
    }), this.connection.onInstruction("update_styling", () => {
      this.updateStylingHandlers.forEach((handler) => handler());
    }), logManager.addHandler((level, node, ...args) => {
      this.log(level, node, ...args);
    }), initializeNanoflowDebugger(this.connection, logManager);
  }
  async connect() {
    this.connection.connect(), await waitForNFDebuggerBreakpoints();
  }
  addOnReload(handler) {
    this.reloadHandlers.push(handler);
  }
  addOnUpdateStyling(handler) {
    this.updateStylingHandlers.push(handler);
  }
  log(level, node, ...args) {
    const messages = args.map(convertLoggerArgument), sanitizedNode = "Client" === node ? node : `Client_${node}`;
    this.connection.onConnect(() => this.connection.sendLog(level, sanitizedNode, messages.join("\n")));
  }
}
class GarbageCollector {
  constructor(objectCache, session, objectLockManager, config = {}) {
    this.objectCache = objectCache, this.session = session, this.objectLockManager = objectLockManager, this.logger = LogManager.get().getLogger(), this.config = { interval: 1e4, logging: false, ...config };
  }
  initialize() {
    this.config.interval > 0 && (this.gcInterval = window.setInterval(() => this.collectGarbage(), this.config.interval));
  }
  finalize() {
    window.clearInterval(this.gcInterval);
  }
  collectGarbage() {
    const cachedObjects = this.objectCache.getAllObjects(), cachedGuidSet = new Set(cachedObjects.map((mxobj) => mxobj.getGuid())), userId = this.session.getUserId(), sessionId = this.session.getSessionObjectId(), lockedGuids = this.objectLockManager.getLockedGuids(), rootGuids = new Set(Array.from(lockedGuids).concat([userId, sessionId])), guidsToRetain = new Set(findReachableGuidsToRetain(cachedObjects, rootGuids)), collectableGuids = [...difference(cachedGuidSet, guidsToRetain)];
    if (this.config.logging) {
      const objectsStr = groupBy(collectableGuids, (guid) => this.objectCache.getObject(guid).getEntity()).map(({ key, values }) => `${key}: ${values.join(", ")}`).join("\n");
      this.logger.debug(`Garbage collecting ${collectableGuids.length} of ${cachedGuidSet.size}
${objectsStr}`);
    }
    this.objectCache.removeObjects(collectableGuids);
  }
}
class LoggableFileBackend {
  constructor(fileBackend, logManager) {
    this.fileBackend = fileBackend, this.logger = logManager.getLogger(LogNode.FileSystem).debounced;
  }
  async downloadFile(url, filePath) {
    this.logger.trace(`Download file from "${url}" to "${filePath}"`);
    const stopwatch = new Stopwatch();
    await this.fileBackend.downloadFile(url, filePath), this.logger.trace(`Download file from ${url} completed after ${stopwatch.measure()} milliseconds`);
  }
  async listDir(dirPath) {
    return this.fileBackend.listDir(dirPath);
  }
  async moveFile(filePath, newPath) {
    return this.logger.trace(`Move file from "${filePath}" to "${newPath}"`), this.fileBackend.moveFile(filePath, newPath);
  }
  async moveDir(dirPath, newPath) {
    return this.logger.trace(`Move dir from "${dirPath}" to "${newPath}"`), this.fileBackend.moveDir(dirPath, newPath);
  }
  async readFile(filePath) {
    return this.logger.trace(`Read file from "${filePath}"`), this.fileBackend.readFile(filePath);
  }
  async removeDir(dirPath) {
    return this.logger.trace(`Remove dir from "${dirPath}"`), this.fileBackend.removeDir(dirPath);
  }
  async removeFile(filePath) {
    return this.logger.trace(`Remove file from "${filePath}"`), this.fileBackend.removeFile(filePath);
  }
  async storeFile(contentBlob, filePath) {
    return this.logger.trace(`Store blob to file "${filePath}"`), this.fileBackend.storeFile(contentBlob, filePath);
  }
  toAbsolutePath(filePath) {
    return this.fileBackend.toAbsolutePath(filePath);
  }
  async getFileUrl(filePath) {
    return this.logger.trace(`Create URL for file "${filePath}"`), this.fileBackend.getFileUrl(filePath);
  }
}
class MxObjectCache {
  constructor() {
    this.objectCache = /* @__PURE__ */ new Map(), this.changes = /* @__PURE__ */ new Map(), this.newGuids = /* @__PURE__ */ new Set();
  }
  setMxObjects(jsons) {
    for (const json of jsons) {
      const guid = json.guid, cacheObj = this.objectCache.get(guid);
      cacheObj ? cacheObj.resetFromJSON(json) : this.objectCache.set(guid, MxObject.fromJson(json));
    }
  }
  getObject(guid) {
    return this.objectCache.get(guid) ?? null;
  }
  getAllObjects() {
    return Array.from(this.objectCache.values());
  }
  getAllGuids() {
    return unique(Array.from(this.objectCache.keys()).concat(Array.from(this.changes.keys())));
  }
  has(guid) {
    return this.objectCache.has(guid);
  }
  isNew(guid) {
    return this.has(guid) && this.newGuids.has(guid);
  }
  removeObject(guid) {
    this.objectCache.delete(guid), this.newGuids.delete(guid), this.changes.delete(guid);
  }
  removeObjectKeepChanges(guid) {
    this.objectCache.delete(guid), this.newGuids.delete(guid);
  }
  removeObjects(guids) {
    for (const guid of guids)
      this.removeObject(guid);
  }
  addChanges(changes) {
    for (const [guid, objChanges] of Object.entries(changes)) {
      const existingObjChanges = this.changes.get(guid) ?? {};
      for (const [attr, attrChange] of Object.entries(objChanges))
        "value" in attrChange ? existingObjChanges[attr] = attrChange : existingObjChanges[attr] && (existingObjChanges[attr].hash = attrChange.hash);
      this.changes.set(guid, existingObjChanges);
    }
  }
  getChanges(guid) {
    return this.changes.get(guid) ?? {};
  }
  hasChanges(guid) {
    return this.changes.has(guid);
  }
  removeChanges(resets) {
    for (const [guid, attributes] of Object.entries(resets)) {
      const changes = this.changes.get(guid);
      if (void 0 === changes)
        return;
      for (const attr of attributes)
        delete changes[attr];
      0 === Object.keys(changes).length && this.changes.delete(guid);
    }
  }
  removeAllChanges(guids) {
    for (const guid of guids)
      this.changes.delete(guid);
  }
  makeChange(guid, attr, value) {
    const currentChanges = this.changes.get(guid) ?? {};
    this.changes.set(guid, { ...currentChanges, [attr]: { value } });
  }
  dehydrate() {
    return { data: clone(this.getAllObjects().map((o) => o.toJSON())), newGuids: Array.from(this.newGuids), changes: clone(Object.fromEntries(this.changes)) };
  }
  hydrate({ data, newGuids, changes }) {
    this.clear();
    for (const objData of data) {
      const mxObject = MxObject.fromJson(clone(objData));
      this.objectCache.set(objData.guid, mxObject);
    }
    this.newGuids = new Set(newGuids);
    for (const [guid, change] of Object.entries(changes))
      this.changes.set(guid, clone(change));
  }
  clear() {
    this.objectCache.clear(), this.changes.clear(), this.newGuids.clear();
  }
  onCreate(guids) {
    for (const guid of guids)
      this.newGuids.add(guid);
  }
  onCommit(guids) {
    for (const guid of guids)
      this.newGuids.delete(guid);
  }
  onDelete(guids) {
    for (const guid of guids)
      this.objectCache.get(guid)?.markAsUnavailable(), this.removeObject(guid);
  }
}
class AsyncTaskThrottler {
  constructor(taskHandlingFn, concurrentTasks = 4) {
    this.taskHandlingFn = taskHandlingFn, this.concurrentTasks = concurrentTasks, this.taskQueue = [], this.tasksInProgress = 0;
  }
  async addToQueue(...args) {
    return new Promise((resolve, reject) => {
      this.taskQueue.push({ args, resolve, reject }), this.processQueue();
    });
  }
  processQueue() {
    if (this.tasksInProgress >= this.concurrentTasks)
      return;
    const tasks = this.taskQueue.splice(0, this.concurrentTasks - this.tasksInProgress);
    this.tasksInProgress += tasks.length, tasks.forEach((task) => {
      const { args, resolve, reject } = task;
      this.taskHandlingFn(...args).then((result) => {
        this.tasksInProgress--, resolve(result), this.processQueue();
      }).catch((e) => {
        this.tasksInProgress = 0, this.taskQueue = [], reject(e);
      });
    });
  }
}
class OnlineData {
  constructor(objectCache, lockManager) {
    this.objectCache = objectCache, this.lockManager = lockManager;
  }
  async retrieveByXPath(operationId, args, xpathConstraint, options, wantCount) {
    const json = await memoizeConcurrent({ operationId, args, xpathConstraint, options, wantCount }, () => retrieve(operationId, args, { ...options, wantCount, extraXpath: xpathConstraint }, {}, [])), releaseResponseObjects = await handleRuntimeSuccess(this.objectCache, this.lockManager, json);
    try {
      return { ...this.processResult(json), count: json.count, hasMoreItems: json.hasMoreItems };
    } finally {
      releaseResponseObjects();
    }
  }
  async retrieveByPath(guid, operationId) {
    const [changes, objects] = getRequestDataForGuidsReachableFrom(this.objectCache, [guid]), json = await memoizeConcurrent({ guid, operationId }, () => retrieve(operationId, { CurrentObject: { guid } }, {}, changes, objects)), releaseResponseObjects = await handleRuntimeSuccess(this.objectCache, this.lockManager, json);
    try {
      return this.processResult(json);
    } finally {
      releaseResponseObjects();
    }
  }
  async retrieveByPathUsingOperationIdOrCache(guid, path, direction, entity, operationId) {
    let cachedObjects = [];
    const entityMeta = getEntityMeta(entity), retrieveLocally = void 0 !== entityMeta && function(entityMeta2, path2) {
      const numberOfSteps = path2.split("/").length;
      return !entityMeta2.isPersistable && !entityMeta2.needsReachableState.retrieve && 1 === numberOfSteps;
    }(entityMeta, path);
    if (!operationId && !retrieveLocally)
      throw new Error(`Error trying to retrieve an object of type ${entity}`);
    return operationId && !retrieveLocally || ({ cachedObjects } = getCachedObjectsByPath(guid, direction, path, this.objectCache)), operationId && 0 === cachedObjects.length ? this.retrieveByPath(guid, operationId) : { mxObjects: cachedObjects, count: cachedObjects.length };
  }
  async retrieveByMicroflow(operationId, args, targetForm) {
    let json;
    try {
      const [changes, objects] = getRequestDataForMicroflow(this.objectCache, operationId, getGuidsFromRuntimeArguments(args).concat(getImplicitMicroflowParameters()));
      json = await retrieve(operationId, args, {}, changes, objects);
    } catch (e) {
      throw await handleRuntimeError(this.objectCache, e), e;
    }
    const releaseResponseObjects = await handleRuntimeSuccess(this.objectCache, this.lockManager, json, { targetForm });
    try {
      return { ...this.processResult(json), hasMoreItems: json.hasMoreItems };
    } finally {
      releaseResponseObjects();
    }
  }
  processResult(result) {
    return result.partialObjects.length ? { mxObjects: result.partialObjects.map((obj) => MxObject.fromJson(obj, true).snapshot()), extra: [] } : { mxObjects: result.resultGuids.map((guid) => ensure(this.objectCache.getObject(guid))), extra: result.extraGuids.map((guid) => ensure(this.objectCache.getObject(guid))) };
  }
  async executeMicroflow(operationId, args, targetForm, validationGuids = [], runAsync = false) {
    let json;
    try {
      const sendAllState = Object.values(args).some((mfParam) => "xpath" in mfParam), [changes, objects] = sendAllState ? function(objectCache) {
        const allGuidsInCache = objectCache.getAllObjects().map((obj) => obj.getGuid()), session = getSession();
        return [session.getUserId(), session.getSessionObjectId()].filter((guid) => !allGuidsInCache.includes(guid)).forEach((guid) => allGuidsInCache.push(guid)), getRequestData(objectCache, allGuidsInCache);
      }(this.objectCache) : getRequestDataForMicroflow(this.objectCache, operationId, getGuidsFromRuntimeArguments(args).concat(getImplicitMicroflowParameters()));
      json = runAsync ? await executeAsync((asyncId) => runtimeOperation(operationId, args, changes, objects, validationGuids, asyncId)) : await runtimeOperation(operationId, args, changes, objects, validationGuids);
    } catch (e) {
      throw await handleRuntimeError(this.objectCache, e), e;
    }
    const releaseResponseObjects = await handleRuntimeSuccess(this.objectCache, this.lockManager, json, { targetForm });
    try {
      const result = json.actionResult;
      if (null == result)
        return;
      const { value, type } = result;
      return runtimeValueToExpressionVariable(value, type, (guid) => ensure(this.objectCache.getObject(guid)));
    } finally {
      releaseResponseObjects();
    }
  }
  async executeExternalAction(operationId, actionObject, objectsToCommit) {
    const actionObjectGuid = actionObject.getGuid(), guidsToCommit = unique(objectsToCommit.map((mxobj) => mxobj.getGuid())), [changes, objects] = function(objectCache, actionObjectGuid2, guidsToCommit2) {
      const [changesForGuidsReachableFromContextObject, objectsForGuidsReachableFromContextObject] = getRequestDataForGuidsReachableFrom(objectCache, [actionObjectGuid2]), [changesForCommit, objectsForCommit] = getRequestDataForObjectAction(objectCache, guidsToCommit2, "commit"), changes2 = { ...changesForGuidsReachableFromContextObject, ...changesForCommit }, objects2 = [...objectsForGuidsReachableFromContextObject];
      for (const objectForCommit of objectsForCommit)
        objects2.find((o) => o.guid === objectForCommit.guid) || objects2.push(objectForCommit);
      return [changes2, objects2];
    }(this.objectCache, actionObjectGuid, guidsToCommit);
    let json;
    try {
      const args = { Object: { guid: actionObjectGuid } };
      guidsToCommit.length > 0 && (args.Objects = { guids: guidsToCommit }), json = await runtimeOperation(operationId, args, changes, objects);
    } catch (e) {
      throw await handleRuntimeError(this.objectCache, e), e;
    }
    const releaseResponseObjects = await handleRuntimeSuccess(this.objectCache, this.lockManager, json);
    try {
      handleUncachedObjects(this.objectCache, objectsToCommit, json);
      const { commits = [] } = json, committedObjects = unique(objectsToCommit.filter((objectToCommit) => commits.includes(objectToCommit.getGuid()))), entityUpdates = committedObjects.map((mxobj) => ({ entity: mxobj.getEntity() })), objectUpdates = committedObjects.map((mxobj) => ({ guid: mxobj.getGuid() }));
      await publish(...entityUpdates, ...objectUpdates);
    } finally {
      releaseResponseObjects();
    }
  }
  async createObject(entity, operationId) {
    const entityMeta = getEntityMeta(entity);
    if (void 0 !== entityMeta && (!operationId || function(entityMeta2) {
      return !entityMeta2.isPersistable && !entityMeta2.needsReachableState.create && Object.values(entityMeta2.attributes).every((attr) => !attr.isAlwaysReadOnly && !isSystemAttribute(attr.name));
    }(entityMeta))) {
      const guid = createMendixGuid(entityMeta);
      return this.objectCache.onCreate([guid]), this.objectCache.setMxObjects([createMxObjectJSON(guid, entityMeta)]), this.objectCache.getObject(guid);
    }
    if (void 0 !== operationId)
      return this.executeCreateObjectAction(operationId, entity);
    throw new Error(`Error trying to create an object of type ${entity}`);
  }
  async executeCreateObjectAction(operationId, entity) {
    const [changes, objects] = getEntityMeta(entity)?.needsReachableState.create ? getRequestDataForGuidsReachableFrom(this.objectCache, []) : getRequestData(this.objectCache, []);
    let json;
    try {
      json = await runtimeOperation(operationId, {}, changes, objects);
    } catch (e) {
      throw await handleRuntimeError(this.objectCache, e), e;
    }
    const releaseResponseObjects = await handleRuntimeSuccess(this.objectCache, this.lockManager, json);
    try {
      const guid = ensure(json.actionResult).value;
      return ensure(this.objectCache.getObject(guid));
    } finally {
      releaseResponseObjects();
    }
  }
  async executeObjectAction(operationId, event, mxobjs) {
    if (0 === mxobjs.length)
      return;
    const guids = unique(mxobjs.map((mxobj) => mxobj.getGuid())), [changes, objects] = getRequestDataForObjectAction(this.objectCache, guids, event), guidMapping = indexByKey((mxobj) => mxobj.getGuid())(mxobjs), guidEntityMapping = guids.reduce((previousValue, guid) => (previousValue[guid] = guidMapping[guid].getEntity(), previousValue), {});
    let json;
    try {
      json = await runtimeOperation(operationId, { Objects: { guids } }, changes, objects);
    } catch (e) {
      throw await handleRuntimeError(this.objectCache, e), e;
    }
    const releaseResponseObjects = await handleRuntimeSuccess(this.objectCache, this.lockManager, json);
    try {
      handleUncachedObjects(this.objectCache, mxobjs, json);
      const { commits = [], deletes = [], resets = {} } = json, resetGuids = Object.keys(resets), affectedGuids = "rollback" === event ? [...guids] : [...commits, ...deletes, ...resetGuids].filter((guid) => guids.includes(guid)), objectGuidsToUpdate = "rollback" === event ? [...guids] : [...commits, ...resetGuids], entityUpdates = unique(affectedGuids.map((guid) => guidEntityMapping[guid])).filter((entity) => void 0 !== entity).map((entity) => ({ entity })), objectUpdates = unique(objectGuidsToUpdate).filter((guid) => guids.includes(guid)).map((guid) => ({ guid }));
      await publish(...entityUpdates, ...objectUpdates);
    } finally {
      releaseResponseObjects();
    }
  }
  async generateExport(params) {
    const exportGuids = params?.guids ?? [], [changes, objects] = getRequestDataForGuidsReachableFrom(this.objectCache, exportGuids);
    let json;
    try {
      json = await executeAsync((asyncId) => _export(params, changes, objects, asyncId));
    } catch (e) {
      throw await handleRuntimeError(this.objectCache, e), e;
    }
    await handleRuntimeSuccess(this.objectCache, this.lockManager, json, { autoRelease: true });
  }
}
function assign(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source)
      target[key] = source[key];
  }
  return target;
}
var api = function init(converter, defaultAttributes) {
  function set(name, value, attributes) {
    if ("undefined" != typeof document) {
      "number" == typeof (attributes = assign({}, defaultAttributes, attributes)).expires && (attributes.expires = new Date(Date.now() + 864e5 * attributes.expires)), attributes.expires && (attributes.expires = attributes.expires.toUTCString()), name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
      var stringifiedAttributes = "";
      for (var attributeName in attributes)
        attributes[attributeName] && (stringifiedAttributes += "; " + attributeName, true !== attributes[attributeName] && (stringifiedAttributes += "=" + attributes[attributeName].split(";")[0]));
      return document.cookie = name + "=" + converter.write(value, name) + stringifiedAttributes;
    }
  }
  return Object.create({ set, get: function(name) {
    if ("undefined" != typeof document && (!arguments.length || name)) {
      for (var cookies = document.cookie ? document.cookie.split("; ") : [], jar = {}, i = 0; i < cookies.length; i++) {
        var parts = cookies[i].split("="), value = parts.slice(1).join("=");
        try {
          var found = decodeURIComponent(parts[0]);
          if (jar[found] = converter.read(value, found), name === found)
            break;
        } catch (e) {
        }
      }
      return name ? jar[name] : jar;
    }
  }, remove: function(name, attributes) {
    set(name, "", assign({}, attributes, { expires: -1 }));
  }, withAttributes: function(attributes) {
    return init(this.converter, assign({}, this.attributes, attributes));
  }, withConverter: function(converter2) {
    return init(assign({}, this.converter, converter2), this.attributes);
  } }, { attributes: { value: Object.freeze(defaultAttributes) }, converter: { value: Object.freeze(converter) } });
}({ read: function(value) {
  return '"' === value[0] && (value = value.slice(1, -1)), value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
}, write: function(value) {
  return encodeURIComponent(value).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);
} }, { path: "/" });
class Session {
  constructor(sessionStore, startupLogger, authLogger, bundleVersion, mxVersion, onUnauthorized) {
    this.sessionStore = sessionStore, this.startupLogger = startupLogger, this.authLogger = authLogger, this.bundleVersion = bundleVersion, this.mxVersion = mxVersion, this.onUnauthorized = onUnauthorized, this.unregisterRetryGetSessionDataMiddleware = registerMiddleware(createRetryMiddleware(2, "get_session_data"));
  }
  isValid() {
    return void 0 !== this.sessionData;
  }
  getConfig(path) {
    if (void 0 === this.sessionData)
      throw new Error("Session is not available");
    if (!path)
      return clone(this.sessionData);
    const steps = path.split(".");
    let result = this.sessionData;
    for (let i = 0; i < steps.length && result; i++)
      result = result[ensure(steps[i])];
    return clone(result);
  }
  getUserObject() {
    return this.userObject || (this.userObject = MxObject.fromJson(this.getConfig("user"))), this.userObject;
  }
  isGuest() {
    return this.getConfig("user.attributes.IsAnonymous.value");
  }
  isOffline() {
    return !!this.getConfig("sync_config");
  }
  getOfflineConfig() {
    return this.getConfig("sync_config") ?? void 0;
  }
  getOfflineMetadata() {
    const offlineEntities = new Set(ensure(this.getOfflineConfig()).schema);
    return ensure(this.getConfig("metadata")).filter(({ objectType }) => offlineEntities.has(objectType));
  }
  getSessionObjectId() {
    return this.getConfig("sessionObjectId");
  }
  isStrictModeEnabled() {
    return this.getConfig("isStrictModeEnabled");
  }
  getUserId() {
    return this.getUserObject().getGuid();
  }
  getUserRoleNames() {
    return this.getConfig("roles");
  }
  hasSomeRole(roles) {
    if (void 0 === roles)
      return true;
    const userRoleNames = this.getUserRoleNames();
    return roles.some((role) => userRoleNames.includes(role));
  }
  getConstants() {
    return this.getConfig("constants");
  }
  async login({ username, password, useAuthToken = "default" }) {
    const stopwatch = new Stopwatch();
    this.authLogger.debug("Logging in user."), await login$2(username, password, useAuthToken.toString()), await this.clearCachedSessionDataOnLogin(), this.authLogger.debug(`Login completed in ${stopwatch.measure()} milliseconds`);
  }
  destroySession(callback) {
    callback();
  }
  async clearCachedSessionData() {
    await this.sessionStore.remove();
  }
  async clearCachedSessionDataOnLogin() {
    api.remove("clear_cache"), await this.clearCachedSessionData();
  }
  async logout() {
    const stopwatch = new Stopwatch();
    this.authLogger.debug("Starting logout.");
    try {
      await logout$1();
    } catch (e) {
      if (!(e instanceof ConnectionError))
        throw e;
      api.set("OfflineLogout", "1", { expires: 365 });
    } finally {
      await this.clearCachedSessionData(), this.authLogger.debug(`Logged out the user in ${stopwatch.measure()} milliseconds`);
    }
  }
  async startup(params, runningInDevelopmentHost = false) {
    this.sessionParams = params, "1" === api.get("clear_cache") && await this.clearCachedSessionDataOnLogin();
    const sessionData = await this.loadSessionData(runningInDevelopmentHost, function({ profile, offline }) {
      if (offline)
        return true;
      switch (profile) {
        case "ResponsiveOffline":
        case "NativePhone":
        case "TabletOffline":
        case "PhoneOffline":
          return true;
        default:
          return false;
      }
    }({ profile: params.profile, offline: params.offline }));
    var handler, getCsrfToken;
    return this.sessionData = sessionData, addEnumerations(sessionData.enumerations), this.isOffline() ? registerMiddleware(/* @__PURE__ */ function(recover) {
      const ignoredActions = ["get_session_data", "login", "logout"];
      let recoverPromise, sessionCounter = 0;
      return async (request, next) => {
        const currentSessionNumber = sessionCounter;
        try {
          return await next(request);
        } catch (e) {
          const action2 = isJson(request.body) ? request.body.action : void 0;
          if (!(e instanceof UnauthorizedError) || void 0 !== action2 && ignoredActions.includes(action2))
            throw e;
          if (currentSessionNumber !== sessionCounter)
            return next(request);
          if (recoverPromise)
            return await recoverPromise, next(request);
          recoverPromise = recover();
          try {
            await recoverPromise;
          } finally {
            recoverPromise = void 0;
          }
          return ++sessionCounter, next(request);
        }
      };
    }(this.restoreSessionOnUnauthorized.bind(this))) : (registerMiddleware((handler = this.failOnUnauthorized.bind(this), async (request, next) => {
      try {
        return await next(request);
      } catch (err) {
        const action2 = isJson(request.body) && request.body.action;
        if (err instanceof UnauthorizedError && "login" !== action2)
          return handler(err);
        throw err;
      }
    })), sessionData.keepalive && setInterval(() => {
      keepalive().catch(() => {
      });
    }, sessionData.keepalive)), registerMiddleware((getCsrfToken = () => ensure(this.sessionData).csrftoken, (request, next) => {
      const requestWithToken = { url: request.url, init: { ...request.init, headers: new Headers(request.init.headers) }, body: request.body };
      return requestWithToken.init.headers.append("X-Csrf-Token", getCsrfToken()), next(requestWithToken);
    })), sessionData;
  }
  async loadCachedSessionData() {
    const cachedSessionDataStr = await this.sessionStore.get();
    return void 0 !== cachedSessionDataStr ? JSON.parse(cachedSessionDataStr) : void 0;
  }
  async saveSessionData() {
    await this.sessionStore.set(JSON.stringify(ensure(this.sessionData)));
  }
  async getCachedProfile() {
    const cachedSessionDataStr = await this.sessionStore.get(), cachedSessionData = void 0 !== cachedSessionDataStr ? JSON.parse(cachedSessionDataStr) : void 0;
    if (cachedSessionData)
      return cachedSessionData.uiconfig.profile.kind;
  }
  async loadSessionData(runningInDevelopmentHost, isSessionCacheSupported) {
    const cachedSessionData = isSessionCacheSupported ? await this.loadCachedSessionData() : void 0;
    if (cachedSessionData) {
      const { isDevModeEnabled, bundleVersion, mxVersion } = cachedSessionData;
      this.startupLogger.debug(`Found a cached session data created by the bundle ${bundleVersion} in Mendix ${mxVersion}. The cached session is ${isDevModeEnabled ? "" : "not "}in development mode.`);
    }
    const isCachedSessionDataValid = cachedSessionData && this.bundleVersion && cachedSessionData.bundleVersion === this.bundleVersion;
    cachedSessionData && this.startupLogger.debug(`The cached session data is ${isCachedSessionDataValid ? "" : "not "}valid.`);
    const shouldReloadSessionData = runningInDevelopmentHost && cachedSessionData?.isDevModeEnabled && false !== navigator.onLine;
    if (isCachedSessionDataValid && !shouldReloadSessionData)
      return this.startupLogger.debug("The app will use the cached session data."), cachedSessionData;
    this.startupLogger.debug("The app will not use the cached session data.");
    try {
      const stopwatch = new Stopwatch();
      this.startupLogger.trace("Getting a new session from runtime.");
      const newSessionData = { ...await this.getSessionData(), bundleVersion: this.bundleVersion, mxVersion: this.mxVersion }, duration = stopwatch.measure();
      return this.startupLogger.log(duration.ms > 5e3 ? "warning" : "debug", `Created a new session in ${duration} milliseconds`), newSessionData;
    } catch (e) {
      if (e instanceof ServerError && [401, 460].includes(e.status))
        this.startupLogger.error((401 === e.status ? "Could not create a session because the server responded with 401 (Unauthorized). This may happen if the authentication token is no longer valid. " : "Could not create a session because the server responded with 460 (Session expired). ") + "The app will clear the stored session and restart."), await this.clearCachedSessionData();
      else {
        const logLevel = e instanceof ConnectionError || isCachedSessionDataValid ? "debug" : "error";
        if (this.startupLogger.log(logLevel, "An error occurred while creating a new session." + (isCachedSessionDataValid ? " The app will start using the cached session data." : ""), e), isCachedSessionDataValid)
          return cachedSessionData;
      }
      throw e;
    } finally {
      this.unregisterRetryGetSessionDataMiddleware();
    }
  }
  async getSessionData() {
    const params = ensure(this.sessionParams);
    return getSessionData(params);
  }
  async restoreSessionOnUnauthorized() {
    try {
      const { csrftoken, user } = await this.getSessionData();
      this.isGuest() || user.guid === this.sessionData?.user.guid ? (ensure(this.sessionData).csrftoken = csrftoken, await this.sessionStore.set(JSON.stringify(this.sessionData))) : await this.failOnUnauthorized(new UnauthorizedError(419));
    } catch (e) {
      if (!(e instanceof UnauthorizedError))
        throw e;
      await this.failOnUnauthorized(e);
    }
  }
  async failOnUnauthorized(error) {
    await this.clearCachedSessionData();
    const statusCode = 401 === error.status ? 419 : error.status;
    return this.authLogger.info(`The client is not authorized. Request failed with status code ${statusCode}. Removing session.`), await this.onUnauthorized(), never();
  }
}
function getProfileFromUrl(search) {
  const raw = queryString.parse(search).profile?.toString() ?? "";
  return ["Responsive", "ResponsiveOffline", "Tablet", "Phone", "PhoneOffline", "TabletOffline", ""].includes(raw) ? raw : "Responsive";
}
function translatedError(e) {
  return e instanceof DescribedNanoflowError ? { type: "error", content: e.description } : e instanceof NanoflowError ? translatedError(e.innerError) : e instanceof DescribedError || e instanceof DescribedServerError ? { type: "error", content: e.message } : e instanceof ConnectionError ? { type: "error", content: translate("mxui.sys.UI", "connection_error") } : e instanceof SynchronizationError ? { type: "info", content: translate("mxui.sys.UI", "sync_error") } : e instanceof ServerError ? { type: "error", content: 402 === e.status ? translate("mendix.signin", "http402") : translate("mxui.sys.UI", "internal_error") } : { type: "error", content: translate("mxui.sys.UI", "internal_error") };
}
function createCreateSqlQueries(entities) {
  return [...createGuidToTableSql(), ...entities.flatMap((entity) => [createEntityTableSql(entity), ...createEntityIndices(entity)])];
}
function createDbMetaSqlQueries(version) {
  const createTableSql = generateTableSql(DB_META_TABLE, [{ name: DB_NAME_COLUMN, type: "text" }, { name: DB_VALUE_COLUMN, type: "text" }], DB_NAME_COLUMN), metaData = { [DB_VERSION_KEY]: version.toString(), [DB_COUNTER_KEY]: "0", [toUserScopedName(DB_OFFLINE_METADATA_KEY)]: "[]" };
  return [createTableSql, ...Object.entries(metaData).map(([name, value]) => [`INSERT OR IGNORE INTO "${DB_META_TABLE}" (name, value) VALUES (?,?)`, [name, value]])];
}
function createTombstoneTableSqlQuery() {
  const tombstoneColumnsDescription = [{ name: GUID_COLUMN, type: "text" }, { name: SYNC_ID_COLUMN, type: "text" }];
  return generateTableSql(toUserScopedName(TOMBSTONE_TABLE), tombstoneColumnsDescription, GUID_COLUMN);
}
function createEntityTableSql(entity) {
  const columnDescriptions = getAttributesMeta(entity).map((attr) => ({ name: toSafeKey(attr.name), type: attributeToSqlType(attr.type) })).concat({ name: GUID_COLUMN, type: "text" });
  return generateTableSql(toUserScopedName(toSafeKey(entity)), columnDescriptions, GUID_COLUMN);
}
function createEntityIndices(entity) {
  const associations = getAttributesMeta(entity).filter((a) => "ObjectReference" === a.type), tableName = toUserScopedName(toSafeKey(entity));
  return [...associations.map(({ name }) => [createIndexQuery(`idx_${tableName}_${toSafeKey(name)}`, tableName, { name }), []]), ...getEntityMeta(entity)?.indices.map((index) => createIndexSql(entity, index)) ?? []];
}
function createIndexQuery(name, table, ...columns) {
  return `CREATE INDEX IF NOT EXISTS [${name}] ON [${table}](${columns.map((c) => `[${toSafeKey(c.name)}]` + (void 0 === c.direction ? "" : ` ${c.direction}`)).join(", ")})`;
}
function createIndexSql(entity, index) {
  const tableName = toUserScopedName(toSafeKey(entity));
  return [createIndexQuery(`idx_${tableName}_${index.attributes.map((a) => `${toSafeKey(a.name)}_${a.direction}`).join("_")}`, tableName, ...index.attributes), []];
}
function createGuidToTableSql() {
  const columnDescriptions = [{ name: GUID_COLUMN, type: "text" }, { name: TABLE_NAME_COLUMN, type: "text" }, { name: SYNC_ID_COLUMN, type: "text" }, { name: READONLY_COLUMN, type: "text" }], tableName = toUserScopedName(METADATA_TABLE), tableNameWithoutSyncIdIndexSql = [createIndexQuery(`idx_${tableName}_tableName_withSyncId`, tableName, { name: TABLE_NAME_COLUMN }) + ` WHERE [${SYNC_ID_COLUMN}] IS NOT NULL`, []];
  return [generateTableSql(tableName, columnDescriptions, GUID_COLUMN), tableNameWithoutSyncIdIndexSql];
}
function generateTableSql(name, columnDescriptions, primaryKey) {
  if (columnDescriptions.length > 990)
    throw new Error(`Unable to create table '${name}' with more than 990 columns.`);
  return [[`CREATE TABLE IF NOT EXISTS "${name}" (`, columnDescriptions.map((columnDescription) => [`"${columnDescription.name}"`, columnDescription.type, "text" === columnDescription.type ? "COLLATE NOCASE" : "", columnDescription.name === primaryKey ? "PRIMARY KEY" : ""].join(" ").trim()).join(", "), ")"].join(""), []];
}
function attributeToSqlType(attributeType) {
  switch (attributeType) {
    case "Decimal":
    case "Enum":
    case "HashString":
    case "Integer":
    case "Long":
    case "ObjectReference":
    case "String":
    case "EnumSet":
    case "ObjectReferenceSet":
      return "text";
    case "AutoNumber":
    case "Boolean":
    case "DateTime":
      return "integer";
    case "Binary":
      return "blob";
  }
}
function createCleanSqlQueries(tableName) {
  return [`DELETE FROM "${toUserScopedName(tableName)}"`, []];
}
function createDropTableSqlQuery(tableName) {
  return [`DROP TABLE IF EXISTS "${toUserScopedName(tableName)}"`, []];
}
function createEntitySql(objects) {
  const objectsPerEntity = objects.reduce((map, object) => (map[object.objectType] = (map[object.objectType] ?? []).concat(object), map), {});
  return Object.entries(objectsPerEntity).flatMap(([entityName, entityObjects]) => {
    const meta = getEntityMeta(entityName), attributes = Object.values(meta?.attributes ?? {}), columns = [`"${GUID_COLUMN}"`, ...attributes.map((a) => `"${toSafeKey(a.name)}"`)], columnPlaceholders = new Array(columns.length).fill("?").join(", ");
    return chunkParameters(entityObjects, columns.length).flatMap((objectsChunk) => {
      const placeholders = new Array(objectsChunk.length).fill(`(${columnPlaceholders})`).join(", ");
      return [[`INSERT OR REPLACE INTO "${toUserScopedName(toSafeKey(entityName))}" (${columns.join(", ")}) VALUES ${placeholders}`, objectsChunk.flatMap((object) => [object.guid, ...attributes.map((a) => runtimeToSql(object.attributes[a.name]?.value ?? null, a.type))])]];
    });
  });
}
function createMetaSql(objects) {
  return chunkParameters(objects, 4).flatMap((objectsChunk) => {
    const placeholders = new Array(objectsChunk.length).fill("(?, ?, ?, ?)").join(", ");
    return [[`INSERT OR REPLACE INTO "${toUserScopedName(METADATA_TABLE)}" ("${GUID_COLUMN}", "${TABLE_NAME_COLUMN}", "${SYNC_ID_COLUMN}", "${READONLY_COLUMN}") VALUES ${placeholders}`, objectsChunk.flatMap((object) => {
      const readonlyAttrs = Object.entries(object.attributes).filter(([, attribute]) => attribute.readonly).map(([attrName]) => attrName);
      return [object.guid, object.objectType, object.syncId ?? null, JSON.stringify(readonlyAttrs)];
    })]];
  });
}
function createSelectObjectsByGuidsQueries(entity, guids) {
  if (0 === guids.length)
    throw new AssertionError("No guids specified");
  return chunkParameters(guids).map((chunkedGuids) => {
    const placeholders = new Array(chunkedGuids.length).fill("?").join(", "), safeEntityName = toSafeKey(entity), tableName = toUserScopedName(safeEntityName), metaDataTable = toUserScopedName(METADATA_TABLE);
    return [[`SELECT ${safeEntityName}.*,`, METADATA_COLUMNS.map((col) => `${METADATA_TABLE}.[${col}] AS "${METADATA_TABLE}.${col}"`).join(", "), `FROM "${tableName}" AS ${safeEntityName}`, `JOIN ${metaDataTable} AS ${METADATA_TABLE} USING (${GUID_COLUMN})`, `WHERE ${METADATA_TABLE}.${GUID_COLUMN} IN (${placeholders})`].join(" "), chunkedGuids];
  });
}
function attributeToColumn(entity, attribute) {
  return `${toSafeKey(entity)}.[${toSafeKey(attribute)}]`;
}
class SelectQueryBuilder {
  constructor(entity) {
    this.selectColumns = [], this.tableNameAlias = toSafeKey(entity), this.tableName = toUserScopedName(this.tableNameAlias), this.fromClause = `FROM ${this.tableName} AS ${this.tableNameAlias}`;
  }
  filtered(filter) {
    const { type, expr, params } = toSqlFilter(filter, this.tableNameAlias, true);
    return "null" !== type && (this.whereClause = `WHERE ${expr}`, this.bindParameters = params), this;
  }
  sorted(sort) {
    const sortStr = sort.map(([attr, order]) => `${attributeToColumn(this.tableNameAlias, attr)} ${order}`).join(", ");
    return this.orderClause = sortStr ? `ORDER BY ${sortStr}` : "", this;
  }
  paged(offset, amount) {
    return this.limitClause = `LIMIT ${void 0 !== amount && amount > 0 ? amount : -1} OFFSET ${offset ?? 0}`, this;
  }
  columns(columns) {
    return this.selectColumns = columns, this;
  }
  attributes(attributes) {
    return this.selectColumns = attributes.map((attr) => ({ column: attributeToColumn(this.tableNameAlias, attr), alias: toSafeKey(attr) })), this;
  }
  buildSelectWithMeta() {
    const metadataTable = toUserScopedName(METADATA_TABLE);
    return [["SELECT", this.selectColumns.map(({ column, alias }) => `${column} AS "${alias}"`).concat(METADATA_COLUMNS.map((col) => `${METADATA_TABLE}.[${col}] AS "${METADATA_TABLE}.${col}"`)).join(", "), this.fromClause, `JOIN ${metadataTable} AS ${METADATA_TABLE} USING (${GUID_COLUMN})`, this.whereClause, this.orderClause, this.limitClause].filter((s) => s).join(" "), this.bindParameters ?? []];
  }
  buildCount() {
    return [['SELECT COUNT("guid") AS count', this.fromClause, this.whereClause].filter((s) => s).join(" "), this.bindParameters ?? []];
  }
}
class UnionBuilder {
  constructor() {
    this.orderClause = "", this.limitClause = "", this.selectQueries = [];
  }
  addQuery(query) {
    return this.selectQueries.push(query), this;
  }
  sorted(sort) {
    const sortStr = sort.map(([attr, order]) => `"${attr}" ${order}`).join(", ");
    return this.orderClause = sortStr ? ` ORDER BY ${sortStr}` : "", this;
  }
  paged(offset, amount) {
    return this.limitClause = ` LIMIT ${void 0 !== amount && amount > 0 ? amount : -1} OFFSET ${offset ?? 0}`, this;
  }
  build() {
    const [queries, params] = function(array) {
      const t1s = [], t2s = [];
      return array.forEach(([t1, t2]) => {
        t1s.push(t1), t2s.push(t2);
      }), [t1s, t2s];
    }(this.selectQueries);
    return [queries.join(" UNION ") + this.orderClause + this.limitClause, params.flat()];
  }
}
function rowToJson(row) {
  const objectType = row[`${METADATA_TABLE}.${TABLE_NAME_COLUMN}`], result = { guid: row[`${METADATA_TABLE}.${GUID_COLUMN}`], attributes: {}, objectType }, entityMeta = getEntityMeta(objectType), readonlyAttributes = JSON.parse(row[`${METADATA_TABLE}.${READONLY_COLUMN}`]) ?? [];
  return Object.keys(row).filter((attrKey) => !attrKey.startsWith(METADATA_TABLE) && attrKey !== GUID_COLUMN).forEach((attrKey) => {
    const attr = function(alias) {
      const parts = alias.split(";");
      if (parts.length > 1)
        return parts[parts.length - 1];
      return alias;
    }(fromSafeKey(attrKey)), attrType = entityMeta?.attributes[attr]?.type ?? "String";
    result.attributes[attr] = { value: sqlToRuntime(row[attrKey], attrType), ...readonlyAttributes.includes(attr) ? { readonly: true } : {} };
  }), result;
}
function toAlias(entity, attribute) {
  return toSafeKey(`${entity};${attribute}`);
}
class SQLiteDB {
  constructor(database) {
    this.database = database, this.lastUniqueId = 0, this.queryListeners = [];
  }
  registerQueryListener(listener) {
    this.queryListeners.push(listener);
  }
  async usingReadTransaction(fn) {
    return this.database.inTransaction(async (tx) => fn(new SQLiteDBQueriesAndCommands(this, tx)));
  }
  async usingWriteTransaction(fn) {
    return this.database.inTransaction(async (tx) => fn(new SQLiteDBQueriesAndCommands(this, tx)));
  }
  async delete(entities) {
    await this.usingWriteTransaction((tx) => tx.delete(entities)), await this.execute(["VACUUM", []], (query, params) => this.database.exec(query, emptyParamsAsUndefined(params)));
  }
  async runMigrations(migrations) {
    const dbVersion = await this.usingReadTransaction((tx) => tx.getDatabaseVersion()), startingMigrationIndex = migrations.findIndex(({ version }) => version === dbVersion), applicableMigrations = -1 === startingMigrationIndex ? migrations : migrations.slice(startingMigrationIndex + 1);
    for (const migration of applicableMigrations) {
      await migration.apply(this.database);
      const updateVersionQuery = createUpdateDbMetaValue(DB_VERSION_KEY, migration.version.toString());
      await this.database.inTransaction(async (tx) => this.exec(tx, updateVersionQuery));
    }
  }
  async wrap(queryDescription, doQuery) {
    const handlers = this.queryListeners.map((wrapper) => wrapper(queryDescription));
    try {
      const result = await doQuery();
      return handlers.forEach(([onComplete, _]) => onComplete(result)), result;
    } catch (error) {
      return handlers.forEach(([_, onError]) => onError(error)), Promise.reject(error);
    }
  }
  async execute(sql, fn) {
    const [query, params] = sql;
    return this.wrap(`${query}
Params: ${JSON.stringify(params)}`, () => fn(query, params));
  }
  async selectObjects(tx, sql) {
    if (sql.length > 0) {
      if (2 !== sql.length || "string" != typeof sql[0]) {
        const sortedSqls = sql.sort(([sqlA], [sqlB]) => sqlA.localeCompare(sqlB));
        return (await Promise.all(sortedSqls.map((query) => this.selectObjects(tx, query)))).flat();
      }
      return this.execute(sql, (query, params) => tx.selectObjects(query, emptyParamsAsUndefined(params)));
    }
    return [];
  }
  async selectValue(tx, sql) {
    return this.execute(sql, (query, params) => tx.selectValue(query, emptyParamsAsUndefined(params)));
  }
  async exec(tx, sql) {
    if (sql.length > 0) {
      if (2 !== sql.length || "string" != typeof sql[0]) {
        return (await Promise.all(sql.map((q) => doExec(this, q)))).reduce((total, amount) => total + amount, 0);
      }
      return doExec(this, sql);
    }
    return 0;
    async function doExec(self, sqlQuery) {
      return self.execute(sqlQuery, async (query, params) => tx.exec(query, emptyParamsAsUndefined(params)));
    }
  }
  getLowLevelAPI() {
    return this.database;
  }
  async increaseAndGetUniqueId(amount, allocate) {
    const idsUsedInBatch = this.lastUniqueId % SQLiteDB.ID_BATCH_SIZE, idsLeftInBatch = SQLiteDB.ID_BATCH_SIZE - idsUsedInBatch;
    if (0 === this.lastUniqueId || idsLeftInBatch < amount) {
      const amountOfBatches = Math.ceil(Math.abs(amount - idsLeftInBatch) / SQLiteDB.ID_BATCH_SIZE), newLastId = await allocate(amountOfBatches * SQLiteDB.ID_BATCH_SIZE);
      0 === this.lastUniqueId && (this.lastUniqueId = newLastId - amountOfBatches * SQLiteDB.ID_BATCH_SIZE);
    }
    return this.lastUniqueId += amount, this.lastUniqueId;
  }
}
function emptyParamsAsUndefined(params) {
  return 0 === params.length ? void 0 : params;
}
SQLiteDB.ID_BATCH_SIZE = 1e3;
class SQLiteDBQueries {
  constructor(database, api2) {
    this.api = api2, this.database = database;
  }
  async selectObjects(sql) {
    return this.database.selectObjects(this.api, sql);
  }
  async selectValue(sql) {
    return this.database.selectValue(this.api, sql);
  }
  async retrieveAllTombstones() {
    return await this.selectObjects([`SELECT "${GUID_COLUMN}", "${SYNC_ID_COLUMN}" FROM "${toUserScopedName(TOMBSTONE_TABLE)}"`, []]);
  }
  async retrieveDirtyObjects(excludedEntities) {
    const sql = createGetDirtyObjectsMetadataSql(excludedEntities), rows = await this.selectObjects(sql), queries = groupByMap(rows, (row) => row[TABLE_NAME_COLUMN], (row) => row[GUID_COLUMN]).flatMap(({ key, values }) => createSelectObjectsByGuidsQueries(key, values));
    return (await this.selectObjects(queries)).map((row) => ({ syncId: row[`${METADATA_TABLE}.${SYNC_ID_COLUMN}`], ...rowToJson(row) }));
  }
  async retrieveEntityMetadatas() {
    const offlineMetadataQuery = createGetDbMetaValue(toUserScopedName(DB_OFFLINE_METADATA_KEY)), result = await this.selectObjects(offlineMetadataQuery);
    return JSON.parse(ensure(result[0])[DB_VALUE_COLUMN]);
  }
  async retrieveMxObjectsFromSql(sql, includeSyncId) {
    return (await this.selectObjects(sql)).map((row) => {
      const syncId = row[`${METADATA_TABLE}.${SYNC_ID_COLUMN}`], object = rowToJson(row);
      return includeSyncId ? { syncId, ...object } : object;
    });
  }
  async retrieveMxObjects(entity, filter, options, includeSyncId = false) {
    const entities = [entity, ...getEntityMeta(entity).specializations], sql = 1 === entities.length ? buildRetrieveMxObjectsQuery(entity, filter, options).buildSelectWithMeta() : function() {
      const maybePredefinedColumns = options?.attributes?.map((a) => ({ column: attributeToColumn(entity, a), alias: toAlias(entity, a) })), attributesPerEntity = Object.fromEntries(entities.map((e) => [e, getAttributesPerEntity(e)])), allAttributes = uniqueBy(Object.values(attributesPerEntity).flat(), ({ alias }) => alias), unionBuilder = new UnionBuilder();
      entities.map((e) => {
        const columns = maybePredefinedColumns ?? function(e2, attributes, allAttributes2) {
          const attributeAliases = new Set(attributes.map(({ alias }) => alias));
          return allAttributes2.map((a) => ({ column: attributeAliases.has(a.alias) ? attributeToColumn(e2, a.attribute) : "NULL", alias: a.alias }));
        }(e, attributesPerEntity[e], allAttributes);
        return buildRetrieveMxObjectsQuery(e, convertToSpecializationFilter(entity, e, filter), { columns }).buildSelectWithMeta();
      }).forEach((query) => unionBuilder.addQuery(query)), void 0 !== options?.sort && unionBuilder.sorted(options.sort.map(([attr, order]) => [toAlias(entity, attr), order]));
      void 0 === options?.amount && void 0 === options?.offset || unionBuilder.paged(options.offset, options.amount);
      return unionBuilder.build();
    }();
    return this.retrieveMxObjectsFromSql(sql, includeSyncId);
    function getAttributesPerEntity(e) {
      const currentEntityResult = getAttributesMeta(e).map((a) => ({ attribute: a.name, alias: toAlias(e, a.name) })), generalization = getEntityMeta(e).generalization;
      if (e === entity || void 0 === generalization)
        return currentEntityResult;
      const superAttributes = getAttributesPerEntity(generalization), superAttributesSet = new Set(superAttributes.map(({ attribute }) => attribute));
      return superAttributes.concat(currentEntityResult.filter(({ attribute }) => !superAttributesSet.has(attribute)));
    }
  }
  async retrieveMxObjectMetasByGuids(guids) {
    const sql = createGetEntitiesSql(guids);
    return (await this.selectObjects(sql)).map((row) => ({ guid: row[GUID_COLUMN], objectType: row[TABLE_NAME_COLUMN] }));
  }
  async buildEntityGuidsList(guids) {
    const [runtimeGuids, offlineGuids] = partition(function(guid) {
      return isRuntimeGuid(guid) && void 0 !== deriveEntityUnchecked(guid);
    }, guids), offlineGuidsPerEntity = await (async (ids) => {
      if (0 === ids.length)
        return [];
      const objectMetas = await this.retrieveMxObjectMetasByGuids(ids);
      return 0 === objectMetas.length ? Promise.resolve([]) : groupByMap(objectMetas, (row) => row.objectType, (row) => row.guid);
    })(offlineGuids);
    return [...groupBy(runtimeGuids, deriveEntity).filter(({ key }) => true === getEntityMeta(key)?.isPersistable), ...offlineGuidsPerEntity];
  }
  async retrieveMxObjectByGuids(guids) {
    const queries = (await this.buildEntityGuidsList(guids)).flatMap(({ key, values }) => createSelectObjectsByGuidsQueries(key, values));
    return this.retrieveMxObjectsFromSql(queries);
  }
  async retrieveMxObjectsCount(entity, filter) {
    return [entity, ...getEntityMeta(entity).specializations].map((e) => {
      const sql = buildRetrieveMxObjectsQuery(e, convertToSpecializationFilter(entity, e, filter)).buildCount();
      return this.selectValue(sql);
    }).reduce(async (sum, current) => await sum + await current, Promise.resolve(0));
  }
  async retrieveSyncIds(guids) {
    const sql = createGetSyncIdsSqlQueries(guids);
    return (await this.selectObjects(sql)).map((row) => [row[GUID_COLUMN], row[SYNC_ID_COLUMN]]);
  }
  async retrieveGuidsAndChangeDatesForFileObjects(entity) {
    const sql = function(entity2) {
      const userScopedSafeTableName = toSafeKey(toUserScopedName(entity2));
      return [`SELECT ${[GUID_COLUMN, CHANGED_DATE_COLUMN].join(", ")} FROM "${userScopedSafeTableName}" WHERE ${HAS_CONTENTS_COLUMN} = 1`, []];
    }(entity);
    return (await this.selectObjects(sql)).map((row) => ({ guid: row[GUID_COLUMN], changedDate: row[CHANGED_DATE_COLUMN] }));
  }
  async getDatabaseVersion() {
    const dbVersionQuery = createGetDbMetaValue(DB_VERSION_KEY);
    return parseInt(await this.selectValue(dbVersionQuery), 10);
  }
  async checkTableExists(tableName) {
    const sql = createCheckTableExistSqlQuery(tableName === DB_META_TABLE ? DB_META_TABLE : toUserScopedName(tableName));
    return 1 === await this.selectValue(sql);
  }
}
class SQLiteDBQueriesAndCommands extends SQLiteDBQueries {
  constructor(database, tx) {
    super(database, tx), this.tx = tx;
  }
  async exec(sql) {
    return this.database.exec(this.tx, sql);
  }
  async ensureSchema(entities, latestVersion) {
    const queries = [...createCreateSqlQueries(entities), ...createDbMetaSqlQueries(latestVersion), createTombstoneTableSqlQuery()];
    await this.exec(queries);
  }
  async changeEntityTable(entity, attributesToAdd, attributesToRemove) {
    const baseQuery = `ALTER TABLE ${toUserScopedName(toSafeKey(entity))}`, queries = [...attributesToAdd.map(([attr, meta]) => {
      const sqlType = attributeToSqlType(meta.type);
      return `ADD "${toSafeKey(attr)}" ${sqlType} ${"text" === sqlType ? "COLLATE NOCASE" : ""}`;
    }), ...attributesToRemove.map((attr) => `DROP "${toSafeKey(attr)}"`)].map((instruction) => [`${baseQuery} ${instruction}`, []]);
    await this.exec(queries);
  }
  async createIndex(entity, index) {
    const query = createIndexSql(entity, index);
    await this.exec(query);
  }
  async dropIndex(entity, index) {
    const query = function(entity2, index2) {
      return [`DROP INDEX IF EXISTS [idx_${toUserScopedName(toSafeKey(entity2))}_${index2.attributes.map((a) => `${toSafeKey(a.name)}_${a.direction}`).join("_")}]`, []];
    }(entity, index);
    await this.exec(query);
  }
  async delete(entities) {
    const queries = [...entities.map((entity) => createDropTableSqlQuery(toSafeKey(entity))), createDropTableSqlQuery(METADATA_TABLE), createDropTableSqlQuery(TOMBSTONE_TABLE)];
    await this.exec(queries);
  }
  async clearDirtyFlags(guids) {
    const queries = createClearDirtyGuidsSqlQueries(guids);
    return this.exec(queries);
  }
  async dropEntityTables(entities) {
    const queries = [...entities.map((entity) => createDropTableSqlQuery(toSafeKey(entity))), ...createDeleteEntitiesMetaSqlQueries(entities)];
    await this.exec(queries);
  }
  async deleteEntitiesByEntity(entity) {
    const queries = [createCleanSqlQueries(toSafeKey(entity)), ...createDeleteEntitiesMetaSqlQueries([entity])];
    return this.exec(queries);
  }
  async deleteEntitiesByGuid(guids) {
    const queries = (await this.buildEntityGuidsList(guids)).flatMap(({ key, values }) => function(entity, guids2) {
      if (0 === guids2.length)
        throw new AssertionError("No guids specified");
      return chunkParameters(guids2).flatMap((value) => {
        const placeholders = new Array(value.length).fill("?").join(", ");
        return [[`DELETE FROM "${toUserScopedName(toSafeKey(entity))}" WHERE ${GUID_COLUMN} IN (${placeholders})`, value], [`DELETE FROM "${toUserScopedName(METADATA_TABLE)}" WHERE ${TABLE_NAME_COLUMN} = '${entity}' AND ${GUID_COLUMN} IN (${placeholders})`, value]];
      });
    }(key, values));
    return this.exec(queries);
  }
  async deleteTombstones(guids) {
    const queries = function(guids2) {
      if (0 === guids2.length)
        throw new AssertionError("No guids specified");
      return chunkParameters(guids2).flatMap((value) => {
        const placeholders = new Array(value.length).fill("?").join(", ");
        return [[`DELETE FROM "${toUserScopedName(TOMBSTONE_TABLE)}" WHERE "${GUID_COLUMN}" IN (${placeholders})`, value]];
      });
    }(guids);
    await this.exec(queries);
  }
  async insertTombstones(items) {
    const queries = function(items2) {
      return chunkParameters(items2, 2).flatMap((itemChunk) => {
        const placeholders = new Array(itemChunk.length).fill("(?, ?)").join(", ");
        return [[`INSERT OR REPLACE INTO "${toUserScopedName(TOMBSTONE_TABLE)}" ("${GUID_COLUMN}", "${SYNC_ID_COLUMN}") VALUES ${placeholders}`, itemChunk.flatMap((item) => [item.guid, item.syncId])]];
      });
    }(items);
    await this.exec(queries);
  }
  async truncateTombstones() {
    const sql = createCleanSqlQueries(TOMBSTONE_TABLE);
    await this.exec(sql);
  }
  async increaseAndGetUniqueId(amount) {
    return this.database.increaseAndGetUniqueId(amount, async (batch) => {
      const updateCounterQuery = createUpdateCounterValue(batch), readCounterQuery = createGetDbMetaValue(DB_COUNTER_KEY);
      return await this.exec(updateCounterQuery), parseInt(await this.selectValue(readCounterQuery), 10);
    });
  }
  async insertMxObjects(items) {
    return this.insertMxObjectsWithSyncId(items.map((obj) => ({ ...obj, syncId: null })));
  }
  async insertMxObjectsWithSyncId(items) {
    const queries = [...createEntitySql(objects = items), ...createMetaSql(objects)];
    var objects;
    return this.exec(queries);
  }
  async reset() {
    const sql = createDropTableSqlQuery(METADATA_TABLE);
    await this.exec(sql);
  }
  async updateEntityData(entity, guid, attribute, newValue) {
    const updates = { [attribute]: newValue }, sql = createUpdateSqlQuery(ensure(getEntityMeta(entity)), updates, GUID_COLUMN, guid);
    return this.exec(sql);
  }
  async updateEntityDataReferringTo(entity, refersTo, attribute, newValue) {
    const queries = function(entityAttrPairs, oldValue, newValue2) {
      return Object.entries(entityAttrPairs).flatMap(([entityName, attrs]) => attrs.map((attr) => {
        const updates = { [attr]: newValue2 };
        return createUpdateSqlQuery(ensure(getEntityMeta(entityName)), updates, attr, oldValue);
      }));
    }({ [entity]: [attribute] }, refersTo, newValue);
    return this.exec(queries);
  }
  async updateEntityGuids(guids, guidMapping, entities) {
    const metaTableName = toUserScopedName(METADATA_TABLE), updateEntityGuidAmounts = await Promise.all(guids.filter((guid) => guidMapping.has(guid)).flatMap((guid) => [this.updateEntityData(ensure(guidMapping.getEntity(guid)), guid, "guid", guidMapping.getGuid(guid)), this.exec([`UPDATE ${metaTableName} SET ${GUID_COLUMN} = ? WHERE [${GUID_COLUMN}] = ?`, [guidMapping.getGuid(guid), guid]])])), entityAssociationsPairsCache = createMemoizedCache((entity) => getEntityAssociationsPairs(entity, entities)), updateReferringEntityAmounts = await Promise.all(guidMapping.entries().flatMap(([oldGuid, newGuid, entity]) => {
      const entityAssociationsPairs = entityAssociationsPairsCache(entity) ?? {};
      return Object.entries(entityAssociationsPairs).flatMap(([entityName, attrs]) => Promise.all(attrs.map((attr) => this.updateEntityDataReferringTo(entityName, oldGuid, attr, newGuid))));
    }));
    return updateEntityGuidAmounts.concat(updateReferringEntityAmounts.flat()).reduce((sum, current) => sum + current, 0);
  }
  async updateEntityMetadatas(values) {
    const sql = createUpdateDbMetaValue(toUserScopedName(DB_OFFLINE_METADATA_KEY), JSON.stringify(values));
    return this.exec(sql);
  }
}
function buildRetrieveMxObjectsQuery(entity, filter, options) {
  const providedOptions = options ?? {}, sqlBuilder = new SelectQueryBuilder(entity), columns = providedOptions.columns ?? getAttributesMeta(entity).map((m) => ({ column: attributeToColumn(entity, m.name), alias: toAlias(entity, m.name) }));
  return sqlBuilder.columns(columns), void 0 !== filter && sqlBuilder.filtered(filter), void 0 === providedOptions.offset && void 0 === providedOptions.amount || sqlBuilder.paged(providedOptions.offset, providedOptions.amount), void 0 !== providedOptions.sort && sqlBuilder.sorted(providedOptions.sort), sqlBuilder;
}
class Parser {
  formatValue(value, type, config) {
    if ("" === value || null === value)
      return "";
    switch (type.toLowerCase()) {
      case "decimal":
      case "integer":
      case "long": {
        if ("string" == typeof value || "number" == typeof value)
          try {
            value = new Big(value);
          } catch {
            throw new Error(`Value '${value}' cannot be formatted as a numeric value.`);
          }
        if (!(value instanceof Big))
          throw new Error(`Value '${value}' cannot be formatted as a numeric value.`);
        const numberConfig = toNumberFormatterConfig(config), groupDigits = numberConfig && numberConfig.groupDigits, configuredDecimals = numberConfig && numberConfig.decimalPrecision, defaultDecimals = "decimal" === type.toLowerCase() ? void 0 : 0;
        return formatNumber(value, groupDigits, void 0 !== configuredDecimals ? configuredDecimals : defaultDecimals);
      }
      case "datetime": {
        if (!("number" == typeof value || value instanceof Date))
          throw new Error(`Value '${value}' cannot be formatted as Date.`);
        const dateTimeConfig = toDateTimeFormatterConfig(config);
        return formatDate$1(new Date(value), dateTimeConfig);
      }
      case "boolean":
        if ("boolean" != typeof value)
          throw new Error(`Value '${value}' cannot be formatted as boolean.`);
        return translate("mxui.common", value.toString());
      default:
        return String(value);
    }
  }
  formatAttribute(object, attribute, config) {
    const type = object.getAttributeType(attribute), value = object.get(attribute);
    return "Enum" === type ? object.getEnumCaption(attribute) || value : this.formatValue(value, type, config);
  }
  parseValue(value, type, config) {
    if ("" === value)
      return "";
    switch (type.toLowerCase()) {
      case "integer":
      case "long":
      case "decimal": {
        const numberConfig = toNumberFormatterConfig(config), configuredDecimals = numberConfig && numberConfig.decimalPrecision;
        return parseNumber(value, configuredDecimals) || null;
      }
      case "datetime": {
        const dateTimeConfig = toDateTimeFormatterConfig(config);
        return parseDate(value, dateTimeConfig) || null;
      }
      case "enum":
      default:
        return value;
      case "boolean":
        return value === translate("mxui.common", "true");
    }
  }
}
function toNumberFormatterConfig(config) {
  if (config)
    return "places" in config ? { decimalPrecision: config.places, groupDigits: Boolean(config.groups) } : config;
}
function toDateTimeFormatterConfig(config) {
  return config ? "datePattern" in config && config.datePattern ? { type: "custom", pattern: config.datePattern } : "selector" in config ? { type: config.selector } : config : { type: "date" };
}

var module$1, classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
module$1 = classnames, function() {
  var hasOwn = {}.hasOwnProperty;
  function classNames2() {
    for (var classes = "", i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      arg && (classes = appendClass(classes, parseValue(arg)));
    }
    return classes;
  }
  function parseValue(arg) {
    if ("string" == typeof arg || "number" == typeof arg)
      return arg;
    if ("object" != typeof arg)
      return "";
    if (Array.isArray(arg))
      return classNames2.apply(null, arg);
    if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]"))
      return arg.toString();
    var classes = "";
    for (var key in arg)
      hasOwn.call(arg, key) && arg[key] && (classes = appendClass(classes, key));
    return classes;
  }
  function appendClass(value, newClass) {
    return newClass ? value ? value + " " + newClass : value + newClass : value;
  }
  module$1.exports ? (classNames2.default = classNames2, module$1.exports = classNames2) : window.classNames = classNames2;
}();
var classNames = getDefaultExportFromCjs$1(classnames.exports);

function isPhone() {
  return /Android.*Mobile|iPhone|iPod|BlackBerry|Windows.*Phone/.test(navigator.userAgent);
}
function isTablet() {
  return /iPad|Android/.test(navigator.userAgent) || navigator.userAgent.includes("Mac") && navigator.maxTouchPoints > 1;
}
function isMobileDevice() {
  return isPhone() || isTablet();
}
const DISABLE_INTERACTION_ATTRIBUTE = "data-disable-interaction", FOCUS_CAPTURING_ATTRIBUTE = "data-focus-capturing", FOCUS_CAPTURING_MODAL = "modal", FOCUS_CAPTURING_NON_MODAL = "non-modal";
function initialize() {
  document.body.addEventListener("keydown", onKeyDown), document.body.addEventListener("focusin", onFocusIn), document.body.addEventListener("mousedown", onMouseDown);
}
function onMouseDown(e) {
  document.body.hasAttribute("data-disable-interaction") && e.preventDefault();
}
function onKeyDown(e) {
  if (document.body.hasAttribute("data-disable-interaction"))
    e.preventDefault();
  else if ("Tab" === e.key) {
    const nextInput = function(target, reverse = false) {
      const element = target && getHTMLElement(target), wrapAround = () => findNextNonWrapping(getFocusCapturingRoot(element) ?? document.body, reverse);
      return (element && findNextNonWrapping(element, reverse)) ?? wrapAround();
    }(e.target, e.shiftKey);
    nextInput && (e.preventDefault(), setFocus(nextInput));
  }
}
function onFocusIn(e) {
  const target = e.target;
  if (target === document.body)
    return;
  const focusRoot = getFocusRoot(target);
  focusRoot.contains(target) || function(container) {
    const first = findFirst(container);
    first && setFocus(first);
  }(focusRoot);
}
function setFocus(element) {
  !function() {
    const selection = document.getSelection();
    if (null === selection || function(selection2) {
      if (1 === selection2.rangeCount) {
        const range = selection2.getRangeAt(0);
        return range.startOffset === range.endOffset;
      }
      return 0 === selection2.rangeCount;
    }(selection))
      return;
    selection.removeAllRanges(), selection.addRange(document.createRange());
  }(), element.focus(), function(element2) {
    const input = element2;
    "text" !== input.type && "password" !== input.type || input.select();
  }(element);
}
function getFocus() {
  const activeElement = document.activeElement && getHTMLElement(document.activeElement);
  return activeElement !== document.body ? activeElement : null;
}
function findFirst(container) {
  return findNextInContainer(container, false);
}
function findNextNonWrapping(element, reverse = false) {
  const focusRoot = getFocusRoot(element);
  let current, found;
  if (focusRoot.contains(element))
    current = element;
  else {
    if (isFocusable(focusRoot))
      return focusRoot;
    current = focusRoot;
  }
  if (!reverse && isFocusContext(current) && !skipContainer(current) && (found = findNextInContainer(current, !!reverse), found))
    return found;
  do {
    const context = findFocusContext(current, focusRoot);
    if (found = findNextInContainer(context, !!reverse, current), found)
      return found;
    if (reverse && isFocusable(context))
      return context;
    current = context;
  } while (current !== focusRoot);
  return null;
}
function findFocusContext(element, focusRoot) {
  if (element === focusRoot)
    return focusRoot;
  let current = element;
  for (; current !== focusRoot && current.parentElement; )
    if (current = current.parentElement, isFocusContext(current))
      return current;
  return focusRoot;
}
function getFocusRoot(element) {
  const capturingRoot = getFocusCapturingRoot(element);
  return capturingRoot ? function() {
    const focusRoots = document.querySelectorAll("[data-focus-capturing=modal]");
    return Array.from(focusRoots).filter(isHTMLElement).sort((a, b) => Number(b.style.zIndex) - Number(a.style.zIndex))[0];
  }() ?? capturingRoot : document.body;
}
function getFocusCapturingRoot(element) {
  if (!element || element === document.body)
    return document.body;
  let current = element;
  for (; current && isHTMLElement(current); ) {
    const captureMode = current.getAttribute("data-focus-capturing");
    if ("modal" === captureMode || "non-modal" === captureMode)
      return current;
    current = current.parentElement;
  }
  return null;
}
function findNextInContainer(container, reverse, afterElement) {
  const startTabIndex = afterElement && afterElement !== container ? getEffectiveTabIndex(afterElement) : void 0, candidates = gatherDescendants(container), tabIndices = Object.keys(candidates).map((s) => parseInt(s, 10)).filter(/* @__PURE__ */ function(startTabIndex2, reverse2) {
    return void 0 === startTabIndex2 ? (_) => true : reverse2 ? (t) => compareTabIndex(t, startTabIndex2) <= 0 : (t) => compareTabIndex(t, startTabIndex2) >= 0;
  }(startTabIndex, reverse)).sort(compareTabIndex);
  reverse && tabIndices.reverse();
  for (const tabIndex of tabIndices)
    if (tabIndex in candidates) {
      let array = ensure(candidates[tabIndex]);
      reverse && array.reverse(), tabIndex === startTabIndex && (array = array.slice(array.indexOf(afterElement) + 1));
      const candidate = findNextInArray(array, reverse);
      if (candidate)
        return candidate;
    }
  return null;
}
function findNextInArray(array, reverse) {
  for (const element of array) {
    if (!reverse && isFocusable(element))
      return element;
    if (isFocusContext(element) && !skipContainer(element)) {
      const candidate = findNextInContainer(element, reverse);
      if (candidate)
        return candidate;
    }
    if (reverse && isFocusable(element))
      return element;
  }
  return null;
}
function gatherDescendants(e, output = {}) {
  for (let i = 0; i < e.children.length; i++) {
    const child = e.children.item(i);
    if (!isHTMLElement(child))
      continue;
    const tabIndex = getEffectiveTabIndex(child);
    (output[tabIndex] = output[tabIndex] ?? []).push(child), isFocusContext(child) || gatherDescendants(child, output);
  }
  return output;
}
function compareTabIndex(a, b) {
  return a === b ? 0 : 0 === a ? 1 : 0 === b ? -1 : a - b;
}
function isFocusContext(element) {
  return element === document.body || null !== element.getAttribute("data-focusindex");
}
function getEffectiveTabIndex(element) {
  const tabIndexValue = getIntAttribute(element, "data-focusindex") ?? getTabIndex(element);
  return Math.max(0, tabIndexValue ?? 0);
}
function getTabIndex(element) {
  const tabIndex = getIntAttribute(element, "tabindex");
  return -32768 !== tabIndex ? tabIndex : null;
}
function getIntAttribute(element, attribute) {
  const value = element.getAttribute(attribute);
  return value ? parseInt(value, 10) : null;
}
function skipContainer(element) {
  return "-1" === element.getAttribute("data-focusindex");
}
function isFocusable(element) {
  return isNavigableElement(element) && function(element2) {
    return function(element3) {
      if (0 === element3.offsetWidth && 0 === element3.offsetHeight)
        return false;
      return "visible" === window.getComputedStyle(element3).visibility;
    }(element2) && function(element3) {
      return !element3.disabled;
    }(element2);
  }(element);
}
function isNavigableElement(element) {
  if (skipContainer(element))
    return false;
  return (getTabIndex(element) ?? getDefaultTabIndex(element)) >= 0;
}
function getFocusableContainer(target) {
  let element = getHTMLElement(target);
  for (; element; ) {
    if (null !== getTabIndex(element) || 0 === getDefaultTabIndex(element))
      return element;
    element = element.parentElement;
  }
  return null;
}
function getDefaultTabIndex(element) {
  switch (element.tagName.toLowerCase()) {
    case "a":
    case "area":
    case "button":
    case "input":
    case "object":
    case "select":
    case "textarea":
      return 0;
    default:
      return element.getAttribute("contenteditable") ? 0 : -1;
  }
}
function getHTMLElement(target) {
  return isHTMLElement(target) ? target : function(target2) {
    return "parentElement" in target2;
  }(target) ? target.parentElement : null;
}
function isHTMLElement(target) {
  return "offsetParent" in target;
}
function moveFocusTo(node) {
  isMobileDevice() ? function() {
    const current = getFocus();
    current && current.blur();
  }() : setFocus(node);
}

async function cancelChanges(config, { currentForm }) {
  currentForm.setSuspend(true);
  try {
    await methodToPromise(currentForm, "publish", "rollback");
    const objectsToRollback = currentForm.getSubmitObjects();
    mx.isOffline() ? await new Promise((resolve, reject) => getData().rollback({ mxobjs: objectsToRollback, callback: resolve, error: reject })) : await onlineData().executeObjectAction(config.operationId, "rollback", objectsToRollback), config.closePage && await methodToPromise(currentForm, "close");
  } finally {
    currentForm.setSuspend(false);
  }
}

const compute = Symbol("compute");
function isComputation(value) {
  return "object" == typeof value && null != value?.[compute];
}
function processComputation(computation, store, widgetId, propertyPath) {
  return computation[compute](store, widgetId, propertyPath);
}
const result = Symbol("result");
function isComputationResult(value) {
  return "object" == typeof value && null != value?.[result];
}
function toValue(computationResult) {
  return computationResult[result];
}
function asResult(value) {
  return { [result]: value };
}
function asProperty(func) {
  return (c) => ({ [compute]: (s, w, p) => {
    const funcResult = func(c, s, w, p);
    return Array.isArray(funcResult) ? funcResult : [funcResult, void 0];
  } });
}

const ErrorBoundaryFallbackContext = reactExports.createContext(() => null);
let ErrorBoundary$1 = class ErrorBoundary extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = { hasError: false };
  }
  render() {
    return this.state.hasError ? jsxRuntimeExports.jsx(ErrorBoundaryFallbackContext.Consumer, { children: (fallbackComponent) => reactExports.createElement(fallbackComponent, { errorMessage: `Could not render widget '${this.props.widgetId}'` }) }) : this.props.children;
  }
  static getDerivedStateFromError() {
    return { hasError: true };
  }
};
const typeCache = /* @__PURE__ */ new Map();
function asPluginWidgets(componentMap) {
  const result = {};
  return Object.entries(componentMap).forEach(([key, wrappedComponent]) => {
    result["$" + key] = asPluginWidget(wrappedComponent);
  }), result;
}
const WidgetIdContext = reactExports.createContext("not a widget");
function asPluginWidget(wrappedComponent) {
  const cachedResult = typeCache.get(wrappedComponent);
  if (void 0 !== cachedResult)
    return cachedResult;
  const componentName = friendlyName(wrappedComponent), uncachedComponent = function(wrappedComponent2, componentName2) {
    const MemoisedComponent = reactExports.memo(function(component, componentName3) {
      if (component.prototype?.isReactComponent) {
        const FunctionalWrapper = (props) => reactExports.createElement(component, props);
        return FunctionalWrapper.displayName = componentName3, FunctionalWrapper;
      }
      return component.displayName = componentName3, component;
    }(wrappedComponent2, componentName2));
    return (wrapperProps) => {
      const [correctWidgetId] = reactExports.useState(() => wrapperProps.$widgetId);
      if (wrapperProps.$widgetId !== correctWidgetId || void 0 === correctWidgetId)
        throw new AssertionError(`Parent of component ${componentName2} did not correctly assign keys.`);
      const store = useComponentStore(), [formSuspended$] = store.useSlot(pageScope, "formSuspended"), [mappedProps, onAfterUpdates] = reactExports.useMemo(() => mapWrapperProps(wrapperProps, store, wrapperProps.$widgetId, ""), []);
      let disposer;
      const [computedProps, setComputedProps] = reactExports.useState(() => {
        if (!isDependable(mappedProps))
          return mappedProps;
        let firstRun = true, initialComputedProps = {};
        return disposer = autorun(() => {
          const props = mappedProps.dependOn(), suspended = formSuspended$.dependOn();
          firstRun ? initialComputedProps = props : suspended || setComputedProps(props);
        }, { name: `Props of ${wrapperProps.$widgetId}` }), firstRun = false, initialComputedProps;
      });
      return reactExports.useLayoutEffect(() => disposer, []), onAfterUpdates.length && reactExports.useLayoutEffect(() => onAfterUpdates.forEach((l) => l()), [computedProps]), jsxRuntimeExports.jsx(WidgetIdContext.Provider, { value: correctWidgetId, children: jsxRuntimeExports.jsx(ErrorBoundary$1, { widgetId: toFriendlyId(correctWidgetId), children: jsxRuntimeExports.jsx(SubscriptionPriorityContext.Provider, { value: reactExports.useContext(SubscriptionPriorityContext) + 1, children: jsxRuntimeExports.jsx(MemoisedComponent, { ...computedProps }) }) }) });
    };
  }(wrappedComponent, componentName);
  return uncachedComponent.displayName = `pluginWidget(${componentName})`, typeCache.set(wrappedComponent, uncachedComponent), uncachedComponent;
}
function mapWrapperProps(value, store, widgetId, propPath) {
  const mappedEntries = Object.entries(value).map(([key, valueItem]) => "$widgetId" === key ? tuple("name", tuple(toWidgetName(widgetId), [])) : tuple(key, mapWrapperProp(valueItem, store, widgetId, `${propPath}/${key}`)));
  return [mappedEntries.some(([_, [mappedItem]]) => isDependable(mappedItem)) ? fromComputation$(`Prop ${propPath || "root"} of ${widgetId}`, () => Object.fromEntries(mappedEntries.map(([key, [mappedItem]]) => [key, isDependable(mappedItem) ? mappedItem.dependOn() : mappedItem]))) : Object.fromEntries(mappedEntries.map(([key, [mappedItem]]) => [key, mappedItem])), mappedEntries.flatMap(([, [, onAfterUpdate]]) => onAfterUpdate)];
}
function mapWrapperProp(value, store, widgetId, propPath) {
  if (isComputationResult(value))
    return [toValue(value), []];
  if (isComputation(value)) {
    const [dependable, onAfterUpdate] = processComputation(value, store, widgetId, propPath);
    return [dependable, onAfterUpdate ? [onAfterUpdate] : []];
  }
  if (Array.isArray(value)) {
    if (reactExports.isValidElement(value[0]) || function(array) {
      return 0 === array.length || array.every((e) => null === e || "object" != typeof e);
    }(value))
      return [value, []];
    const mappedItems = value.map((valueItem, index) => mapWrapperProp(valueItem, store, widgetId, `${propPath}/${index}`));
    return [mappedItems.some(([mappedItem]) => isDependable(mappedItem)) ? fromComputation$(`Prop ${propPath} of ${widgetId}`, () => mappedItems.map(([mappedItem]) => isDependable(mappedItem) ? mappedItem.dependOn() : mappedItem)) : mappedItems.map(([mappedItem]) => mappedItem), mappedItems.flatMap(([_, onAfterUpdate]) => onAfterUpdate)];
  }
  return !reactExports.isValidElement(value) && isJson(value) ? mapWrapperProps(value, store, widgetId, propPath) : [value, []];
}

const MAIN_PLACEHOLDER_NAME = "Main", PlaceholderProperty = asProperty((config, store, widgetId) => {
  const [form$] = store.useSlot(pageScope, "form");
  return fromComputation$(`Content of ${widgetId}`, () => {
    const form = ensure(form$.dependOn())[0], placeholderContent = form.getPlaceholderContent(config.id);
    return "function" == typeof placeholderContent ? placeholderContent(form.getHistoryId()) : placeholderContent;
  });
});

const Fragment = (props) => jsxRuntimeExports.jsx(reactExports.Fragment, { children: props.content });

class ActionRegistry {
  constructor() {
    this.handlers = {};
  }
  registerHandler(id, callback) {
    this.handlers[id] = callback;
  }
  unregisterHandler(id) {
    delete this.handlers[id];
  }
  getHandler(id) {
    return this.handlers[id];
  }
}
const ActionContext = n.createContext(void 0);

async function commit({ objects }) {
  return new Promise((resolve, reject) => {
    getData().commit({ mxobjs: objects, callback: resolve, error: reject });
  });
}
async function create({ entity }) {
  return new Promise((resolve, reject) => getData().create({ entity, callback: resolve, error: reject }));
}
async function retrieveByGuids({ guids }) {
  return new Promise((resolve, reject) => getData().get({ guids, callback: resolve, error: reject }));
}
async function retrieveByXPath({ xpath, filter, returnCount = false }) {
  return new Promise((resolve, reject) => getData().get({ xpath, filter, count: returnCount, callback: (objects, { count }) => {
    returnCount && resolve([objects, count]), resolve(objects);
  }, error: reject }));
}
async function retrieveByPath({ path, guid, entity, direction = "reverse" }) {
  return new Promise((resolve, reject) => getData().get({ path, guid, entity, direction, callback: resolve, error: reject }));
}
async function retrieveByEntity({ entity, filter, queryFilter }) {
  if (queryFilter) {
    const { mxObjects } = await offlineData().retrieveUncached(entity, queryFilter, filter ?? {});
    return mxObjects;
  }
  return new Promise((resolve, reject) => getData().get({ entity, filter, callback: resolve, error: reject }));
}
async function remove({ guids }) {
  return new Promise((resolve, reject) => getData().remove({ guids, callback: resolve, error: reject }));
}
async function rollback({ objects }) {
  return new Promise((resolve, reject) => getData().rollback({ mxobjs: objects, callback: resolve, error: reject }));
}
function subscribe(params, scope) {
  return getData().subscribe(params, scope);
}
function unsubscribe(handle) {
  getData().unsubscribe(handle);
}
async function update(params) {
  return new Promise((resolve, reject) => {
    try {
      publish(params), resolve();
    } catch (error) {
      reject(error);
    }
  });
}
var dataModule = Object.freeze({ __proto__: null, commit, create, remove, retrieveByEntity, retrieveByGuids, retrieveByPath, retrieveByXPath, rollback, subscribe, unsubscribe, update });

function getUserId() {
  return getSession().getUserId();
}
function getUserName() {
  return getSession().getUserObject().get2("Name");
}
function getUserRoleNames() {
  return getSession().getUserRoleNames();
}
function isGuest() {
  return getSession().isGuest();
}
var sessionModule = Object.freeze({ __proto__: null, getUserId, getUserName, getUserRoleNames, isGuest });

async function back() {
  await getUI().back();
}
async function confirmation({ content, okText = translate("mxui.widget.DialogMessage", "ok"), cancelText = translate("mxui.widget.DialogMessage", "cancel") }) {
  return new Promise((resolve) => {
    getUI().confirmation({ content, proceed: okText, cancel: cancelText, handler: () => resolve(true), onCancel: () => resolve(false) });
  });
}
function showDialog({ type, content, isModal = false }) {
  getUI().showMessage(type, content, isModal);
}
async function showLogin({ messageCode } = {}) {
  await getUI().showLogin(messageCode);
}
function showProgress({ content, isModal } = {}) {
  return new Big(getUI().showProgress(content, isModal));
}
function hideProgress({ progressId }) {
  getUI().hideProgress(progressId.toNumber());
}
var uiModule = Object.freeze({ __proto__: null, back, confirmation, hideProgress, showDialog, showLogin, showProgress });

const homeUrl = window.location.origin + window.location.pathname, baseUrl = homeUrl.slice(0, homeUrl.lastIndexOf("/") + 1), baseUrlPath = window.location.pathname.replace("/index.html", "");
function getPathFromHash() {
  const hash = window.location.hash.slice(1);
  return hash.startsWith("/") ? hash : null;
}
function reload() {
  redirect(homeUrl);
}
function setupBaseTag(url = baseUrl) {
  const baseElement = document.createElement("base");
  baseElement.href = url, document.getElementsByTagName("head")[0]?.appendChild(baseElement);
}
function redirect(location2) {
  /^(https?|file):\/\//.test(location2) || location2.startsWith("/") || (location2 = baseUrl + location2);
  const parsedLocation = queryString.parseUrl(location2), search = queryString.stringify({ ...parsedLocation.query, ...queryString.parse(window.location.search) }), href = parsedLocation.url + ("" !== search ? `?${search}` : "") + window.location.hash;
  window.location.href === href ? window.location.reload() : window.location.assign(href);
}
const data = dataModule, session = sessionModule, ui = uiModule;
function getAppUrl() {
  return appUrl ?? baseUrl;
}
async function logout() {
  await getSession().logout(), await new Promise((resolve) => getData().clear(resolve)), reload();
}
async function login$1({ username, password, useAuthToken, reloadOnSuccess = true }) {
  if (await getSession().login({ username, password, useAuthToken }), afterLoginAction)
    await afterLoginAction();
  else if (reloadOnSuccess) {
    const urlParams = new URLSearchParams(location.search);
    if (urlParams.has("c")) {
      const url = new URL(location.href);
      url.pathname = decodeURIComponent(urlParams.get("c")), urlParams.delete("c"), url.search = urlParams.toString(), location.href = url.toString();
    } else
      reload();
  }
}
let appUrl, afterLoginAction;
const setAfterLoginAction = (a) => {
  afterLoginAction = a;
}, setAppUrl = (a) => {
  appUrl = a;
};

var FormatterType;
!function(FormatterType2) {
  FormatterType2.Number = "number", FormatterType2.DateTime = "datetime";
}(FormatterType || (FormatterType = {}));

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _state, _releasers, _pending, _apply, apply_fn, _lock, lock_fn, _unlock, unlock_fn, _db, _dbReady, _txOptions, _tx, _txTimestamp, _runChain, _putChain, _run, run_fn, _objectStore, _index, _options, _mapIdToFile, _idb, _pendingPurges, _taskTimestamp, _pendingAsync, _growthHandler, _xWriteHelper, xWriteHelper_fn, _xSyncHelper, xSyncHelper_fn, _maybePurge, maybePurge_fn, _bound, bound_fn, _reblockIfNeeded, reblockIfNeeded_fn;
const styleDeclarationProto = Object.getPrototypeOf(document.body.style), originalSetProperty = styleDeclarationProto.setProperty;
var createRoot;
styleDeclarationProto.setProperty = function(name, value, priority) {
  name.startsWith("--mx-important-") && (name = name.replace("--mx-important-", ""), priority = "important"), originalSetProperty.call(this, name, value, priority ?? "");
};
var m = reactDomExports;
createRoot = m.createRoot, m.hydrateRoot;
const DemoUserSwitcher = ({ activeDemoUser, demoUsers, onSelectUser }) => {
  const [isVisible, setIsVisible] = reactExports.useState(false);
  return jsxRuntimeExports.jsxs("div", { className: "mx-demouserswitcher", style: { right: isVisible ? "0px" : "-360px", transition: "right 0.3s" }, children: [jsxRuntimeExports.jsx("div", { className: "mx-demouserswitcher-toggle", onClick: () => setIsVisible(!isVisible) }), jsxRuntimeExports.jsxs("div", { className: "mx-demouserswitcher-content", children: [jsxRuntimeExports.jsx("h2", { children: "Select user" }), jsxRuntimeExports.jsx("p", { children: "Select one of the demo users to view the application with the associated user roles." }), jsxRuntimeExports.jsx("ul", { children: demoUsers.map((user) => jsxRuntimeExports.jsx("li", { className: activeDemoUser === user.name ? "active" : "", onClick: () => onSelectUser(user), style: { cursor: "pointer" }, children: jsxRuntimeExports.jsxs("a", { children: [jsxRuntimeExports.jsx("h3", { children: user.name }), jsxRuntimeExports.jsx("p", { children: user.roles.join(", ") })] }) }, user.name)) })] })] });
};
class ErrorBoundary extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = { hasError: false };
  }
  render() {
    return this.state.hasError ? jsxRuntimeExports.jsx("div", { children: "Something went wrong" }) : this.props.children;
  }
  static getDerivedStateFromError() {
    return { hasError: true };
  }
}
function serializeFilterToViewState(expr) {
  return void 0 !== expr ? function serialize(e) {
    return "literal" === e.type ? function(e2) {
      switch (e2.valueType) {
        case "DateTime":
          return serializedLiteral(e2.valueType, e2.value.getTime());
        case "Numeric":
          return serializedLiteral(e2.valueType, e2.value.toString());
        case "Reference":
        case "ReferenceSet":
          const dataSourceId = e2[dataSourceIdSymbol$1];
          return serializedLiteral(e2.valueType, e2.value, { dataSourceId });
        default:
          return serializedLiteral(e2.valueType, e2.value);
      }
    }(e) : mapValues(e, (v) => Array.isArray(v) ? v.map(serialize) : "object" == typeof v ? serialize(v) : v);
  }(expr) : void 0;
}
function deserializeFilterFromViewState(expr) {
  return void 0 !== expr ? function deserialize(e) {
    const result = "literal" === e.type ? function(e2) {
      switch (e2.valueType) {
        case "DateTime":
          return literal(new Date(e2.value));
        case "Numeric":
          return literal(new Big(e2.value));
        case "Reference":
        case "ReferenceSet":
          return freezeExpression({ type: "literal", value: e2.value, valueType: e2.valueType, [dataSourceIdSymbol$1]: e2.dataSourceId });
        default:
          return literal(e2.value);
      }
    }(e) : mapValues(e, (v) => Array.isArray(v) ? Object.freeze(v.map(deserialize)) : "object" == typeof v ? deserialize(v) : v);
    return freezeExpression(result);
  }(expr) : void 0;
}
function serializedLiteral(valueType, value, extra) {
  return { type: "literal", value, valueType, ...extra };
}
const slotsNotToPersist = ["form", "formSuspended", "object", "editableObject", "isInvalid", "validationRequest", "subtreeReadonly", "uniqueId", "firstLoadDone"], slotPatternsNotToPersist = [/^.*\/items$/];
function shouldPersistSlot(slot) {
  return !slotsNotToPersist.includes(slot) && !slotPatternsNotToPersist.some((p) => p.test(slot));
}
function applyViewState(viewState, storeBackend) {
  viewState.forEach(({ slot, widgetId, values }) => values.forEach(([namespace, value]) => storeBackend.set(widgetId, slot, namespace, function(slot2, value2) {
    return slot2.endsWith("/filter") ? deserializeFilterFromViewState(value2) : value2;
  }(slot, value))));
}
let closePopupHandler, popups = [], popupIndex = 0, messageIndex = 0, loginDialogIndex = 0;
function addId(id) {
  popups.push(id);
}
const logger$1 = LogManager.get().getLogger(), stack = [];
let index = -1, isNavigatingBack = false, replaceHome = false, closePageUpdateSuspended = false;
const viewStates = {}, formParameterLocks = [];
const getIndex = () => index, setIsNavigatingBack = (value) => isNavigatingBack = value, setReplaceHome = (value) => replaceHome = value, setClosePageUpdateSuspended = (value) => closePageUpdateSuspended = value;
function add(...ids) {
  stack.splice(index + 1).forEach((removedItem) => {
    delete viewStates[removedItem];
  });
  for (const id of ids)
    index++, stack[index] = id;
  for (; Object.keys(viewStates).length > 50; ) {
    const item = stack.find((value) => viewStates[value]);
    if (void 0 === item) {
      logger$1.warn("viewStates cleanup has failed");
      break;
    }
    delete viewStates[item];
  }
}
let resolveCloseForm, closeFormPromise;
const getResolveCloseForm = () => resolveCloseForm;
async function closeForm(numberOfFormsToClose = 1, replaceHome2, suspendClosePageUpdate) {
  if (replaceHome2 && 1 === numberOfFormsToClose && 0 === getIndex())
    setReplaceHome(true);
  else {
    const numberOfPagesToMoveBack = Math.min(getIndex(), numberOfFormsToClose);
    numberOfPagesToMoveBack > 0 && (setIsNavigatingBack(true), index -= numberOfPagesToMoveBack, suspendClosePageUpdate && setClosePageUpdateSuspended(true), window.history.go(-numberOfPagesToMoveBack), closeFormPromise = new Promise((resolve) => resolveCloseForm = resolve), await closeFormPromise);
  }
}
class WebForm extends FormWithStore {
  async closePage(numberOfPagesToClose, replaceHome2, suspendClosePageUpdate) {
    await closeForm(numberOfPagesToClose, replaceHome2, suspendClosePageUpdate);
  }
}
class PopupForm extends WebForm {
  async closePage(numberOfPagesToClose = 1, replaceHome2, suspendClosePageUpdate) {
    const pagesLeftToClose = function(activeId, totalNumberOfFormsToClose = 1) {
      if (void 0 === closePopupHandler)
        return totalNumberOfFormsToClose;
      const otherPopups = popups.filter((p) => p !== activeId), numberOfPopupsToClose = Math.min(totalNumberOfFormsToClose - 1, otherPopups.length), closedPopups = numberOfPopupsToClose > 0 ? otherPopups.slice(-numberOfPopupsToClose) : [];
      return popups = otherPopups.slice(0, otherPopups.length - numberOfPopupsToClose), closePopupHandler([activeId, ...closedPopups]), totalNumberOfFormsToClose - (numberOfPopupsToClose + 1);
    }(this.getHistoryId(), numberOfPagesToClose);
    pagesLeftToClose > 0 && await super.closePage(pagesLeftToClose, replaceHome2, suspendClosePageUpdate);
  }
}
function observeFirstLoadDone(storeBackend, callback) {
  const firstLoadDoneEntries$ = storeBackend.getAllEntries$("firstLoadDone");
  return reaction(() => firstLoadDoneEntries$.dependOn(), (firstLoadDoneEntries) => {
    firstLoadDoneEntries.every((o) => true === o.value) && setTimeout(callback, 0);
  }, { fireImmediately: true });
}
const style = { height: "100%", display: "flex", flexDirection: "column" }, ModalContent = ({ className, children, onSubmit }) => onSubmit ? jsxRuntimeExports.jsx("form", { className, style, onSubmit, children }) : jsxRuntimeExports.jsx("div", { className, style, children });
let items = [];
const ModalHeader = ({ titleId, title, active: active2, className, isDialog, showCloseButton, onDrag, onDrop, onClose, onFullscreenToggle }) => {
  const lastPosition = reactExports.useRef({ x: 0, y: 0 }), [dragging, setDragging] = reactExports.useState(false), [mousePressed, setMousePressed] = reactExports.useState(false), onMouseUp = reactExports.useCallback((event) => {
    dragging && (setDragging(false), onDrop()), setMousePressed(false), event.stopPropagation();
  }, [onDrop, dragging]), onMouseMove = reactExports.useCallback((event) => {
    if (dragging) {
      const top = event.clientY - lastPosition.current.y, left = event.clientX - lastPosition.current.x;
      onDrag(top, left, event.clientX), lastPosition.current = { x: event.clientX, y: event.clientY }, event.stopPropagation(), event.preventDefault();
    } else if (mousePressed) {
      const absoluteMovement = { x: Math.abs(event.clientX - lastPosition.current.x), y: Math.abs(event.clientY - lastPosition.current.y) };
      Math.sqrt(absoluteMovement.x ** 2 + absoluteMovement.y ** 2) > 5 && (setDragging(true), setMousePressed(false), lastPosition.current = { x: event.clientX, y: event.clientY });
    }
  }, [dragging, mousePressed, lastPosition, onDrag]);
  return reactExports.useEffect(() => {
    if (active2)
      return document.addEventListener("mouseup", onMouseUp), () => {
        document.removeEventListener("mouseup", onMouseUp);
      };
  }, [active2, onMouseUp]), reactExports.useEffect(() => {
    if (active2 && (mousePressed || dragging))
      return document.addEventListener("mousemove", onMouseMove), () => {
        document.removeEventListener("mousemove", onMouseMove);
      };
  }, [active2, mousePressed, onMouseMove, dragging]), jsxRuntimeExports.jsxs("div", { className, style: { userSelect: "none", flex: "0 0 auto" }, onMouseDown: (event) => {
    0 === event.button && (setMousePressed(true), lastPosition.current = { x: event.clientX, y: event.clientY });
  }, onDoubleClick: (event) => {
    onFullscreenToggle(), event.stopPropagation();
  }, children: [showCloseButton && jsxRuntimeExports.jsx("button", { type: "button", className: classNames("close", { "mx-dialog-close": isDialog }), title: translate("mxui.widget.Window", "close"), "aria-label": translate("mxui.widget.Window", "close"), onClick: onClose, children: "\xD7" }), jsxRuntimeExports.jsx("h4", { id: titleId, className: classNames({ "caption mx-dialog-caption": isDialog }), children: title })] });
};
var ResizeMode;
!function(ResizeMode2) {
  ResizeMode2[ResizeMode2.NORTH = 0] = "NORTH", ResizeMode2[ResizeMode2.EAST = 1] = "EAST", ResizeMode2[ResizeMode2.SOUTH = 2] = "SOUTH", ResizeMode2[ResizeMode2.WEST = 3] = "WEST", ResizeMode2[ResizeMode2.NORTHEAST = 4] = "NORTHEAST", ResizeMode2[ResizeMode2.NORTHWEST = 5] = "NORTHWEST", ResizeMode2[ResizeMode2.SOUTHEAST = 6] = "SOUTHEAST", ResizeMode2[ResizeMode2.SOUTHWEST = 7] = "SOUTHWEST";
}(ResizeMode || (ResizeMode = {}));
const resizeDirections = [{ mode: ResizeMode.NORTH, cssClass: "mx-resizer-n" }, { mode: ResizeMode.EAST, cssClass: "mx-resizer-e" }, { mode: ResizeMode.SOUTH, cssClass: "mx-resizer-s" }, { mode: ResizeMode.WEST, cssClass: "mx-resizer-w" }, { mode: ResizeMode.NORTHEAST, cssClass: "mx-resizer-ne" }, { mode: ResizeMode.SOUTHEAST, cssClass: "mx-resizer-se" }, { mode: ResizeMode.SOUTHWEST, cssClass: "mx-resizer-sw" }, { mode: ResizeMode.NORTHWEST, cssClass: "mx-resizer-nw" }];
function getValidMousePosition(positionX, positionY, deadZoneSize) {
  return (positionX < deadZoneSize || positionX > window.innerWidth - deadZoneSize) && (positionX = positionX < deadZoneSize ? deadZoneSize : window.innerWidth - deadZoneSize), (positionY < deadZoneSize || positionY > window.innerHeight - deadZoneSize) && (positionY = positionY < deadZoneSize ? deadZoneSize : window.innerHeight - deadZoneSize), { x: positionX, y: positionY };
}
function ModalResizer({ onResize, onResizeEnd }) {
  const [resizing, setResizing] = reactExports.useState(false), resizeMode = reactExports.useRef(), lastPosition = reactExports.useRef({ x: 0, y: 0 }), onMouseUp = (event) => {
    setResizing(false), event.stopPropagation(), onResizeEnd();
  }, onMouseMove = reactExports.useCallback((event) => {
    if (!resizing)
      return;
    let deltaWidth = 0, deltaHeight = 0, deltaTop = 0, deltaLeft = 0;
    const mousePosition = getValidMousePosition(event.clientX, event.clientY, 20);
    resizeMode.current === ResizeMode.EAST || resizeMode.current === ResizeMode.NORTHEAST || resizeMode.current === ResizeMode.SOUTHEAST ? deltaWidth = mousePosition.x - lastPosition.current.x : resizeMode.current !== ResizeMode.WEST && resizeMode.current !== ResizeMode.NORTHWEST && resizeMode.current !== ResizeMode.SOUTHWEST || (deltaWidth = lastPosition.current.x - mousePosition.x, deltaLeft = -deltaWidth), resizeMode.current === ResizeMode.SOUTH || resizeMode.current === ResizeMode.SOUTHWEST || resizeMode.current === ResizeMode.SOUTHEAST ? deltaHeight = mousePosition.y - lastPosition.current.y : resizeMode.current !== ResizeMode.NORTH && resizeMode.current !== ResizeMode.NORTHWEST && resizeMode.current !== ResizeMode.NORTHEAST || (deltaHeight = lastPosition.current.y - mousePosition.y, deltaTop = -deltaHeight), lastPosition.current = { x: mousePosition.x, y: mousePosition.y }, 0 === deltaWidth && 0 === deltaHeight || onResize({ deltaWidth, deltaHeight, deltaTop, deltaLeft }), event.stopPropagation(), event.preventDefault();
  }, [resizing, onResize]);
  return reactExports.useEffect(() => {
    if (resizing)
      return document.addEventListener("mouseup", onMouseUp), document.addEventListener("mousemove", onMouseMove), () => {
        document.removeEventListener("mouseup", onMouseUp), document.removeEventListener("mousemove", onMouseMove);
      };
  }, [onMouseMove, resizing]), jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: resizeDirections.map((direction) => jsxRuntimeExports.jsx("div", { className: classNames("mx-resizer", direction.cssClass), onMouseDown: (event) => ((event2, mode) => {
    if (0 !== event2.button)
      return;
    resizeMode.current = mode;
    const mousePosition = getValidMousePosition(event2.clientX, event2.clientY, 20);
    lastPosition.current = { x: mousePosition.x, y: mousePosition.y }, setResizing(true), event2.preventDefault(), event2.stopPropagation();
  })(event, direction.mode), style: { userSelect: "none" } }, direction.mode)) });
}
function getValidPosition(modal) {
  let { left, top } = modal;
  const { width, height } = modal;
  if (!width || !height)
    return { left, top };
  const exceedsLimitLeft = modal.left < 20, exceedsLimitTop = modal.top < 20, exceedsLimitRight = modal.left + width > window.innerWidth - 20, exceedsLimitBottom = modal.top + height > window.innerHeight - 20, exceedsMaxWidth = window.innerWidth - 20 < width, exceedsMaxHeight = window.innerHeight - 20 < height;
  return exceedsLimitLeft || exceedsMaxWidth ? left = 20 : exceedsLimitRight && (left = window.innerWidth - width - 20), exceedsLimitTop || exceedsMaxHeight ? top = 20 : exceedsLimitBottom && (top = window.innerHeight - height - 20), { top, left };
}
function getDefaultTop(height) {
  return Math.max(20, 0.7 * (window.innerHeight / 2 - height / 2));
}
function getDefaultLeft(width) {
  return Math.max(20, window.innerWidth / 2 - width / 2);
}
function getMaxHeight() {
  return window.innerHeight - 40;
}
function getMaxWidth() {
  return window.innerWidth - 40;
}
function adjustSizeToLimits(state, minWidth = 300, minHeight = 200) {
  const newState = { ...state }, maxWidth = getMaxWidth(), maxHeight = getMaxHeight();
  newState.height && (newState.height > maxHeight ? newState.height = maxHeight : newState.height < minHeight && (newState.height = minHeight)), newState.width && (newState.width > maxWidth ? newState.width = maxWidth : newState.width < minWidth && (newState.width = minWidth));
  const position = newState.width && newState.height ? getValidPosition(newState) : { top: newState.top, left: newState.left };
  return { ...newState, ...position };
}
function getFullscreenState() {
  return { width: getMaxWidth(), height: getMaxHeight(), top: 20, left: 20 };
}
let observer, showMessageHandler, hideMessageHandler, showProgressHandler, hideProgressHandler, hideAllProgressHandler, showLoginHandler;
function Modal({ widgetId, initWidth, initHeight, initOffset, resizable, onFocus, onDrop, title, onClose, zIndex, isActive, isModal, isDialog, showCloseButton, children, className, style: style2, footer, onSubmit, form, preferUnderlyingModalOverLastFocusedElement }) {
  const modalRef = reactExports.useRef(null), modalBodyRef = reactExports.useRef(null), lastManualModalState = reactExports.useRef(), [modalState, setModalState] = reactExports.useState({ width: initWidth, height: initHeight, top: 0, left: 0 }), lastModalWidth = reactExports.useRef(), [isFullscreen, setIsFullscreen] = reactExports.useState(false), [minWidth, setMinWidth] = reactExports.useState(300), [minHeight, setMinHeight] = reactExports.useState(200);
  reactExports.useEffect(() => {
    function handleWindowResize() {
      if (observer.disconnect(), modalRef.current && lastManualModalState.current) {
        const { width, height } = modalRef.current.getBoundingClientRect();
        lastManualModalState.current.width && lastManualModalState.current.height || (lastManualModalState.current = { ...lastManualModalState.current, width, height });
        const newState = isFullscreen ? getFullscreenState() : adjustSizeToLimits(lastManualModalState.current, minWidth, minHeight);
        setModalState(newState);
      }
    }
    return window.addEventListener("resize", handleWindowResize), () => {
      window.removeEventListener("resize", handleWindowResize);
    };
  }, [isFullscreen, minWidth, minHeight]), reactExports.useEffect(() => (observer = new ResizeObserver(() => {
    window.requestAnimationFrame(() => {
      !function() {
        if (modalRef.current && lastManualModalState.current) {
          const maxHeight = getMaxHeight(), rect = modalRef.current.getBoundingClientRect();
          if (rect.height + rect.top - 20 > maxHeight) {
            let newState;
            rect.height < maxHeight ? newState = { ...lastManualModalState.current, top: maxHeight - rect.height + 20 + initOffset } : (observer.disconnect(), newState = { ...lastManualModalState.current, top: 20, height: maxHeight }), lastManualModalState.current = newState, setModalState(newState);
          }
        }
      }();
    });
  }), modalRef.current && observer.observe(modalRef.current), () => {
    observer.disconnect();
  }), [initOffset]);
  const handleDrop = reactExports.useCallback(() => {
    if (modalRef.current) {
      const { width, height } = modalRef.current.getBoundingClientRect();
      lastManualModalState.current = { ...modalState, ...getValidPosition({ top: modalState.top, left: modalState.left, width, height }) }, setModalState(lastManualModalState.current);
    }
    onDrop && onDrop();
  }, [modalState, onDrop]), handleResize = reactExports.useCallback(({ deltaWidth, deltaHeight, deltaTop, deltaLeft }) => {
    if (resizable && modalRef.current) {
      observer.disconnect();
      const { offsetWidth, offsetHeight } = modalRef.current, newState = adjustSizeToLimits({ height: offsetHeight + deltaHeight, width: offsetWidth + deltaWidth, top: modalState.top + deltaTop, left: modalState.left + deltaLeft }, minWidth, minHeight);
      lastManualModalState.current = newState, setModalState(newState), setIsFullscreen(false);
    }
  }, [resizable, modalState, minWidth, minHeight]), setMinSize = reactExports.useCallback(() => {
    if (modalRef.current) {
      const { clientWidth, clientHeight } = modalRef.current, borders = function(node) {
        const { offsetHeight, offsetWidth, clientHeight: clientHeight2, clientWidth: clientWidth2 } = node;
        return { x: offsetWidth - clientWidth2, y: offsetHeight - clientHeight2 };
      }(modalRef.current), fullWidth = clientWidth + borders.x, fullHeight = clientHeight + borders.y, newMinWidth = fullWidth > 300 + borders.x ? 300 + borders.x : fullWidth, newMinHeight = fullHeight > 200 + borders.y ? 200 + borders.y : fullHeight;
      setMinWidth(newMinWidth), setMinHeight(newMinHeight);
    }
  }, []), handleFullScreenToggle = reactExports.useCallback(() => {
    isFullscreen ? lastManualModalState.current && (lastModalWidth.current = void 0, setModalState(adjustSizeToLimits(lastManualModalState.current))) : (lastManualModalState.current = modalState, lastModalWidth.current = modalRef.current?.getBoundingClientRect().width, setModalState(getFullscreenState())), setIsFullscreen(!isFullscreen);
  }, [isFullscreen, modalState]);
  reactExports.useEffect(() => {
    const handleEscPress = (e) => {
      "Escape" === e.key && modalRef.current?.contains(getFocus()) && !document.body.hasAttribute(DISABLE_INTERACTION_ATTRIBUTE) && (e.stopPropagation(), e.preventDefault(), onClose());
    };
    return document.addEventListener("keydown", handleEscPress), () => {
      document.removeEventListener("keydown", handleEscPress);
    };
  }, []);
  const captionId = `${widgetId}_caption`, contentId = `${widgetId}_content`, lastfocusedElement = reactExports.useRef(getFocus());
  return reactExports.useEffect(() => {
    function focusModal() {
      if (modalBodyRef.current && modalRef.current) {
        const elementToFocus = findFirst(modalBodyRef.current) ?? findFirst(modalRef.current) ?? modalRef.current;
        moveFocusTo(elementToFocus);
      }
    }
    let firstLoadDoneReactionDisposer;
    return function(modalId, modalContentId, previousFocusedItem, preferUnderlyingModalOverLastFocusedElement2) {
      items.unshift({ modalId, modalContentId, previousFocusedItem, preferUnderlyingModalOverLastFocusedElement: preferUnderlyingModalOverLastFocusedElement2 });
    }(widgetId, contentId, lastfocusedElement.current ?? void 0, preferUnderlyingModalOverLastFocusedElement ?? false), form ? firstLoadDoneReactionDisposer = observeFirstLoadDone(form.getStoreBackend(), focusModal) : focusModal(), () => {
      setFocus(function() {
        const poppedItem = items.shift(), peekedItem = items[0];
        if (poppedItem?.preferUnderlyingModalOverLastFocusedElement && void 0 !== peekedItem && poppedItem.previousFocusedItem === peekedItem.previousFocusedItem) {
          const modal = document.getElementById(peekedItem.modalId), modalContent = document.getElementById(peekedItem.modalContentId);
          if (modal && modalContent)
            return findFirst(modalContent) ?? findFirst(modal) ?? modal;
        }
        return poppedItem?.previousFocusedItem ?? document.body;
      }()), firstLoadDoneReactionDisposer && firstLoadDoneReactionDisposer();
    };
  }, []), reactExports.useEffect(() => {
    function handleFinishOpening() {
      if (!modalRef.current || lastManualModalState.current && 0 === initOffset)
        return;
      const rect = modalRef.current.getBoundingClientRect(), height = initHeight ?? rect.height, width = initWidth ?? rect.width;
      setMinSize(), lastManualModalState.current = { height: initHeight, width: initWidth, top: getDefaultTop(height) + initOffset, left: getDefaultLeft(width) + initOffset }, height > getMaxHeight() || width > getMaxWidth() ? lastManualModalState.current = adjustSizeToLimits({ ...lastManualModalState.current, height, width }) : (lastManualModalState.current.left > getMaxWidth() - width - 20 || lastManualModalState.current.top > getMaxHeight() - height - 20) && (lastManualModalState.current = { ...getValidPosition({ ...lastManualModalState.current, height, width }), width: lastManualModalState.current.width, height: lastManualModalState.current.height }), setModalState(lastManualModalState.current);
    }
    let firstLoadDoneReactionDisposer;
    return form ? firstLoadDoneReactionDisposer = observeFirstLoadDone(form.getStoreBackend(), handleFinishOpening) : handleFinishOpening(), () => {
      firstLoadDoneReactionDisposer && firstLoadDoneReactionDisposer();
    };
  }, [initOffset]), jsxRuntimeExports.jsxs("div", { ref: modalRef, id: widgetId, className: classNames("modal-dialog", className, { "mx-window": !isDialog, "mx-dialog": isDialog, "mx-window-active": isActive && !isDialog }), style: { width: modalState.width, height: modalState.height, zIndex, top: 0 === modalState.top ? "100%" : modalState.top, left: 0 === modalState.left ? "100%" : modalState.left, ...style2 }, role: "dialog", "data-focus-capturing": isModal ? FOCUS_CAPTURING_MODAL : FOCUS_CAPTURING_NON_MODAL, "aria-modal": isModal, "aria-labelledby": captionId, "aria-describedby": contentId, tabIndex: -1, onMouseDown: onFocus, children: [jsxRuntimeExports.jsxs(ModalContent, { className: classNames("modal-content", { "mx-window-content": !isDialog, "mx-dialog-content": isDialog }), onSubmit, children: [jsxRuntimeExports.jsx(ModalHeader, { titleId: captionId, className: classNames("modal-header", { "mx-window-header": !isDialog, "mx-dialog-header": isDialog }), title, onDrag: (deltaTop, deltaLeft, mouseX) => {
    if (!isMobileDevice() && lastManualModalState.current) {
      let { top, left, width, height } = modalState;
      isFullscreen && lastModalWidth.current ? (width = lastModalWidth.current, height = lastManualModalState.current.height, top = 20, left = mouseX - width / 2, mouseX <= width + 20 ? left = 20 : mouseX >= window.innerWidth - 20 - width && (left = window.innerWidth - 20 - width), setIsFullscreen(false), setModalState(adjustSizeToLimits({ width, height, top: top + deltaTop, left: left + deltaLeft }, minWidth, minHeight))) : setModalState({ width, height, top: top + deltaTop, left: left + deltaLeft });
    }
  }, onDrop: handleDrop, onClose, active: isActive, isDialog, showCloseButton, onFullscreenToggle: handleFullScreenToggle }), jsxRuntimeExports.jsx("div", { id: contentId, className: classNames("modal-body", { "mx-window-body": !isDialog, "mx-dialog-body": isDialog }), style: { flex: "1 1 auto" }, ref: modalBodyRef, children }), footer && jsxRuntimeExports.jsx("div", { className: classNames("modal-footer", { "mx-window-footer": !isDialog, "mx-dialog-footer": isDialog }), ...isDialog && { "data-focusindex": "0" }, children: footer })] }), resizable && jsxRuntimeExports.jsx(ModalResizer, { onResize: handleResize, onResizeEnd: setMinSize })] });
}
function LoginDialog({ widgetId, messageCode, zIndex, onFocus, onClose, onError }) {
  const [username, setUsername] = reactExports.useState(""), [password, setPassword] = reactExports.useState("");
  return jsxRuntimeExports.jsxs(Modal, { widgetId, className: "mx-login", title: translateLoginMessage(messageCode ? `http${messageCode}` : "loginHeader"), footer: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("button", { className: "btn btn-primary", type: "submit", children: translateLoginMessage("loginButton") }), jsxRuntimeExports.jsx("button", { className: "btn", type: "button", onClick: onClose, children: translateLoginMessage("cancel") }), 403 === messageCode && jsxRuntimeExports.jsx("button", { className: "btn go-to-homepage", type: "button", onClick: () => location.href = window.mx.homeUrl, children: translateLoginMessage("goHomeButton") })] }), isDialog: true, initWidth: 500, initOffset: 0, resizable: true, zIndex, isActive: true, isModal: false, showCloseButton: false, onFocus, onClose, onSubmit: (e) => {
    e.preventDefault(), window.mx.login(username, password, onClose, onError);
  }, children: [jsxRuntimeExports.jsx("input", { className: "form-control", name: "username", type: "text", autoCorrect: "off", autoCapitalize: "none", placeholder: translateLoginMessage("username"), value: username, onChange: (e) => setUsername(e.target.value) }), jsxRuntimeExports.jsx("input", { className: "form-control", name: "password", type: "password", autoCorrect: "off", autoCapitalize: "none", placeholder: translateLoginMessage("password"), value: password, onChange: (e) => setPassword(e.target.value) })] });
}
function ModalFooter({ okCaption, cancelCaption, onOk, onCancel, onClose }) {
  const buttonElements = [jsxRuntimeExports.jsx("button", { className: "btn btn-primary", onClick: () => {
    onClose && onClose(), onOk && onOk();
  }, children: okCaption }, "ok")];
  return cancelCaption && buttonElements.push(jsxRuntimeExports.jsx("button", { className: "btn", onClick: () => {
    onClose && onClose(), onCancel && onCancel();
  }, children: cancelCaption }, "cancel")), jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: buttonElements });
}
function ParagraphWithNewLines({ text }) {
  return jsxRuntimeExports.jsx("p", void 0 === text ? {} : { children: text.split("\n").map((p, i, itt) => jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [p, i < itt.length - 1 && jsxRuntimeExports.jsx("br", {})] }, `${p} ${i}`)) });
}
function Progress({ zIndex, message, isModal, showDelay = 0 }) {
  const [isShowing, setIsShowing] = reactExports.useState(0 === showDelay), timeout = reactExports.useRef();
  return reactExports.useEffect(() => (clearTimeout(timeout.current), timeout.current = window.setTimeout(() => {
    setIsShowing(true);
  }, showDelay), () => window.clearTimeout(timeout.current)), [showDelay]), reactExports.useEffect(() => (isModal && document.body.setAttribute(DISABLE_INTERACTION_ATTRIBUTE, "true"), () => {
    isModal && document.body.removeAttribute(DISABLE_INTERACTION_ATTRIBUTE);
  }), [isModal]), isShowing ? jsxRuntimeExports.jsxs("div", { id: "mxui_widget_Progress_0", className: classNames("mx-progress", { "mx-progress-empty": !message }), style: { zIndex }, role: "alert", "aria-live": "assertive", "aria-busy": "true", children: [jsxRuntimeExports.jsx("div", { className: "mx-progress-message", children: message }), jsxRuntimeExports.jsx("div", { className: "mx-progress-indicator" })] }) : null;
}
const getShowMessageHandler = () => showMessageHandler, getHideMessageHandler = () => hideMessageHandler, getShowProgressHandler = () => ensure(showProgressHandler), getHideProgressHandler = () => ensure(hideProgressHandler);
function Messages({ onUpdateOverlay, overlayIsVisible }) {
  const [stack2, setStack] = reactExports.useState([]), [dialogMessages, setDialogMessages] = reactExports.useState([]), [progressMessages, setProgressMessages] = reactExports.useState([]), [loginDialog, setLoginDialog] = reactExports.useState();
  showMessageHandler = (type, message, title, isModal, controls) => {
    const id = newId(), index2 = messageIndex++;
    return setDialogMessages((prevDialogMessages) => [...prevDialogMessages, { id, index: index2, type, content: message, title, isModal, controls }]), setStack((prevStack) => [...prevStack, id]), id;
  }, showProgressHandler = (message, isModal, showDelay) => {
    const id = Date.now();
    return setProgressMessages((prevProgressMessages) => [...prevProgressMessages, { id, content: message, isModal, showDelay }]), id;
  }, hideMessageHandler = (id) => {
    setDialogMessages((prevDialogMessages) => prevDialogMessages.filter((item) => item.id !== id)), setStack((prevStack) => prevStack.filter((item) => item !== id));
  }, hideProgressHandler = (id) => setProgressMessages((prevProgressMessages) => prevProgressMessages.filter((item) => item.id !== id)), hideAllProgressHandler = () => setProgressMessages([]), showLoginHandler = (messageCode) => setLoginDialog((prevLoginDialog) => {
    if (prevLoginDialog)
      return { ...prevLoginDialog, messageCode };
    {
      const index2 = loginDialogIndex++;
      return { messageCode, index: index2, id: newId() };
    }
  });
  const focusHandler = (id) => setStack((prevStack) => {
    const lastId = prevStack[prevStack.length - 1];
    if (!lastId)
      return prevStack;
    const newStack = [...prevStack];
    return newStack[newStack.indexOf(id)] = lastId, newStack[newStack.length - 1] = id, newStack;
  }), lastProgressMessage = progressMessages[progressMessages.length - 1], progressZIndex = 1e3 + 2 * (stack2.length + 1);
  return reactExports.useEffect(() => {
    const hasBlockingMessage = dialogMessages.some((item) => item.isModal), hasBlockingProgress = progressMessages.some((item) => item.isModal), hasModal = hasBlockingMessage || hasBlockingProgress, overlayZIndex = hasBlockingProgress ? progressZIndex - 1 : 1e3 + 2 * stack2.length - 1;
    onUpdateOverlay(hasModal, stack2.length > 0 || hasBlockingProgress ? overlayZIndex : 0);
  }, [progressZIndex, stack2.length, dialogMessages, progressMessages]), reactDomExports.createPortal(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [dialogMessages.map(({ id, index: index2, type, content, title, controls, isModal }) => jsxRuntimeExports.jsx(Modal, { widgetId: `mxui_widget_DialogMessage_${index2}`, className: "confirmation" === type ? void 0 : `mx-dialog-${type}`, title, footer: jsxRuntimeExports.jsx(ModalFooter, { ...controls, onClose: () => {
    hideMessageHandler && hideMessageHandler(id);
  } }), isDialog: true, initWidth: 500, initOffset: 0, resizable: true, zIndex: 1e3 + 2 * (stack2.indexOf(id) + 1), isActive: stack2[stack2.length - 1] === id, isModal: isModal || overlayIsVisible, onFocus: () => focusHandler(id), onClose: () => {
    hideMessageHandler && hideMessageHandler(id), controls.onCancel && controls.onCancel();
  }, showCloseButton: true, children: jsxRuntimeExports.jsx(ParagraphWithNewLines, { text: content }) }, id)), loginDialog && jsxRuntimeExports.jsx(LoginDialog, { widgetId: `mxui_widget_LoginDialog_${loginDialog.index}`, messageCode: loginDialog.messageCode, zIndex: 1e3 + 2 * (stack2.indexOf(loginDialog.id) + 1), onFocus: () => focusHandler(loginDialog.id), onClose: () => setLoginDialog(void 0), onError: ({ status }) => {
    showLoginHandler(status);
  } }), lastProgressMessage && jsxRuntimeExports.jsx(Progress, { zIndex: progressZIndex, showDelay: lastProgressMessage.showDelay, message: lastProgressMessage.content, isModal: lastProgressMessage.isModal })] }), document.body);
}
const ErrorFallbackWeb = ({ errorMessage }) => jsxRuntimeExports.jsx("div", { style: { color: "red" }, children: errorMessage }), $Fragment$1 = asPluginWidget(Fragment);
function Popups({ popups: popups2, onUpdateOverlay }) {
  const [{ stack: stack2, offsets }, setPopupsState] = reactExports.useState({ stack: [], offsets: [] }), [actionRegistries] = reactExports.useState({}), activeId = stack2[stack2.length - 1];
  reactExports.useEffect(() => {
    setPopupsState((prevPopupsState) => {
      const newState = { ...prevPopupsState, stack: [...prevPopupsState.stack], offsets: [...prevPopupsState.offsets] }, deletedPopups = newState.stack.filter((old) => !popups2.some((p) => p.form.getHistoryId() === old));
      for (const popup of deletedPopups)
        newState.stack = newState.stack.filter((prevId) => prevId !== popup), newState.offsets = newState.offsets.map((offsetId) => offsetId === popup ? void 0 : offsetId), delete actionRegistries[popup];
      const addedPopups = popups2.map((p) => p.form.getHistoryId()).filter((p) => !newState.stack.includes(p));
      for (const popup of addedPopups) {
        const freeSlotIndex = newState.offsets.indexOf(void 0);
        freeSlotIndex > -1 ? newState.offsets[freeSlotIndex] = popup : newState.offsets.push(popup), newState.stack.push(popup);
      }
      return newState;
    });
  }, [popups2]);
  let hasModal = false;
  const popupElements = [];
  for (const { widgetId, cancelChangesOperationId, form, classes, style: style2, title, closeButton, width, height, resizable, modal, preferUnderlyingModalOverLastFocusedElement } of popups2) {
    const popupId = form.getHistoryId();
    modal && (hasModal = true);
    const currentOffsetIndex = offsets.indexOf(popupId), offset = -1 === currentOffsetIndex ? 0 : 20 * currentOffsetIndex, isActive = activeId === popupId, zIndex = 100 + 2 * (stack2.indexOf(popupId) + 1);
    actionRegistries[popupId] ?? (actionRegistries[popupId] = new ActionRegistry()), popupElements.push(jsxRuntimeExports.jsx(Modal, { widgetId, className: classes, style: style2, title, initWidth: width && width > 0 ? width : void 0, initHeight: height && height > 0 ? height : void 0, initOffset: hasModal ? 0 : offset, resizable: !isMobileDevice() && resizable, onClose: () => {
      const closeAction = closeButton && actionRegistries[popupId]?.getHandler(closeButton);
      closeAction ? closeAction() : cancelChanges({ operationId: cancelChangesOperationId, closePage: true }, { currentForm: form }).catch(handleError);
    }, zIndex, onFocus: () => setPopupsState((prevPopupsState) => activeId && !isActive ? { ...prevPopupsState, stack: prevPopupsState.stack.map((prevId) => prevId === popupId ? activeId : prevId === activeId ? popupId : prevId) } : prevPopupsState), onDrop: () => {
      setPopupsState((prevPopupsState) => {
        const offsetIndex = prevPopupsState.offsets.indexOf(popupId);
        if (offsetIndex > -1) {
          const newOffsets = [...prevPopupsState.offsets];
          return newOffsets[offsetIndex] = void 0, { ...prevPopupsState, offsets: newOffsets };
        }
        return prevPopupsState;
      });
    }, isActive, isModal: hasModal, showCloseButton: true, form, preferUnderlyingModalOverLastFocusedElement, children: jsxRuntimeExports.jsx(ActionContext.Provider, { value: actionRegistries[popupId], children: jsxRuntimeExports.jsx(RootStoreProvider, { backend: form.getStoreBackend(), children: jsxRuntimeExports.jsx(ErrorBoundaryFallbackContext.Provider, { value: ErrorFallbackWeb, children: jsxRuntimeExports.jsx($Fragment$1, { $widgetId: "root", content: PlaceholderProperty({ id: MAIN_PLACEHOLDER_NAME }) }) }) }) }) }, popupId));
  }
  return reactExports.useEffect(() => {
    const overlayZIndex = 100 + 2 * stack2.length - 1;
    onUpdateOverlay(hasModal, stack2.length > 0 ? overlayZIndex : 0);
  }, [hasModal, stack2.length]), reactDomExports.createPortal(jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: popupElements }), document.body);
}
const $Fragment = asPluginWidget(Fragment);
function Page({ storeBackend, classes, style: style2 }) {
  const pageRef = reactExports.useRef(null);
  return reactExports.useEffect(() => {
    observeFirstLoadDone(storeBackend, () => {
      if (pageRef.current) {
        const elementToFocus = findFirst(pageRef.current);
        elementToFocus && moveFocusTo(elementToFocus);
      }
    });
  }, []), jsxRuntimeExports.jsx(RootStoreProvider, { backend: storeBackend, children: jsxRuntimeExports.jsx(ErrorBoundaryFallbackContext.Provider, { value: ErrorFallbackWeb, children: jsxRuntimeExports.jsx("div", { ref: pageRef, style: style2, className: classNames("mx-page", classes), "data-focusindex": "0", children: jsxRuntimeExports.jsx($Fragment, { $widgetId: "root", content: PlaceholderProperty({ id: MAIN_PLACEHOLDER_NAME }) }) }) }) });
}
let openFormHandler;
const lockManager = ObjectLockManager.getInstance(), openPageQueue = [];
async function updateHistory(historyState, url, queryString2) {
  const parameterNames = Object.keys(historyState.formParameters);
  function updateHistoryUrl(updatedUrl) {
    const query = mergeQueryStrings(location.search, queryString2 ?? "");
    let newUrl = updatedUrl;
    var position, id;
    newUrl = updatedUrl && "" !== query ? joinPath(baseUrlPath, updatedUrl) + "?" + query : updatedUrl ? joinPath(baseUrlPath, updatedUrl) : "" !== query ? location.pathname + "?" + query : location.pathname, replaceHome ? (window.history.replaceState(historyState, "", newUrl), position = 0, id = historyState.id, stack[position] = id, setReplaceHome(false)) : 0 === stack.length ? (window.history.replaceState(historyState, "", newUrl), add(historyState.id)) : (window.history.pushState(historyState, "", newUrl), add(historyState.id));
  }
  url && parameterNames.length > 0 ? await async function() {
    if (void 0 === url)
      return;
    for (const parameter of parameterNames) {
      const regex = new RegExp(`\\{${parameter.replace("$", "")}/(\\w+)\\}`), attribute = regex.exec(url)?.[1];
      if (void 0 !== attribute)
        if ("Id" === attribute)
          url = url.replace(regex, historyState.formParameters[parameter] ?? "");
        else {
          if (void 0 === historyState.formParameters[parameter]) {
            url = url.replace(regex, "-");
            continue;
          }
          const mxObj = await getByGuid(historyState.formParameters[parameter]);
          if (!mxObj?.has(attribute)) {
            url = url.replace(regex, "-");
            continue;
          }
          url = url.replace(regex, mxObj.get2(attribute)?.toString() ?? "");
        }
      else
        url = url.replace(`{${parameter.replace("$", "")}}`, historyState.formParameters[parameter] ?? "");
    }
    updateHistoryUrl(url);
  }() : updateHistoryUrl(url);
}
function updateDocumentTitle(applicationTitle, pageTitle) {
  window.document.title = pageTitle ? `${applicationTitle} - ${pageTitle}` : applicationTitle;
}
function ApplyViewState({ state, storeBackend }) {
  const viewState = state.viewState;
  return reactExports.useLayoutEffect(() => {
    viewState && applyViewState(viewState, storeBackend);
  }, [viewState]), null;
}
async function importPage(name) {
  getShowProgressHandler()(void 0, void 0, 500);
  const cacheBust = getSession().getConfig("cachebust"), page = await import(`./pages/${name}.js?${cacheBust}`);
  return ensure(hideAllProgressHandler)(), page;
}
function Router({ constants, applicationTitle, onUpdateOverlay }) {
  const storeBackend = reactExports.useRef(new StoreBackend()), [state, setState] = reactExports.useState(), [popups2, setPopups] = reactExports.useState([]), pageTitle = reactExports.useRef();
  reactExports.useEffect(() => updateDocumentTitle(applicationTitle, pageTitle.current), [applicationTitle]);
  const updatePage = reactExports.useCallback((newPage, historyState, viewState) => {
    const { pageName, formParameters, id: historyId } = historyState, { classes, style: style2 } = newPage, currentViewState = function(storeBackend2) {
      const recordsToPersist = storeBackend2.getUsedSlots().filter(shouldPersistSlot).flatMap((slot) => readUntracked(storeBackend2.getAllEntries$(slot)).map((entry) => ({ ...entry, slot }))).map((record) => {
        return { ...record, value: (slot = record.slot, value = record.value, slot.endsWith("/filter") ? serializeFilterToViewState(value) : value) };
        var slot, value;
      }).filter(({ value }) => void 0 !== value);
      return groupBy(recordsToPersist, ({ slot, widgetId }) => `${slot}|${widgetId}`).map(({ values }) => {
        const { slot, widgetId } = values[0];
        return { slot, widgetId, values: values.map(({ path, value }) => tuple(path, ensure(value))) };
      });
    }(storeBackend.current);
    state && function(lockManager2, historyId2, viewState2, formParameterGuids) {
      viewStates[historyId2] = viewState2, formParameterLocks.push(lockManager2.lock(formParameterGuids)), formParameterLocks.length > 5 && formParameterLocks.shift()?.();
    }(lockManager, state.historyId, currentViewState, state.formParameterGuids);
    const newForm = new WebForm({ storeBackend: storeBackend.current, historyId, name: pageName, title: pageTitle.current ?? "", pageContent: newPage.content, formParameters }), newState = { historyId, formParameterGuids: newForm.getParameterGuids(), classes, style: style2 };
    if (viewState) {
      const widgetIdsToExclude = new Set(currentViewState.filter(({ widgetId }) => widgetId.startsWith(constants.LAYOUT_SCOPE_ID_PREFIX)).map(({ widgetId }) => widgetId));
      newState.viewState = viewState.filter(({ widgetId }) => !widgetIdsToExclude.has(widgetId));
    }
    return setState(newState), newForm;
  }, [state, constants.LAYOUT_SCOPE_ID_PREFIX]);
  return openFormHandler = async (pageName, formParameters, customTitle, currentForm, params, numberOfPagesToClose) => {
    await closeFormPromise, numberOfPagesToClose && currentForm && (setClosePageUpdateSuspended("content" === params.location), await currentForm.closePage(numberOfPagesToClose));
    const historyState = { id: newId("historyId"), pageName, formParameters, customTitle, params };
    switch (params.location) {
      case "popup":
      case "modal": {
        const newPage = await importPage(pageName);
        return function(popup, historyState2, title) {
          const { pageName: pageName2, formParameters: formParameters2 } = historyState2, newForm = new PopupForm({ storeBackend: new StoreBackend(), historyId: historyState2.id, name: pageName2, title, pageContent: popup.content, formParameters: formParameters2 });
          addId(historyState2.id);
          const { location: location2, width, height, resizable, preferUnderlyingModalOverLastFocusedElement } = historyState2.params;
          return setPopups((prevState) => [...prevState, { widgetId: "mxui_widget_Window_" + popupIndex++, form: newForm, classes: popup.classes, title, modal: "modal" === location2, style: popup.style, closeButton: popup.closeButton, cancelChangesOperationId: popup.cancelChangesOperationId, width, height, resizable: resizable ?? false, preferUnderlyingModalOverLastFocusedElement }]), newForm;
        }(newPage, historyState, customTitle ?? newPage.title);
      }
      case "content": {
        if (params.pageUpdateSuspended)
          return void openPageQueue.push(async () => {
            await updateHistory(historyState, params.url, params.queryString), pageTitle.current = customTitle, updateDocumentTitle(applicationTitle, pageTitle.current);
          });
        const newPage = await importPage(pageName);
        return openPageQueue.push(async () => {
          await updateHistory(historyState, newPage.url, params.queryString), pageTitle.current = customTitle ?? newPage.title, updateDocumentTitle(applicationTitle, pageTitle.current);
        }), await async function() {
          for (; openPageQueue.length > 0; ) {
            const callback = openPageQueue.shift();
            callback && await callback();
          }
        }(), updatePage(newPage, historyState, void 0);
      }
      default:
        return;
    }
  }, reactExports.useEffect(() => {
    function onPopState(ev) {
      const historyState = ev.state;
      historyState && (isNavigatingBack ? setIsNavigatingBack(false) : function(id) {
        const newIndex = stack.indexOf(id);
        newIndex > -1 && (index = newIndex);
      }(historyState.id), (closePageUpdateSuspended ? Promise.resolve(void 0) : importPage(historyState.pageName)).then((newPage) => {
        var historyId;
        newPage && (pageTitle.current = historyState.customTitle ?? newPage.title, updateDocumentTitle(applicationTitle, pageTitle.current), updatePage(newPage, historyState, (historyId = historyState.id, viewStates[historyId])));
      }).finally(() => {
        setClosePageUpdateSuspended(false);
        const resolveCloseForm2 = getResolveCloseForm();
        resolveCloseForm2 && resolveCloseForm2();
      }).catch((e) => {
        throw e;
      }));
    }
    return window.addEventListener("popstate", onPopState), () => window.removeEventListener("popstate", onPopState);
  }, [updatePage, applicationTitle]), reactExports.useEffect(() => (closePopupHandler = function(ids) {
    setPopups((prevState) => prevState.filter((popup) => !ids.includes(popup.form.getHistoryId())));
  }, () => {
    closePopupHandler = void 0;
  }), []), void 0 === state ? null : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(ApplyViewState, { state, storeBackend: storeBackend.current }), jsxRuntimeExports.jsx(Page, { storeBackend: storeBackend.current, classes: state.classes, style: state.style }), jsxRuntimeExports.jsx(Popups, { popups: popups2, onUpdateOverlay })] });
}
function Overlay({ zIndex }) {
  return reactDomExports.createPortal(jsxRuntimeExports.jsx("div", { className: "mx-underlay", style: { zIndex } }), document.body);
}
let showReloadNotificationHandler;
const ReloadNotification = () => {
  const [isVisible, setIsVisible] = reactExports.useState(false);
  return reactExports.useEffect(() => {
    const hideNotification = () => {
      setTimeout(() => {
        setIsVisible(false);
      }, 400);
    };
    return isVisible ? (document.addEventListener("mousemove", hideNotification), document.addEventListener("touchmove", hideNotification)) : (document.removeEventListener("mousemove", hideNotification), document.removeEventListener("touchmove", hideNotification)), () => {
      document.removeEventListener("mousemove", hideNotification), document.removeEventListener("touchmove", hideNotification);
    };
  }, [isVisible]), showReloadNotificationHandler = () => {
    setIsVisible(true);
  }, isVisible ? jsxRuntimeExports.jsx("div", { className: "mx-reload-notification", children: "App has been reloaded" }) : null;
};
class OpfsBackendBase {
  constructor(rootDir) {
    this.rootDir = rootDir;
  }
  async getDirectoryHandle(dirPath, create) {
    const root = navigator.storage.getDirectory();
    return this.toAbsolutePath(dirPath).split("/").filter((p) => "" !== p).reduce(async (dirEntry, dirName) => (await dirEntry).getDirectoryHandle(dirName, { create }), root);
  }
  async getFileHandle(filePath, create) {
    const [dirEntry, fileName] = await this.getParentHandleWithFileName(filePath, create);
    return dirEntry.getFileHandle(fileName, { create });
  }
  async getParentHandleWithFileName(path, create) {
    const paths = path.split("/").filter((p) => "" !== p), fileName = paths.pop();
    return [await this.getDirectoryHandle(paths.join("/"), create), fileName];
  }
  toAbsolutePath(filePath) {
    return filePath === this.rootDir || filePath.startsWith(this.rootDir + "/") ? filePath : this.rootDir + "/" + filePath;
  }
}
class WebWorkerClient {
  constructor(webWorker) {
    this.webWorker = webWorker, this.awaitingResponses = [], this.messageId = 0, this.webWorker.addEventListener("message", (event) => {
      const response = this.awaitingResponses[event.data.id];
      void 0 !== response ? (event.data.isSuccess && response.resolve(event.data.data), void 0 !== event.data.failure && response.reject(event.data.failure), delete this.awaitingResponses[event.data.id]) : console.error(`Could not find response for id ${event.data.id}.`);
    });
  }
  async request(message, options) {
    return new Promise((resolve, reject) => {
      this.sendMessage(message, options ?? [], resolve, reject);
    });
  }
  post(message, options) {
    this.sendMessage(message, options ?? [], () => {
    }, (e) => {
      console.error(`Error encountered while processing message: ${e}`, e);
    });
  }
  sendMessage(message, options, resolve, reject) {
    const messageId = this.messageId++;
    this.awaitingResponses[messageId] = { id: messageId, resolve, reject }, this.webWorker.postMessage({ id: messageId, data: message }, options);
  }
}
class OpfsFileBackend extends OpfsBackendBase {
  constructor(rootDir, config) {
    super(rootDir), this.opfsFileStorageWorker = new OpfsFileStorageWorkerClient(rootDir), this.downloadQueue = new AsyncTaskThrottler(async (url, filePath) => {
      if (config?.downloadFileFn)
        return new Promise((resolve, reject) => config.downloadFileFn(url, filePath, resolve, reject));
      const blob = await get(url, "blob");
      return this.storeFile(blob, filePath);
    });
  }
  async downloadFile(url, filePath) {
    await this.downloadQueue.addToQueue(url, filePath);
  }
  async listDir(dirPath) {
    try {
      const dirHandle = await this.getDirectoryHandle(dirPath);
      return (await toArray(dirHandle.values())).map((entry) => entry.name);
    } catch (e) {
      if (e instanceof DOMException && "NotFoundError" === e.name)
        return [];
      throw e;
    }
  }
  async moveDir(dirPath, newPath) {
    const srcHandle = await this.getDirectoryHandle(dirPath), [dirHandle, fileName] = await this.getParentHandleWithFileName(newPath, true);
    try {
      await srcHandle.move(dirHandle, fileName);
    } catch {
      const dirContents = await toArray(srcHandle.values());
      for (const entry of dirContents)
        "directory" === entry.kind ? await this.moveDir(`${dirPath}/${entry.name}`, `${newPath}/${entry.name}`) : await this.moveFile(`${dirPath}/${entry.name}`, `${newPath}/${entry.name}`);
      await this.removeDir(dirPath);
    }
  }
  async moveFile(filePath, newPath) {
    const srcHandle = await this.getFileHandle(filePath), [dirHandle, fileName] = await this.getParentHandleWithFileName(newPath, true);
    try {
      await srcHandle.move(dirHandle, fileName);
    } catch {
      const blob = await srcHandle.getFile();
      await this.storeFile(blob, newPath), await this.removeFile(filePath);
    }
  }
  async readFile(filePath) {
    return (await this.getFileHandle(filePath)).getFile();
  }
  async removeDir(dirPath) {
    try {
      const [dirHandle, fileName] = await this.getParentHandleWithFileName(dirPath);
      await dirHandle.removeEntry(fileName, { recursive: true });
    } catch (e) {
      if (e instanceof DOMException && "NotFoundError" === e.name)
        return;
      throw e;
    }
  }
  async removeFile(filePath) {
    try {
      const [dirHandle, fileName] = await this.getParentHandleWithFileName(filePath);
      await dirHandle.removeEntry(fileName);
    } catch (e) {
      if (e instanceof DOMException && "NotFoundError" === e.name)
        return;
      throw e;
    }
  }
  async getFileUrl(filePath) {
    const file = await this.readFile(filePath);
    return URL.createObjectURL(file);
  }
  async storeFile(data, filePath) {
    if (window.useSyncFileStorage)
      await this.opfsFileStorageWorker.storeFile(filePath, await data.arrayBuffer());
    else
      try {
        const fileHandle = await this.getFileHandle(filePath, true);
        await this.storeAsync(fileHandle, data);
      } catch {
        await this.opfsFileStorageWorker.storeFile(filePath, await data.arrayBuffer());
      }
  }
  async storeAsync(fileHandle, data) {
    const stream = await fileHandle.createWritable();
    try {
      await stream.write(data);
    } finally {
      await stream.close();
    }
  }
}
class OpfsFileStorageWorkerClient {
  constructor(rootDir) {
    this.webWorkerClient = new WebWorkerClient(new Worker(getStaticResourceUrl("mxclientsystem/offline/OpfsFileStorageWorker.js"))), this.webWorkerClient.post({ action: "init", rootDir });
  }
  async storeFile(filePath, data) {
    return this.webWorkerClient.request({ action: "storeFile", filePath, data }, [data]);
  }
}
async function toArray(asyncIterable) {
  const result = [];
  for await (const v of asyncIterable)
    result.push(v);
  return result;
}
function isBrowserWithOfflineSupport() {
  return isBrowserWithServiceWorkerSupport() && window.isSecureContext;
}
function isBrowserWithServiceWorkerSupport() {
  return !("cordova" in window) && "serviceWorker" in navigator;
}
let lastMessageId;
function errorHandler(e) {
  e instanceof Error && LogManager.get().getLogger().error(e.message, e.stack);
  const showMessageHandler2 = getShowMessageHandler(), hideMessageHandler2 = getHideMessageHandler();
  if (showMessageHandler2 && hideMessageHandler2) {
    hideMessageHandler2(lastMessageId);
    const { type, content } = translatedError(e);
    lastMessageId = showMessageHandler2(type, content, translate("mxui.widget.DialogMessage", type), true, { okCaption: translate("mxui.widget.DialogMessage", "ok") });
  }
}
class SQLiteError extends Error {
  constructor(message, code) {
    super(message), this.code = code;
  }
}
function decl(s) {
  const result = [], m2 = s.match(/([ns@]*):([nsv@])/);
  switch (m2[2]) {
    case "n":
      result.push("number");
      break;
    case "s":
      result.push("string");
      break;
    case "v":
      result.push(null);
  }
  const args = [];
  for (let c of m2[1])
    switch (c) {
      case "n":
        args.push("number");
        break;
      case "s":
        args.push("string");
    }
  return result.push(args), result;
}
class Base {
  constructor() {
    __publicField(this, "mxPathName", 64);
  }
  xClose(fileId) {
    return 10;
  }
  xRead(fileId, pData, iOffset) {
    return 10;
  }
  xWrite(fileId, pData, iOffset) {
    return 10;
  }
  xTruncate(fileId, iSize) {
    return 10;
  }
  xSync(fileId, flags) {
    return 0;
  }
  xFileSize(fileId, pSize64) {
    return 10;
  }
  xLock(fileId, flags) {
    return 0;
  }
  xUnlock(fileId, flags) {
    return 0;
  }
  xCheckReservedLock(fileId, pResOut) {
    return pResOut.setInt32(0, 0, true), 0;
  }
  xFileControl(fileId, op, pArg) {
    return 12;
  }
  xSectorSize(fileId) {
    return 512;
  }
  xDeviceCharacteristics(fileId) {
    return 0;
  }
  xOpen(name, fileId, flags, pOutFlags) {
    return 14;
  }
  xDelete(name, syncDir) {
    return 10;
  }
  xAccess(name, flags, pResOut) {
    return 10;
  }
  handleAsync(f) {
    return f();
  }
}
class WebLocksBase {
  constructor() {
    __privateAdd(this, _apply);
    __privateAdd(this, _lock);
    __privateAdd(this, _unlock);
    __privateAdd(this, _state, 0);
    __publicField(this, "timeoutMillis", 0);
    __privateAdd(this, _releasers, /* @__PURE__ */ new Map());
    __privateAdd(this, _pending, Promise.resolve(0));
  }
  get state() {
    return __privateGet(this, _state);
  }
  async lock(flags) {
    return __privateMethod(this, _apply, apply_fn).call(this, __privateMethod(this, _lock, lock_fn), flags);
  }
  async unlock(flags) {
    return __privateMethod(this, _apply, apply_fn).call(this, __privateMethod(this, _unlock, unlock_fn), flags);
  }
  async isSomewhereReserved() {
    throw new Error("unimplemented");
  }
  async _NONEtoSHARED() {
  }
  async _SHAREDtoEXCLUSIVE() {
    await this._SHAREDtoRESERVED(), await this._RESERVEDtoEXCLUSIVE();
  }
  async _SHAREDtoRESERVED() {
  }
  async _RESERVEDtoEXCLUSIVE() {
  }
  async _EXCLUSIVEtoRESERVED() {
  }
  async _EXCLUSIVEtoSHARED() {
    await this._EXCLUSIVEtoRESERVED(), await this._RESERVEDtoSHARED();
  }
  async _EXCLUSIVEtoNONE() {
    await this._EXCLUSIVEtoRESERVED(), await this._RESERVEDtoSHARED(), await this._SHAREDtoNONE();
  }
  async _RESERVEDtoSHARED() {
  }
  async _RESERVEDtoNONE() {
    await this._RESERVEDtoSHARED(), await this._SHAREDtoNONE();
  }
  async _SHAREDtoNONE() {
  }
  _acquireWebLock(lockName, options) {
    return new Promise(async (resolve, reject) => {
      try {
        await navigator.locks.request(lockName, options, (lock) => {
          if (resolve(lock), lock)
            return new Promise((release) => __privateGet(this, _releasers).set(lockName, release));
        });
      } catch (e) {
        reject(e);
      }
    });
  }
  _releaseWebLock(lockName) {
    __privateGet(this, _releasers).get(lockName)?.(), __privateGet(this, _releasers).delete(lockName);
  }
  async _pollWebLock(lockName) {
    const query = await navigator.locks.query();
    return query.held.find(({ name }) => name === lockName)?.mode;
  }
  _getTimeoutSignal() {
    if (this.timeoutMillis) {
      const abortController = new AbortController();
      return setTimeout(() => abortController.abort(), this.timeoutMillis), abortController.signal;
    }
  }
}
_state = new WeakMap();
_releasers = new WeakMap();
_pending = new WeakMap();
_apply = new WeakSet();
apply_fn = async function(method, flags) {
  const targetState = 7 & flags;
  try {
    const call = () => method.call(this, targetState);
    return await __privateSet(this, _pending, __privateGet(this, _pending).then(call, call)), __privateSet(this, _state, targetState), 0;
  } catch (e) {
    return "AbortError" === e.name ? 5 : (console.error(e), 3850);
  }
};
_lock = new WeakSet();
lock_fn = async function(targetState) {
  if (targetState === __privateGet(this, _state))
    return 0;
  switch (__privateGet(this, _state)) {
    case 0:
      if (1 === targetState)
        return this._NONEtoSHARED();
      throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
    case 1:
      switch (targetState) {
        case 2:
          return this._SHAREDtoRESERVED();
        case 4:
          return this._SHAREDtoEXCLUSIVE();
        default:
          throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
      }
    case 2:
      if (4 === targetState)
        return this._RESERVEDtoEXCLUSIVE();
      throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
    default:
      throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
  }
};
_unlock = new WeakSet();
unlock_fn = async function(targetState) {
  if (targetState === __privateGet(this, _state))
    return 0;
  switch (__privateGet(this, _state)) {
    case 4:
      switch (targetState) {
        case 1:
          return this._EXCLUSIVEtoSHARED();
        case 0:
          return this._EXCLUSIVEtoNONE();
        default:
          throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
      }
    case 2:
      switch (targetState) {
        case 1:
          return this._RESERVEDtoSHARED();
        case 0:
          return this._RESERVEDtoNONE();
        default:
          throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
      }
    case 1:
      if (0 === targetState)
        return this._SHAREDtoNONE();
      throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
    default:
      throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
  }
};
class WebLocksExclusive extends WebLocksBase {
  constructor(name) {
    super(), this._lockName = name + "-outer", this._reservedName = name + "-reserved";
  }
  async isSomewhereReserved() {
    return "exclusive" === await this._pollWebLock(this._reservedName);
  }
  async _NONEtoSHARED() {
    await this._acquireWebLock(this._lockName, { mode: "exclusive", signal: this._getTimeoutSignal() });
  }
  async _SHAREDtoRESERVED() {
    await this._acquireWebLock(this._reservedName, { mode: "exclusive", signal: this._getTimeoutSignal() });
  }
  async _RESERVEDtoSHARED() {
    this._releaseWebLock(this._reservedName);
  }
  async _SHAREDtoNONE() {
    this._releaseWebLock(this._lockName);
  }
}
let nextTxId = 0;
const mapTxToId = /* @__PURE__ */ new WeakMap();
class IDBContext {
  constructor(idbDatabase, txOptions = { durability: "default" }) {
    __privateAdd(this, _run);
    __privateAdd(this, _db, void 0);
    __privateAdd(this, _dbReady, void 0);
    __privateAdd(this, _txOptions, void 0);
    __privateAdd(this, _tx, null);
    __privateAdd(this, _txTimestamp, 0);
    __privateAdd(this, _runChain, Promise.resolve());
    __privateAdd(this, _putChain, Promise.resolve());
    __privateSet(this, _dbReady, Promise.resolve(idbDatabase).then((db) => __privateSet(this, _db, db))), __privateSet(this, _txOptions, txOptions);
  }
  async close() {
    const db = __privateGet(this, _db) ?? await __privateGet(this, _dbReady);
    await __privateGet(this, _runChain), await this.sync(), db.close();
  }
  async run(mode, f) {
    const result = __privateGet(this, _runChain).then(() => __privateMethod(this, _run, run_fn).call(this, mode, f));
    return __privateSet(this, _runChain, result.catch(() => {
    })), result;
  }
  async sync() {
    await __privateGet(this, _runChain), await __privateGet(this, _putChain), __privateSet(this, _putChain, Promise.resolve());
  }
}
_db = new WeakMap();
_dbReady = new WeakMap();
_txOptions = new WeakMap();
_tx = new WeakMap();
_txTimestamp = new WeakMap();
_runChain = new WeakMap();
_putChain = new WeakMap();
_run = new WeakSet();
run_fn = async function(mode, f) {
  const db = __privateGet(this, _db) ?? await __privateGet(this, _dbReady);
  if ("readwrite" === mode && "readonly" === __privateGet(this, _tx)?.mode)
    __privateSet(this, _tx, null);
  else if (performance.now() - __privateGet(this, _txTimestamp) > 5e3) {
    try {
      __privateGet(this, _tx)?.commit();
    } catch (e) {
      if ("InvalidStateError" !== e.name)
        throw e;
    }
    await new Promise((resolve) => setTimeout(resolve)), __privateSet(this, _tx, null);
  }
  for (let i = 0; i < 2; ++i) {
    if (!__privateGet(this, _tx)) {
      __privateSet(this, _tx, db.transaction(db.objectStoreNames, mode, __privateGet(this, _txOptions)));
      const timestamp = __privateSet(this, _txTimestamp, performance.now());
      __privateSet(this, _putChain, __privateGet(this, _putChain).then(() => new Promise((resolve, reject) => {
        __privateGet(this, _tx).addEventListener("complete", (event) => {
          resolve(), __privateGet(this, _tx) === event.target && __privateSet(this, _tx, null), mapTxToId.get(event.target);
        }), __privateGet(this, _tx).addEventListener("abort", (event) => {
          console.warn("tx abort", (performance.now() - timestamp) / 1e3);
          const e = event.target.error;
          reject(e), __privateGet(this, _tx) === event.target && __privateSet(this, _tx, null), mapTxToId.get(event.target);
        });
      }))), mapTxToId.set(__privateGet(this, _tx), nextTxId++);
    }
    try {
      const stores = Object.fromEntries(Array.from(db.objectStoreNames, (name) => [name, new ObjectStore(__privateGet(this, _tx).objectStore(name))]));
      return await f(stores);
    } catch (e) {
      if (__privateSet(this, _tx, null), i)
        throw e;
    }
  }
};
function wrapRequest(request) {
  return new Promise((resolve, reject) => {
    request.addEventListener("success", () => resolve(request.result)), request.addEventListener("error", () => reject(request.error));
  });
}
class ObjectStore {
  constructor(objectStore) {
    __privateAdd(this, _objectStore, void 0);
    __privateSet(this, _objectStore, objectStore);
  }
  get(query) {
    __privateGet(this, _objectStore).name;
    return wrapRequest(__privateGet(this, _objectStore).get(query));
  }
  getAll(query, count) {
    __privateGet(this, _objectStore).name;
    return wrapRequest(__privateGet(this, _objectStore).getAll(query, count));
  }
  getKey(query) {
    __privateGet(this, _objectStore).name;
    return wrapRequest(__privateGet(this, _objectStore).getKey(query));
  }
  getAllKeys(query, count) {
    __privateGet(this, _objectStore).name;
    return wrapRequest(__privateGet(this, _objectStore).getAllKeys(query, count));
  }
  put(value, key) {
    __privateGet(this, _objectStore).name;
    return wrapRequest(__privateGet(this, _objectStore).put(value, key));
  }
  delete(query) {
    __privateGet(this, _objectStore).name;
    return wrapRequest(__privateGet(this, _objectStore).delete(query));
  }
  clear() {
    __privateGet(this, _objectStore).name;
    return wrapRequest(__privateGet(this, _objectStore).clear());
  }
  index(name) {
    return new Index(__privateGet(this, _objectStore).index(name));
  }
}
_objectStore = new WeakMap();
class Index {
  constructor(index2) {
    __privateAdd(this, _index, void 0);
    __privateSet(this, _index, index2);
  }
  getAllKeys(query, count) {
    __privateGet(this, _index).objectStore.name, __privateGet(this, _index).name;
    return wrapRequest(__privateGet(this, _index).getAllKeys(query, count));
  }
}
_index = new WeakMap();
const DEFAULT_OPTIONS = { durability: "default", purge: "deferred", purgeAtLeast: 16 };
class IDBBatchAtomicVFS extends Base {
  constructor(idbDatabaseName = "wa-sqlite", options = DEFAULT_OPTIONS) {
    super();
    __privateAdd(this, _xWriteHelper);
    __privateAdd(this, _xSyncHelper);
    __privateAdd(this, _maybePurge);
    __privateAdd(this, _bound);
    __privateAdd(this, _reblockIfNeeded);
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _mapIdToFile, /* @__PURE__ */ new Map());
    __privateAdd(this, _idb, void 0);
    __privateAdd(this, _pendingPurges, /* @__PURE__ */ new Set());
    __privateAdd(this, _taskTimestamp, performance.now());
    __privateAdd(this, _pendingAsync, /* @__PURE__ */ new Set());
    __privateAdd(this, _growthHandler, null);
    this.name = idbDatabaseName, __privateSet(this, _options, Object.assign({}, DEFAULT_OPTIONS, options)), __privateSet(this, _idb, new IDBContext(function(idbDatabaseName2) {
      return new Promise((resolve, reject) => {
        const request = globalThis.indexedDB.open(idbDatabaseName2, 5);
        request.addEventListener("upgradeneeded", function() {
          request.result.createObjectStore("blocks", { keyPath: ["path", "offset", "version"] }).createIndex("version", ["path", "version"]);
        }), request.addEventListener("success", () => {
          resolve(request.result);
        }), request.addEventListener("error", () => {
          reject(request.error);
        });
      });
    }(idbDatabaseName), { durability: __privateGet(this, _options).durability }));
  }
  async close() {
    for (const fileId of __privateGet(this, _mapIdToFile).keys())
      await this.xClose(fileId);
    await __privateGet(this, _idb)?.close(), __privateSet(this, _idb, null);
  }
  xOpen(name, fileId, flags, pOutFlags) {
    var _a;
    const result = this.handleAsync(async () => {
      null === name && (name = `null_${fileId}`), fileId.toString(16), flags.toString(16);
      try {
        const url = new URL(name, "http://localhost/"), file = { path: url.pathname, flags, block0: null, isMetadataChanged: true, locks: new WebLocksExclusive(url.pathname) };
        return __privateGet(this, _mapIdToFile).set(fileId, file), await __privateGet(this, _idb).run("readwrite", async ({ blocks }) => {
          if (file.block0 = await blocks.get(__privateMethod(this, _bound, bound_fn).call(this, file, 0)), !file.block0) {
            if (!(4 & flags))
              throw new Error(`file not found: ${file.path}`);
            file.block0 = { path: file.path, offset: 0, version: 0, data: new Uint8Array(0), fileSize: 0 }, blocks.put(file.block0);
          }
        }), !pOutFlags.buffer.detached && pOutFlags.buffer.byteLength || (pOutFlags = new DataView(new ArrayBuffer(4)), __privateSet(this, _growthHandler, (pOutFlagsNew) => {
          pOutFlagsNew.setInt32(0, pOutFlags.getInt32(0, true), true);
        })), pOutFlags.setInt32(0, 1 & flags, true), 0;
      } catch (e) {
        return console.error(e), 14;
      }
    });
    return (_a = __privateGet(this, _growthHandler)) == null ? void 0 : _a.call(this, pOutFlags), __privateSet(this, _growthHandler, null), result;
  }
  xClose(fileId) {
    return this.handleAsync(async () => {
      try {
        const file = __privateGet(this, _mapIdToFile).get(fileId);
        return file && (file.path, __privateGet(this, _mapIdToFile).delete(fileId), 8 & file.flags && __privateGet(this, _idb).run("readwrite", ({ blocks }) => {
          blocks.delete(IDBKeyRange.bound([file.path], [file.path, []]));
        })), 0;
      } catch (e) {
        return console.error(e), 10;
      }
    });
  }
  xRead(fileId, pData, iOffset) {
    var _a;
    const byteLength = pData.byteLength, result = this.handleAsync(async () => {
      const file = __privateGet(this, _mapIdToFile).get(fileId);
      file.path, pData.byteLength;
      try {
        return await __privateGet(this, _idb).run("readonly", async ({ blocks }) => {
          !pData.buffer.detached && pData.buffer.byteLength || (pData = new Uint8Array(byteLength), __privateSet(this, _growthHandler, (pDataNew) => pDataNew.set(pData)));
          let pDataOffset = 0;
          for (; pDataOffset < pData.byteLength; ) {
            const fileOffset = iOffset + pDataOffset, block = fileOffset < file.block0.data.byteLength ? file.block0 : await blocks.get(__privateMethod(this, _bound, bound_fn).call(this, file, -fileOffset));
            if (!block || block.data.byteLength - block.offset <= fileOffset)
              return pData.fill(0, pDataOffset), 522;
            const buffer = pData.subarray(pDataOffset), blockOffset = fileOffset + block.offset, nBytesToCopy = Math.min(Math.max(block.data.byteLength - blockOffset, 0), buffer.byteLength);
            buffer.set(block.data.subarray(blockOffset, blockOffset + nBytesToCopy)), pDataOffset += nBytesToCopy;
          }
          return 0;
        });
      } catch (e) {
        return console.error(e), 10;
      }
    });
    return (_a = __privateGet(this, _growthHandler)) == null ? void 0 : _a.call(this, pData), __privateSet(this, _growthHandler, null), result;
  }
  xWrite(fileId, pData, iOffset) {
    const rewound = __privateGet(this, _pendingAsync).has(fileId);
    if (rewound || performance.now() - __privateGet(this, _taskTimestamp) > 3e3) {
      const result = this.handleAsync(async () => {
        this.handleAsync !== super.handleAsync && __privateGet(this, _pendingAsync).add(fileId), await new Promise((resolve) => setTimeout(resolve));
        const result2 = __privateMethod(this, _xWriteHelper, xWriteHelper_fn).call(this, fileId, pData.slice(), iOffset);
        return __privateSet(this, _taskTimestamp, performance.now()), result2;
      });
      return rewound && __privateGet(this, _pendingAsync).delete(fileId), result;
    }
    return __privateMethod(this, _xWriteHelper, xWriteHelper_fn).call(this, fileId, pData, iOffset);
  }
  xTruncate(fileId, iSize) {
    const file = __privateGet(this, _mapIdToFile).get(fileId);
    file.path;
    try {
      Object.assign(file.block0, { fileSize: iSize, data: file.block0.data.slice(0, iSize) });
      const block0 = Object.assign({}, file.block0);
      return __privateGet(this, _idb).run("readwrite", ({ blocks }) => {
        blocks.delete(__privateMethod(this, _bound, bound_fn).call(this, file, -1 / 0, -iSize)), blocks.put(block0);
      }), 0;
    } catch (e) {
      return console.error(e), 10;
    }
  }
  xSync(fileId, flags) {
    const rewound = __privateGet(this, _pendingAsync).has(fileId);
    if (rewound || "relaxed" !== __privateGet(this, _options).durability || performance.now() - __privateGet(this, _taskTimestamp) > 3e3) {
      const result = this.handleAsync(async () => {
        this.handleAsync !== super.handleAsync && __privateGet(this, _pendingAsync).add(fileId);
        const result2 = await __privateMethod(this, _xSyncHelper, xSyncHelper_fn).call(this, fileId, flags);
        return __privateSet(this, _taskTimestamp, performance.now()), result2;
      });
      return rewound && __privateGet(this, _pendingAsync).delete(fileId), result;
    }
    return __privateGet(this, _mapIdToFile).get(fileId).path, 0;
  }
  xFileSize(fileId, pSize64) {
    const file = __privateGet(this, _mapIdToFile).get(fileId);
    return file.path, pSize64.setBigInt64(0, BigInt(file.block0.fileSize), true), 0;
  }
  xLock(fileId, flags) {
    return this.handleAsync(async () => {
      const file = __privateGet(this, _mapIdToFile).get(fileId);
      file.path;
      try {
        const result = await file.locks.lock(flags);
        return 0 === result && 1 === file.locks.state && (file.block0 = await __privateGet(this, _idb).run("readonly", ({ blocks }) => blocks.get(__privateMethod(this, _bound, bound_fn).call(this, file, 0)))), result;
      } catch (e) {
        return console.error(e), 10;
      }
    });
  }
  xUnlock(fileId, flags) {
    return this.handleAsync(async () => {
      const file = __privateGet(this, _mapIdToFile).get(fileId);
      file.path;
      try {
        return file.locks.unlock(flags);
      } catch (e) {
        return console.error(e), 10;
      }
    });
  }
  xCheckReservedLock(fileId, pResOut) {
    var _a;
    const result = this.handleAsync(async () => {
      const file = __privateGet(this, _mapIdToFile).get(fileId);
      file.path;
      const isReserved = await file.locks.isSomewhereReserved();
      return !pResOut.buffer.detached && pResOut.buffer.byteLength || (pResOut = new DataView(new ArrayBuffer(4)), __privateSet(this, _growthHandler, (pResOutNew) => {
        pResOutNew.setInt32(0, pResOut.getInt32(0, true), true);
      })), pResOut.setInt32(0, isReserved ? 1 : 0, true), 0;
    });
    return (_a = __privateGet(this, _growthHandler)) == null ? void 0 : _a.call(this, pResOut), __privateSet(this, _growthHandler, null), result;
  }
  xSectorSize(fileId) {
    return 512;
  }
  xDeviceCharacteristics(fileId) {
    return 19968;
  }
  xFileControl(fileId, op, pArg) {
    const file = __privateGet(this, _mapIdToFile).get(fileId);
    switch (file.path, op) {
      case 11:
        return file.overwrite = true, 0;
      case 21:
        if (file.overwrite)
          try {
            return this.handleAsync(async () => (await __privateMethod(this, _reblockIfNeeded, reblockIfNeeded_fn).call(this, file), 0));
          } catch (e) {
            return console.error(e), 10;
          }
        if (file.isMetadataChanged)
          try {
            __privateGet(this, _idb).run("readwrite", async ({ blocks }) => {
              await blocks.put(file.block0);
            }), file.isMetadataChanged = false;
          } catch (e) {
            return console.error(e), 10;
          }
        return 0;
      case 22:
        return file.overwrite = false, 0;
      case 31:
        return this.handleAsync(async () => {
          try {
            return file.block0.version--, file.changedPages = /* @__PURE__ */ new Set(), __privateGet(this, _idb).run("readwrite", async ({ blocks }) => {
              const keys = await blocks.index("version").getAllKeys(IDBKeyRange.bound([file.path], [file.path, file.block0.version]));
              for (const key of keys)
                blocks.delete(key);
            }), 0;
          } catch (e) {
            return console.error(e), 10;
          }
        });
      case 32:
        try {
          const block0 = Object.assign({}, file.block0);
          block0.data = block0.data.slice();
          const changedPages = file.changedPages;
          return file.changedPages = null, file.isMetadataChanged = false, __privateGet(this, _idb).run("readwrite", async ({ blocks }) => {
            blocks.put(block0);
            const purgeBlock = await blocks.get([file.path, "purge", 0]) ?? { path: file.path, offset: "purge", version: 0, data: /* @__PURE__ */ new Map(), count: 0 };
            purgeBlock.count += changedPages.size;
            for (const pageIndex of changedPages)
              purgeBlock.data.set(pageIndex, block0.version);
            blocks.put(purgeBlock), __privateMethod(this, _maybePurge, maybePurge_fn).call(this, file.path, purgeBlock.count);
          }), 0;
        } catch (e) {
          return console.error(e), 10;
        }
      case 33:
        return this.handleAsync(async () => {
          try {
            return file.changedPages = null, file.isMetadataChanged = false, file.block0 = await __privateGet(this, _idb).run("readonly", ({ blocks }) => blocks.get([file.path, 0, file.block0.version + 1])), 0;
          } catch (e) {
            return console.error(e), 10;
          }
        });
      default:
        return 12;
    }
  }
  xAccess(name, flags, pResOut) {
    var _a;
    const result = this.handleAsync(async () => {
      try {
        const path = new URL(name, "file://localhost/").pathname, key = await __privateGet(this, _idb).run("readonly", ({ blocks }) => blocks.getKey(__privateMethod(this, _bound, bound_fn).call(this, { path }, 0)));
        return !pResOut.buffer.detached && pResOut.buffer.byteLength || (pResOut = new DataView(new ArrayBuffer(4)), __privateSet(this, _growthHandler, (pResOutNew) => {
          pResOutNew.setInt32(0, pResOut.getInt32(0, true), true);
        })), pResOut.setInt32(0, key ? 1 : 0, true), 0;
      } catch (e) {
        return console.error(e), 10;
      }
    });
    return (_a = __privateGet(this, _growthHandler)) == null ? void 0 : _a.call(this, pResOut), __privateSet(this, _growthHandler, null), result;
  }
  xDelete(name, syncDir) {
    return this.handleAsync(async () => {
      const path = new URL(name, "file://localhost/").pathname;
      try {
        return __privateGet(this, _idb).run("readwrite", ({ blocks }) => blocks.delete(IDBKeyRange.bound([path], [path, []]))), syncDir && await __privateGet(this, _idb).sync(), 0;
      } catch (e) {
        return console.error(e), 10;
      }
    });
  }
  async purge(path) {
    Date.now();
    await __privateGet(this, _idb).run("readwrite", async ({ blocks }) => {
      const purgeBlock = await blocks.get([path, "purge", 0]);
      if (purgeBlock) {
        for (const [pageOffset, version] of purgeBlock.data)
          blocks.delete(IDBKeyRange.bound([path, pageOffset, version], [path, pageOffset, 1 / 0], true, false));
        await blocks.delete([path, "purge", 0]);
      }
      purgeBlock?.data.size, Date.now();
    });
  }
}
_options = new WeakMap();
_mapIdToFile = new WeakMap();
_idb = new WeakMap();
_pendingPurges = new WeakMap();
_taskTimestamp = new WeakMap();
_pendingAsync = new WeakMap();
_growthHandler = new WeakMap();
_xWriteHelper = new WeakSet();
xWriteHelper_fn = function(fileId, pData, iOffset) {
  const file = __privateGet(this, _mapIdToFile).get(fileId);
  file.path, pData.byteLength;
  try {
    const prevFileSize = file.block0.fileSize;
    file.block0.fileSize < iOffset + pData.byteLength && (file.block0.fileSize = iOffset + pData.byteLength, file.isMetadataChanged = true);
    const block = 0 === iOffset ? file.block0 : { path: file.path, offset: -iOffset, version: file.block0.version, data: null };
    return block.data = pData.slice(), file.changedPages ? (prevFileSize === file.block0.fileSize && file.changedPages.add(-iOffset), 0 !== iOffset && __privateGet(this, _idb).run("readwrite", ({ blocks }) => blocks.put(block))) : __privateGet(this, _idb).run("readwrite", ({ blocks }) => blocks.put(block)), file.isMetadataChanged = 0 !== iOffset && file.isMetadataChanged, 0;
  } catch (e) {
    return console.error(e), 10;
  }
};
_xSyncHelper = new WeakSet();
xSyncHelper_fn = async function(fileId, flags) {
  const file = __privateGet(this, _mapIdToFile).get(fileId);
  file.path;
  try {
    file.isMetadataChanged && (__privateGet(this, _idb).run("readwrite", async ({ blocks }) => {
      await blocks.put(file.block0);
    }), file.isMetadataChanged = false), await __privateGet(this, _idb).sync();
  } catch (e) {
    return console.error(e), 10;
  }
  return 0;
};
_maybePurge = new WeakSet();
maybePurge_fn = function(path, nPages) {
  "manual" === __privateGet(this, _options).purge || __privateGet(this, _pendingPurges).has(path) || nPages < __privateGet(this, _options).purgeAtLeast || (globalThis.requestIdleCallback ? globalThis.requestIdleCallback(() => {
    this.purge(path), __privateGet(this, _pendingPurges).delete(path);
  }) : setTimeout(() => {
    this.purge(path), __privateGet(this, _pendingPurges).delete(path);
  }), __privateGet(this, _pendingPurges).add(path));
};
_bound = new WeakSet();
bound_fn = function(file, begin, end = 0) {
  const version = !begin || -begin < file.block0.data.length ? -1 / 0 : file.block0.version;
  return IDBKeyRange.bound([file.path, begin, version], [file.path, end, 1 / 0]);
};
_reblockIfNeeded = new WeakSet();
reblockIfNeeded_fn = async function(file) {
  const oldPageSize = file.block0.data.length;
  if (oldPageSize < 18)
    return;
  const view = new DataView(file.block0.data.buffer, file.block0.data.byteOffset);
  let newPageSize = view.getUint16(16);
  if (1 === newPageSize && (newPageSize = 65536), newPageSize === oldPageSize)
    return;
  const maxPageSize = Math.max(oldPageSize, newPageSize), nOldPages = maxPageSize / oldPageSize, nNewPages = maxPageSize / newPageSize, fileSize = view.getUint32(28) * newPageSize, version = file.block0.version;
  await __privateGet(this, _idb).run("readwrite", async ({ blocks }) => {
    const keys = await blocks.index("version").getAllKeys(IDBKeyRange.bound([file.path, version + 1], [file.path, 1 / 0]));
    for (const key of keys)
      blocks.delete(key);
    blocks.delete([file.path, "purge", 0]);
    for (let iOffset = 0; iOffset < fileSize; iOffset += maxPageSize) {
      const oldPages = await blocks.getAll(IDBKeyRange.lowerBound([file.path, -(iOffset + maxPageSize), 1 / 0]), nOldPages);
      for (const oldPage of oldPages)
        blocks.delete([oldPage.path, oldPage.offset, oldPage.version]);
      if (1 === nNewPages) {
        const buffer = new Uint8Array(newPageSize);
        for (const oldPage of oldPages)
          buffer.set(oldPage.data, -(iOffset + oldPage.offset));
        const newPage = { path: file.path, offset: -iOffset, version, data: buffer };
        0 === newPage.offset && (newPage.fileSize = fileSize, file.block0 = newPage), blocks.put(newPage);
      } else {
        const oldPage = oldPages[0];
        for (let i = 0; i < nNewPages; ++i) {
          const offset = -(iOffset + i * newPageSize);
          if (-offset >= fileSize)
            break;
          const newPage = { path: oldPage.path, offset, version, data: oldPage.data.subarray(i * newPageSize, (i + 1) * newPageSize) };
          0 === newPage.offset && (newPage.fileSize = fileSize, file.block0 = newPage), blocks.put(newPage);
        }
      }
    }
  });
};
const IS_NODEJS_ENV = "object" == typeof process;
const DEFAULT_WASQLITE_OPTIONS = { wasmMemorySize: 32833536, cacheSize: -16e3 };
async function createWASQLiteDB(fileName, options) {
  const wasqliteOptions = { ...DEFAULT_WASQLITE_OPTIONS, ...options }, libraryOptions = IS_NODEJS_ENV && void 0 !== wasqliteOptions.wasmLocation ? { locateFile: (path) => `${wasqliteOptions.wasmLocation}${path}` } : {}, wasmModule = await async function(baseUrl2, options2) {
    const { default: SQLiteESMFactory } = await import(`${baseUrl2}mxclientsystem/wa-sqlite/wa-sqlite-async.mjs`);
    if (IS_NODEJS_ENV) {
      const originalImportScript = globalThis.importScripts;
      globalThis.importScripts = function() {
      };
      const wasmModule2 = await SQLiteESMFactory(options2);
      return globalThis.importScripts = originalImportScript, wasmModule2;
    }
    return SQLiteESMFactory(options2);
  }(options.baseUrl, libraryOptions), pragmas = IS_NODEJS_ENV ? [] : [`PRAGMA cache_size=${wasqliteOptions.cacheSize}`, ...wasqliteOptions.additionalPragmas ?? []];
  IS_NODEJS_ENV || wasmModule._free(wasmModule._malloc(wasqliteOptions.wasmMemorySize));
  const sqlite3 = function(Module) {
    const sqlite32 = {}, sqliteFreeAddress = Module._getSqliteFree(), tmp = Module._malloc(8), tmpPtr = [tmp, tmp + 4];
    function createUTF8(s) {
      if ("string" != typeof s)
        return 0;
      const n = Module.lengthBytesUTF8(s), zts = Module._sqlite3_malloc(n + 1);
      return Module.stringToUTF8(s, zts, n + 1), zts;
    }
    function cvt32x2ToBigInt(lo32, hi32) {
      return BigInt(hi32) << 32n | 0xffffffffn & BigInt(lo32);
    }
    const cvt32x2AsSafe = function() {
      const hiMax = BigInt(Number.MAX_SAFE_INTEGER) >> 32n, hiMin = BigInt(Number.MIN_SAFE_INTEGER) >> 32n;
      return function(lo32, hi32) {
        return hi32 > hiMax || hi32 < hiMin ? cvt32x2ToBigInt(lo32, hi32) : 4294967296 * hi32 + (2147483647 & lo32) - (2147483648 & lo32);
      };
    }(), databases = /* @__PURE__ */ new Set();
    function verifyDatabase(db2) {
      if (!databases.has(db2))
        throw new SQLiteError("not a database", 21);
    }
    const mapStmtToDB = /* @__PURE__ */ new Map();
    function verifyStatement(stmt) {
      if (!mapStmtToDB.has(stmt))
        throw new SQLiteError("not a statement", 21);
    }
    sqlite32.bind_collection = function(stmt, bindings) {
      verifyStatement(stmt);
      const isArray = Array.isArray(bindings), nBindings = sqlite32.bind_parameter_count(stmt);
      for (let i = 1; i <= nBindings; ++i) {
        const value = bindings[isArray ? i - 1 : sqlite32.bind_parameter_name(stmt, i)];
        void 0 !== value && sqlite32.bind(stmt, i, value);
      }
      return 0;
    }, sqlite32.bind = function(stmt, i, value) {
      switch (verifyStatement(stmt), typeof value) {
        case "number":
          return value === (0 | value) ? sqlite32.bind_int(stmt, i, value) : sqlite32.bind_double(stmt, i, value);
        case "string":
          return sqlite32.bind_text(stmt, i, value);
        default:
          return value instanceof Uint8Array || Array.isArray(value) ? sqlite32.bind_blob(stmt, i, value) : null === value ? sqlite32.bind_null(stmt, i) : "bigint" == typeof value ? sqlite32.bind_int64(stmt, i, value) : void 0 === value ? 27 : (console.warn("unknown binding converted to null", value), sqlite32.bind_null(stmt, i));
      }
    }, sqlite32.bind_blob = function() {
      const fname = "sqlite3_bind_blob", f = Module.cwrap(fname, ...decl("nnnnn:n"));
      return function(stmt, i, value) {
        verifyStatement(stmt);
        const byteLength = value.byteLength ?? value.length, ptr = Module._sqlite3_malloc(byteLength);
        Module.HEAPU8.subarray(ptr).set(value);
        const result = f(stmt, i, ptr, byteLength, sqliteFreeAddress);
        return check(fname, result, mapStmtToDB.get(stmt));
      };
    }(), sqlite32.bind_parameter_count = function() {
      const f = Module.cwrap("sqlite3_bind_parameter_count", ...decl("n:n"));
      return function(stmt) {
        return verifyStatement(stmt), f(stmt);
      };
    }(), sqlite32.bind_double = function() {
      const fname = "sqlite3_bind_double", f = Module.cwrap(fname, ...decl("nnn:n"));
      return function(stmt, i, value) {
        verifyStatement(stmt);
        const result = f(stmt, i, value);
        return check(fname, result, mapStmtToDB.get(stmt));
      };
    }(), sqlite32.bind_int = function() {
      const fname = "sqlite3_bind_int", f = Module.cwrap(fname, ...decl("nnn:n"));
      return function(stmt, i, value) {
        if (verifyStatement(stmt), value > 2147483647 || value < -2147483648)
          return 25;
        const result = f(stmt, i, value);
        return check(fname, result, mapStmtToDB.get(stmt));
      };
    }(), sqlite32.bind_int64 = function() {
      const fname = "sqlite3_bind_int64", f = Module.cwrap(fname, ...decl("nnnn:n"));
      return function(stmt, i, value) {
        if (verifyStatement(stmt), value > 9223372036854775807n || value < -9223372036854775808n)
          return 25;
        const hi32 = value >> 32n, result = f(stmt, i, Number(0xffffffffn & value), Number(hi32));
        return check(fname, result, mapStmtToDB.get(stmt));
      };
    }(), sqlite32.bind_null = function() {
      const fname = "sqlite3_bind_null", f = Module.cwrap(fname, ...decl("nn:n"));
      return function(stmt, i) {
        verifyStatement(stmt);
        const result = f(stmt, i);
        return check(fname, result, mapStmtToDB.get(stmt));
      };
    }(), sqlite32.bind_parameter_name = function() {
      const f = Module.cwrap("sqlite3_bind_parameter_name", ...decl("n:s"));
      return function(stmt, i) {
        return verifyStatement(stmt), f(stmt, i);
      };
    }(), sqlite32.bind_text = function() {
      const fname = "sqlite3_bind_text", f = Module.cwrap(fname, ...decl("nnnnn:n"));
      return function(stmt, i, value) {
        verifyStatement(stmt);
        const ptr = createUTF8(value), result = f(stmt, i, ptr, -1, sqliteFreeAddress);
        return check(fname, result, mapStmtToDB.get(stmt));
      };
    }(), sqlite32.changes = function() {
      const f = Module.cwrap("sqlite3_changes", ...decl("n:n"));
      return function(db2) {
        return verifyDatabase(db2), f(db2);
      };
    }(), sqlite32.close = function() {
      const f = Module.cwrap("sqlite3_close", ...decl("n:n"), { async: true });
      return async function(db2) {
        verifyDatabase(db2);
        const result = await f(db2);
        return databases.delete(db2), check("sqlite3_close", result, db2);
      };
    }(), sqlite32.column = function(stmt, iCol) {
      verifyStatement(stmt);
      const type = sqlite32.column_type(stmt, iCol);
      switch (type) {
        case 4:
          return sqlite32.column_blob(stmt, iCol);
        case 2:
          return sqlite32.column_double(stmt, iCol);
        case 1:
          const lo32 = sqlite32.column_int(stmt, iCol), hi32 = Module.getTempRet0();
          return cvt32x2AsSafe(lo32, hi32);
        case 5:
          return null;
        case 3:
          return sqlite32.column_text(stmt, iCol);
        default:
          throw new SQLiteError("unknown type", type);
      }
    }, sqlite32.column_blob = function() {
      const f = Module.cwrap("sqlite3_column_blob", ...decl("nn:n"));
      return function(stmt, iCol) {
        verifyStatement(stmt);
        const nBytes = sqlite32.column_bytes(stmt, iCol), address = f(stmt, iCol);
        return Module.HEAPU8.subarray(address, address + nBytes);
      };
    }(), sqlite32.column_bytes = function() {
      const f = Module.cwrap("sqlite3_column_bytes", ...decl("nn:n"));
      return function(stmt, iCol) {
        return verifyStatement(stmt), f(stmt, iCol);
      };
    }(), sqlite32.column_count = function() {
      const f = Module.cwrap("sqlite3_column_count", ...decl("n:n"));
      return function(stmt) {
        return verifyStatement(stmt), f(stmt);
      };
    }(), sqlite32.column_double = function() {
      const f = Module.cwrap("sqlite3_column_double", ...decl("nn:n"));
      return function(stmt, iCol) {
        return verifyStatement(stmt), f(stmt, iCol);
      };
    }(), sqlite32.column_int = function() {
      const f = Module.cwrap("sqlite3_column_int64", ...decl("nn:n"));
      return function(stmt, iCol) {
        return verifyStatement(stmt), f(stmt, iCol);
      };
    }(), sqlite32.column_int64 = function() {
      const f = Module.cwrap("sqlite3_column_int64", ...decl("nn:n"));
      return function(stmt, iCol) {
        return verifyStatement(stmt), cvt32x2ToBigInt(f(stmt, iCol), Module.getTempRet0());
      };
    }(), sqlite32.column_name = function() {
      const f = Module.cwrap("sqlite3_column_name", ...decl("nn:s"));
      return function(stmt, iCol) {
        return verifyStatement(stmt), f(stmt, iCol);
      };
    }(), sqlite32.column_names = function(stmt) {
      const columns = [], nColumns = sqlite32.column_count(stmt);
      for (let i = 0; i < nColumns; ++i)
        columns.push(sqlite32.column_name(stmt, i));
      return columns;
    }, sqlite32.column_text = function() {
      const f = Module.cwrap("sqlite3_column_text", ...decl("nn:s"));
      return function(stmt, iCol) {
        return verifyStatement(stmt), f(stmt, iCol);
      };
    }(), sqlite32.column_type = function() {
      const f = Module.cwrap("sqlite3_column_type", ...decl("nn:n"));
      return function(stmt, iCol) {
        return verifyStatement(stmt), f(stmt, iCol);
      };
    }(), sqlite32.create_function = function(db2, zFunctionName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) {
      if (verifyDatabase(db2), xFunc && !xStep && !xFinal)
        return check("sqlite3_create_function", Module.createFunction(db2, zFunctionName, nArg, eTextRep, pApp, xFunc), db2);
      if (!xFunc && xStep && xFinal)
        return check("sqlite3_create_function", Module.createAggregate(db2, zFunctionName, nArg, eTextRep, pApp, xStep, xFinal), db2);
      throw new SQLiteError("invalid function combination", 21);
    }, sqlite32.create_module = function(db2, zName, module, appData) {
      return verifyDatabase(db2), check("sqlite3_create_module", Module.createModule(db2, zName, module, appData), db2);
    }, sqlite32.data_count = function() {
      const f = Module.cwrap("sqlite3_data_count", ...decl("n:n"));
      return function(stmt) {
        return verifyStatement(stmt), f(stmt);
      };
    }(), sqlite32.declare_vtab = function() {
      const f = Module.cwrap("sqlite3_declare_vtab", ...decl("ns:n"));
      return function(pVTab, zSQL) {
        return check("sqlite3_declare_vtab", f(pVTab, zSQL));
      };
    }(), sqlite32.exec = async function(db2, sql, callback) {
      for await (const stmt of sqlite32.statements(db2, sql)) {
        let columns;
        for (; 100 === await sqlite32.step(stmt); )
          if (callback) {
            columns = columns ?? sqlite32.column_names(stmt);
            const row = sqlite32.row(stmt);
            await callback(row, columns);
          }
      }
      return 0;
    }, sqlite32.finalize = function() {
      const f = Module.cwrap("sqlite3_finalize", ...decl("n:n"), { async: true });
      return async function(stmt) {
        if (!mapStmtToDB.has(stmt))
          return 21;
        const result = await f(stmt);
        return mapStmtToDB.get(stmt), mapStmtToDB.delete(stmt), result;
      };
    }(), sqlite32.get_autocommit = function() {
      const f = Module.cwrap("sqlite3_get_autocommit", ...decl("n:n"));
      return function(db2) {
        return f(db2);
      };
    }(), sqlite32.libversion = function() {
      const f = Module.cwrap("sqlite3_libversion", ...decl(":s"));
      return function() {
        return f();
      };
    }(), sqlite32.libversion_number = function() {
      const f = Module.cwrap("sqlite3_libversion_number", ...decl(":n"));
      return function() {
        return f();
      };
    }(), sqlite32.limit = function() {
      const f = Module.cwrap("sqlite3_limit", ...decl("nnn:n"));
      return function(db2, id, newVal) {
        return f(db2, id, newVal);
      };
    }(), sqlite32.open_v2 = function() {
      const f = Module.cwrap("sqlite3_open_v2", ...decl("snnn:n"), { async: true });
      return async function(zFilename, flags, zVfs) {
        flags = flags || 6, zVfs = createUTF8(zVfs);
        const result = await f(zFilename, tmpPtr[0], flags, zVfs), db2 = Module.getValue(tmpPtr[0], "*");
        return databases.add(db2), Module._sqlite3_free(zVfs), Module.ccall("RegisterExtensionFunctions", "void", ["number"], [db2]), check("sqlite3_open_v2", result), db2;
      };
    }(), sqlite32.prepare_v2 = function() {
      const fname = "sqlite3_prepare_v2", f = Module.cwrap(fname, ...decl("nnnnn:n"), { async: true });
      return async function(db2, sql) {
        const result = await f(db2, sql, -1, tmpPtr[0], tmpPtr[1]);
        check(fname, result, db2);
        const stmt = Module.getValue(tmpPtr[0], "*");
        return stmt ? (mapStmtToDB.set(stmt, db2), { stmt, sql: Module.getValue(tmpPtr[1], "*") }) : null;
      };
    }(), sqlite32.progress_handler = function(db2, nProgressOps, handler, userData) {
      verifyDatabase(db2), Module.progressHandler(db2, nProgressOps, handler, userData);
    }, sqlite32.reset = function() {
      const f = Module.cwrap("sqlite3_reset", ...decl("n:n"), { async: true });
      return async function(stmt) {
        return verifyStatement(stmt), check("sqlite3_reset", await f(stmt), mapStmtToDB.get(stmt));
      };
    }(), sqlite32.result = function(context, value) {
      switch (typeof value) {
        case "number":
          value === (0 | value) ? sqlite32.result_int(context, value) : sqlite32.result_double(context, value);
          break;
        case "string":
          sqlite32.result_text(context, value);
          break;
        default:
          if (value instanceof Uint8Array || Array.isArray(value))
            sqlite32.result_blob(context, value);
          else if (null === value)
            sqlite32.result_null(context);
          else {
            if ("bigint" == typeof value)
              return sqlite32.result_int64(context, value);
            console.warn("unknown result converted to null", value), sqlite32.result_null(context);
          }
      }
    }, sqlite32.result_blob = function() {
      const f = Module.cwrap("sqlite3_result_blob", ...decl("nnnn:n"));
      return function(context, value) {
        const byteLength = value.byteLength ?? value.length, ptr = Module._sqlite3_malloc(byteLength);
        Module.HEAPU8.subarray(ptr).set(value), f(context, ptr, byteLength, sqliteFreeAddress);
      };
    }(), sqlite32.result_double = function() {
      const f = Module.cwrap("sqlite3_result_double", ...decl("nn:n"));
      return function(context, value) {
        f(context, value);
      };
    }(), sqlite32.result_int = function() {
      const f = Module.cwrap("sqlite3_result_int", ...decl("nn:n"));
      return function(context, value) {
        f(context, value);
      };
    }(), sqlite32.result_int64 = function() {
      const f = Module.cwrap("sqlite3_result_int64", ...decl("nnn:n"));
      return function(context, value) {
        if (value > 9223372036854775807n || value < -9223372036854775808n)
          return 25;
        const hi32 = value >> 32n;
        f(context, Number(0xffffffffn & value), Number(hi32));
      };
    }(), sqlite32.result_null = function() {
      const f = Module.cwrap("sqlite3_result_null", ...decl("n:n"));
      return function(context) {
        f(context);
      };
    }(), sqlite32.result_text = function() {
      const f = Module.cwrap("sqlite3_result_text", ...decl("nnnn:n"));
      return function(context, value) {
        const ptr = createUTF8(value);
        f(context, ptr, -1, sqliteFreeAddress);
      };
    }(), sqlite32.row = function(stmt) {
      const row = [], nColumns = sqlite32.data_count(stmt);
      for (let i = 0; i < nColumns; ++i) {
        const value = sqlite32.column(stmt, i);
        row.push(value?.buffer === Module.HEAPU8.buffer ? value.slice() : value);
      }
      return row;
    }, sqlite32.set_authorizer = function(db2, authFunction, userData) {
      return verifyDatabase(db2), check("sqlite3_set_authorizer", Module.setAuthorizer(db2, authFunction, userData), db2);
    }, sqlite32.sql = function() {
      const f = Module.cwrap("sqlite3_sql", ...decl("n:s"));
      return function(stmt) {
        return verifyStatement(stmt), f(stmt);
      };
    }(), sqlite32.statements = function(db2, sql) {
      return async function* () {
        const str = sqlite32.str_new(db2, sql);
        let prepared = { stmt: null, sql: sqlite32.str_value(str) };
        try {
          for (; prepared = await sqlite32.prepare_v2(db2, prepared.sql); )
            yield prepared.stmt, sqlite32.finalize(prepared.stmt), prepared.stmt = null;
        } finally {
          prepared?.stmt && sqlite32.finalize(prepared.stmt), sqlite32.str_finish(str);
        }
      }();
    }, sqlite32.step = function() {
      const f = Module.cwrap("sqlite3_step", ...decl("n:n"), { async: true });
      return async function(stmt) {
        return verifyStatement(stmt), check("sqlite3_step", await f(stmt), mapStmtToDB.get(stmt), [100, 101]);
      };
    }();
    let stringId = 0;
    const strings = /* @__PURE__ */ new Map();
    function check(fname, result, db2 = null, allowed = [0]) {
      if (allowed.includes(result))
        return result;
      const message = db2 ? Module.ccall("sqlite3_errmsg", "string", ["number"], [db2]) : fname;
      throw new SQLiteError(message, result);
    }
    return sqlite32.str_new = function(db2, s = "") {
      const sBytes = Module.lengthBytesUTF8(s), str = 4294967295 & stringId++, data = { offset: Module._sqlite3_malloc(sBytes + 1), bytes: sBytes };
      return strings.set(str, data), Module.stringToUTF8(s, data.offset, data.bytes + 1), str;
    }, sqlite32.str_appendall = function(str, s) {
      if (!strings.has(str))
        throw new SQLiteError("not a string", 21);
      const data = strings.get(str), sBytes = Module.lengthBytesUTF8(s), newBytes = data.bytes + sBytes, newOffset = Module._sqlite3_malloc(newBytes + 1);
      Module.HEAPU8.subarray(newOffset, newOffset + newBytes + 1).set(Module.HEAPU8.subarray(data.offset, data.offset + data.bytes)), Module.stringToUTF8(s, newOffset + data.bytes, sBytes + 1), Module._sqlite3_free(data.offset), data.offset = newOffset, data.bytes = newBytes, strings.set(str, data);
    }, sqlite32.str_finish = function(str) {
      if (!strings.has(str))
        throw new SQLiteError("not a string", 21);
      const data = strings.get(str);
      strings.delete(str), Module._sqlite3_free(data.offset);
    }, sqlite32.str_value = function(str) {
      if (!strings.has(str))
        throw new SQLiteError("not a string", 21);
      return strings.get(str).offset;
    }, sqlite32.user_data = function(context) {
      return Module.getFunctionUserData(context);
    }, sqlite32.value = function(pValue) {
      const type = sqlite32.value_type(pValue);
      switch (type) {
        case 4:
          return sqlite32.value_blob(pValue);
        case 2:
          return sqlite32.value_double(pValue);
        case 1:
          const lo32 = sqlite32.value_int(pValue), hi32 = Module.getTempRet0();
          return cvt32x2AsSafe(lo32, hi32);
        case 5:
          return null;
        case 3:
          return sqlite32.value_text(pValue);
        default:
          throw new SQLiteError("unknown type", type);
      }
    }, sqlite32.value_blob = function() {
      const f = Module.cwrap("sqlite3_value_blob", ...decl("n:n"));
      return function(pValue) {
        const nBytes = sqlite32.value_bytes(pValue), address = f(pValue);
        return Module.HEAPU8.subarray(address, address + nBytes);
      };
    }(), sqlite32.value_bytes = function() {
      const f = Module.cwrap("sqlite3_value_bytes", ...decl("n:n"));
      return function(pValue) {
        return f(pValue);
      };
    }(), sqlite32.value_double = function() {
      const f = Module.cwrap("sqlite3_value_double", ...decl("n:n"));
      return function(pValue) {
        return f(pValue);
      };
    }(), sqlite32.value_int = function() {
      const f = Module.cwrap("sqlite3_value_int64", ...decl("n:n"));
      return function(pValue) {
        return f(pValue);
      };
    }(), sqlite32.value_int64 = function() {
      const f = Module.cwrap("sqlite3_value_int64", ...decl("n:n"));
      return function(pValue) {
        return cvt32x2ToBigInt(f(pValue), Module.getTempRet0());
      };
    }(), sqlite32.value_text = function() {
      const f = Module.cwrap("sqlite3_value_text", ...decl("n:s"));
      return function(pValue) {
        return f(pValue);
      };
    }(), sqlite32.value_type = function() {
      const f = Module.cwrap("sqlite3_value_type", ...decl("n:n"));
      return function(pValue) {
        return f(pValue);
      };
    }(), sqlite32.vfs_register = function(vfs, makeDefault) {
      return check("sqlite3_vfs_register", Module.registerVFS(vfs, makeDefault));
    }, sqlite32;
  }(wasmModule);
  sqlite3.vfs_register(new IDBBatchAtomicVFS("idb-batch-atomic", { durability: "strict" }));
  const db = await sqlite3.open_v2(fileName, 70, "idb-batch-atomic");
  for await (const pragma of pragmas)
    await sqlite3.exec(db, pragma);
  return new LowLevelWASQLiteDBAdapter(sqlite3, db);
}
class LowLevelWASQLiteDBAdapter {
  constructor(api2, db) {
    this.api = api2, this.db = db, this.queue = {}, this.stmtCache = new MRUCache(1e3, (value) => this.finalizeStatements(value));
  }
  async inTransaction(fn) {
    return this.serialize("transaction", () => this.doTransactional(() => fn(this)));
  }
  async doTransactional(fn) {
    await this.execInternal("BEGIN");
    try {
      const res = await fn();
      return await this.execInternal("COMMIT"), res;
    } catch (error) {
      throw await this.execInternal("ROLLBACK"), error;
    }
  }
  async selectObjects(sql, params) {
    return this.execInternal(sql, params);
  }
  async selectValue(sql, params) {
    const result = await this.execInternal(sql, params);
    if (result.length > 0) {
      const firstRow = ensure(result[0]), keys = Object.keys(firstRow);
      return keys.length > 0 ? firstRow[ensure(keys[0])] : void 0;
    }
  }
  async exec(sql, params) {
    return await this.execInternal(sql, params), this.api.changes(this.db);
  }
  async execInternal(sql, params) {
    return this.serialize("exec", async () => {
      const rows = [];
      for await (const { stmt, cols } of this.prepareStatements(sql)) {
        if (params) {
          await this.api.reset(stmt);
          for (let i = 0; i < params.length; i++) {
            const p = params[i];
            this.api.bind(stmt, i + 1, "boolean" == typeof p ? p ? 1 : 0 : p);
          }
        }
        for (; 100 === await this.api.step(stmt); ) {
          const obj = {};
          for (let i = 0; i < cols.length; i++)
            obj[ensure(cols[i])] = this.api.column(stmt, i);
          rows.push(obj);
        }
      }
      return rows;
    });
  }
  prepareStatements(sql) {
    return _this = this, async function* () {
      const cachedStmts = _this.stmtCache.get(sql);
      if (void 0 !== cachedStmts)
        for await (const stmt of cachedStmts)
          yield stmt;
      else {
        const statements = [];
        let stmt = 0;
        const str = _this.api.str_new(_this.db, sql);
        try {
          let prepared = { stmt: 0, sql: _this.api.str_value(str) };
          for (; prepared = await _this.api.prepare_v2(_this.db, prepared.sql); ) {
            stmt = prepared.stmt;
            const statement = { stmt, cols: _this.api.column_names(stmt) };
            statements.push(statement), yield statement, stmt = 0;
          }
          await _this.stmtCache.put(sql, statements);
        } finally {
          _this.api.str_finish(str), stmt > 0 && (await _this.api.finalize(stmt), await _this.finalizeStatements(statements));
        }
      }
    }();
    var _this;
  }
  async finalizeStatements(statements) {
    await Promise.all(statements.map(async ({ stmt }) => this.api.finalize(stmt)));
  }
  async serialize(name, fn) {
    const result = (this.queue[name] ?? Promise.resolve()).then(() => fn());
    return this.queue[name] = result.catch(() => {
    }), result;
  }
}
class MRUCache {
  constructor(maxSize, cleanUpFn) {
    this.maxSize = maxSize, this.cleanUpFn = cleanUpFn, this.counter = 0, this.size = 0, this.map = {};
  }
  get(key) {
    const entry = this.map[key];
    return void 0 !== entry && (entry.lastUsed = this.counter++), entry?.value;
  }
  async put(key, value) {
    if (this.size === this.maxSize) {
      const [k, entry] = Object.entries(this.map).reduce(([ok, ov], [ck, cv]) => ov.lastUsed < cv.lastUsed ? [ok, ov] : [ck, cv]);
      await this.cleanUpFn?.(entry.value), delete this.map[k], this.size--;
    }
    this.size++, this.map[key] = { value, lastUsed: this.counter++ };
  }
}
class ReloadHandler {
  constructor(ui, session, onReload) {
    this.ui = ui, this.session = session, this.onReload = onReload;
  }
  reloadApp(withState = false) {
    this.setPageState(withState), this.onReload();
  }
  async tryRestorePage() {
    const showNotification = ensure(showReloadNotificationHandler);
    try {
      const { cache, page, lang } = this.getPageState();
      return !!(cache && page && lang) && (mx.data.hydrateCache(cache), await this.ui.openForm2(page.name, mapValues(page.formParameters, (g) => g ?? void 0), this.getLocaleCode() === lang ? page.title : void 0, void 0, { location: "content" }), showNotification(), true);
    } catch {
      return this.showReloadError(), showNotification(), false;
    }
  }
  getLocaleCode() {
    return this.session.getConfig("locale.code");
  }
  setPageState(withState) {
    const { formParameters, customTitle, pageName } = window.history.state, state = withState ? { page: { name: pageName, formParameters: mapValues(formParameters, (g) => g ?? null), title: customTitle }, cache: mx.data.dehydrateCache(), lang: this.getLocaleCode() } : {};
    window.sessionStorage.setItem("mx.reload.modern", JSON.stringify(state));
  }
  getPageState() {
    const stateStr = window.sessionStorage.getItem("mx.reload.modern");
    return window.sessionStorage.removeItem("mx.reload.modern"), stateStr ? JSON.parse(stateStr) : {};
  }
  showReloadError() {
    const showMessageHandler2 = getShowMessageHandler();
    showMessageHandler2 && showMessageHandler2("confirmation", "An error has occurred that might have been caused by fast reload. Refresh the page to fix it.", translate("mxui.widget.DialogMessage", "error"), true, { okCaption: "Refresh page", onOk: this.onReload });
  }
}
class WebUI {
  constructor(rootElement, onError, logManager) {
    this.rootElement = rootElement, this.onError = onError, this.lockManager = ObjectLockManager.getInstance(), this.navigationLogger = logManager.getLogger(LogNode.Navigation);
  }
  async openForm2(pageId, formParameters, customTitle, currentForm, params, numberOfPagesToClose) {
    const formParameterGuids = Object.values(formParameters).filter((guid) => void 0 !== guid), release = this.lockManager.lock(formParameterGuids);
    try {
      return this.navigationLogger.debug(`Open a page with id: ${pageId} ${numberOfPagesToClose ? ` Number of pages to close: ${numberOfPagesToClose}` : ""}`), await ensure(openFormHandler)(pageId.replace(/\\|\//g, ".").replace(".page.xml", ""), formParameters, customTitle, currentForm, params, numberOfPagesToClose);
    } finally {
      release();
    }
  }
  async getPageParameters(_) {
    throw new AssertionError("getPageParameters should never be called in the React client");
  }
  reload(_callback) {
    throw new NotImplementedError("Method not implemented.");
  }
  async back() {
    await closeForm(1);
  }
  confirmation(args) {
    const { content, proceed, cancel, handler, onCancel } = args;
    this.navigationLogger.debug("Show confirmation dialog"), ensure(getShowMessageHandler())("confirmation", content, translate("mxui.widget.ConfirmationDialog", "caption"), true, { okCaption: proceed ?? translate("mxui.widget.DialogMessage", "ok"), cancelCaption: cancel ?? translate("mxui.widget.DialogMessage", "cancel"), onOk: handler, onCancel });
  }
  async showLogin(messageCode) {
    if (402 === messageCode)
      return void this.exception(translateLoginMessage("http402"));
    const session = getSession();
    if (session.isValid()) {
      const loginPageSettings = session.getConfig("uiconfig.profile.loginPageSettings");
      if (loginPageSettings?.page)
        return void await this.openForm2(loginPageSettings.page, {}, loginPageSettings.title, void 0, { location: loginPageSettings.location });
    }
    const origin = api.get("originURI");
    if (origin) {
      const options = "https:" === window.location.protocol ? { sameSite: "None", secure: true } : {};
      if (api.remove("originURI", options), messageCode) {
        const parsedUrl = queryString.parseUrl(origin);
        redirect(parsedUrl.url + "?" + queryString.stringify({ ...parsedUrl.query, messageCode }));
      } else
        redirect(origin);
    } else
      ensure(showLoginHandler)(messageCode);
  }
  downloadFile(args) {
    const obj = args.mxobject, isRemoteFileEntity = obj.metaData.isRemoteFileEntity;
    if (!obj.get2("HasContents") && !isRemoteFileEntity)
      return;
    const url = mx.data.getDocumentUrl(obj.getGuid(), isRemoteFileEntity ? "" : attributeToClientValue(obj.get2("changedDate")), false, isRemoteFileEntity ? void 0 : encodeURIComponent(attributeToClientValue(obj.get2("Name"))));
    if ("window" === args.target || function() {
      const isChromeFrame = navigator.userAgent.includes("Chrome") && void 0 !== window.externalHost, isMobileBrowser = isMobileDevice();
      return isChromeFrame || isMobileBrowser;
    }()) {
      const fileUrl = url + "&target=window";
      /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || window.navigator.standalone ? ensure(getShowMessageHandler())("confirmation", translate("mxui.widget.DialogMessage", "file_download_message"), translate("mxui.widget.DialogMessage", "file_download"), true, { okCaption: translate("mxui.widget.FileInput", "download"), cancelCaption: translate("mxui.widget.DialogMessage", "cancel"), onOk: () => openFileInWindow(fileUrl) }) : openFileInWindow(fileUrl);
    } else
      !function(url2, onError) {
        let iframe = document.querySelector("[data-file-downloader]");
        iframe || (iframe = document.createElement("iframe"), iframe.style.top = "-10px", iframe.style.height = "1px", iframe.style.position = "absolute", iframe.style.visibility = "hidden", iframe.setAttribute("data-file-downloader", "true"), document.body.appendChild(iframe)), iframe.onload = () => {
          const doc = ensure(iframe.contentDocument ?? iframe.contentWindow?.document), err = getFileError(doc);
          err && onError(err);
        }, ensure(iframe.contentWindow).location = url2;
      }(url + "&target=internal", (err) => {
        args.error ? args.error(err) : this.onError(err);
      });
    function openFileInWindow(fileUrl) {
      window.open(fileUrl, "mendix_file");
    }
  }
  showProgress(message, isModal) {
    return getShowProgressHandler()(message, isModal);
  }
  hideProgress(progressId) {
    getHideProgressHandler()(progressId);
  }
  error(msg, modal) {
    this.showMessage("error", msg, modal);
  }
  warning(msg, modal) {
    this.showMessage("warning", msg, modal);
  }
  showMessage(type, message, isModal) {
    ensure(getShowMessageHandler())(type, message, translate("mxui.widget.DialogMessage", type), isModal, { okCaption: translate("mxui.widget.DialogMessage", "ok") });
  }
  toggleSidebar() {
    throw new NotImplementedError("Method not implemented.");
  }
  includePluggableWidgetsCSS() {
    const head = ensure(document.querySelector("head")), firstCssLinkTag = head.querySelector("link[href*='.css']"), widgetsCss = document.createElement("link");
    widgetsCss.rel = "stylesheet", widgetsCss.href = getStaticResourceUrl("dist/widgets.css"), firstCssLinkTag ? head.insertBefore(widgetsCss, firstCssLinkTag) : head.appendChild(widgetsCss);
  }
  setupLocale() {
    document.documentElement.lang = getLocale().languageTag;
  }
  setDirection(dir) {
    document.body.dir = dir;
  }
  setupProfile(config) {
    const profileName = config.profile.name.toLowerCase();
    this.rootElement.classList.add(`profile-${profileName}`);
  }
  setupRoles(roles) {
    roles.forEach((role) => this.rootElement.classList.add(`role-${role.toLowerCase()}`));
  }
  setupFocusCapturing() {
    this.rootElement.setAttribute(FOCUS_CAPTURING_ATTRIBUTE, FOCUS_CAPTURING_NON_MODAL);
  }
  exception(msg) {
    this.showMessage("error", msg, true);
  }
  info(msg, modal) {
    this.showMessage("info", msg, modal);
  }
}
const logger = LogManager.get().getLogger();
function toPrettyStatistics(reachableObjectsStatistics, stat, referencedBy) {
  const result = { locks: stat.locks };
  !objectIsEmpty(stat.changes) && stat.object.isPersistable() && (result.changes = stat.changes), stat.subscriptions.length > 0 && (result.subscribedWidgets = Array.from(new Set(stat.subscriptions))), referencedBy.length > 0 && (result.referencedBy = referencedBy.map((r) => function(reachableObjectsStatistics2, guid) {
    const referredStat = reachableObjectsStatistics2.find((stat2) => stat2.object.getGuid() === guid);
    if (referredStat)
      return [prettyId(referredStat) + " (" + prettyEntity(referredStat) + ")", toPrettyStatistics(reachableObjectsStatistics2, referredStat, [])];
    const session2 = getSession();
    if (guid === session2.getUserId())
      return ["$currentUser (System.User)", {}];
    return ["$currentSession (System.Session)", {}];
  }(reachableObjectsStatistics, r)).reduce((acc, [id, res]) => (acc[id] = res, acc), {}));
  const session = getSession(), isCurrentUser = stat.object.getGuid() === session.getUserId(), toBeGarbageCollected = 0 === result.locks;
  return isCurrentUser && toBeGarbageCollected && (result.note = "Current user is always in cache"), !toBeGarbageCollected || isCurrentUser ? result : "";
}
function prettyEntity(stat) {
  return stat.object.getEntity() + (stat.object.isPersistable() ? "" : " [NPE]");
}
function prettyId(stat) {
  const status = [];
  return stat.uncommitted && status.push("new"), Object.keys(stat.changes).length > 0 && status.push("changed"), stat.guid + (status.length > 0 ? ` (${status.join(", ")})` : "");
}
window.addEventListener("keydown", (e) => {
  const key = e.key || String.fromCharCode(e.keyCode);
  e.ctrlKey && e.altKey && ("g" === key.toLowerCase() || "KeyG" === e.code) && logger.info(`State details per entity (${(/* @__PURE__ */ new Date()).toLocaleTimeString()}):`, function() {
    const reachableObjectsStatistics = getData().getObjectsStatistics().filter((stat) => null != stat.object), reachabilityGraph = function(statistics) {
      const session = getSession(), userId = session.getUserId(), sessionId = session.getSessionObjectId(), mxObjs = statistics.map((stat) => stat.object), startGuids = statistics.filter((stat) => !objectIsEmpty(stat.changes) && stat.object.isPersistable() || stat.subscriptions.length > 0).map((stat) => stat.object.getGuid());
      return buildRetainmentGraph(mxObjs, new Set(startGuids.concat([userId, sessionId])));
    }(reachableObjectsStatistics), result = {};
    return reachableObjectsStatistics.forEach((stat) => {
      const entity = prettyEntity(stat), id = prettyId(stat);
      result[entity] || (result[entity] = {}), result[entity][id] = toPrettyStatistics(reachableObjectsStatistics, stat, reachabilityGraph.neighborsOf(stat.object.getGuid())) || "Going to be garbage collected \u2020";
    }), result;
  }());
});
const loadCache = [];
let active = false;
const sessionConfig = { bundleVersion: "cacheBust", sessionStore: { get: async () => window.localStorage.session, async set(value) {
  window.localStorage.session = value;
}, async remove() {
  delete window.localStorage.session;
} } };
async function startupClient({ systemTexts, languages, registerServiceWorker: registerServiceWorkerSetting }, rootNode, logManager) {
  setSystemTexts(systemTexts), setErrorHandler(errorHandler), registerConsoleLogsListener(), logUnhandledErrors();
  const cache = new MxObjectCache(), lockManager2 = ObjectLockManager.getInstance(), session = new Session(sessionConfig.sessionStore, logManager.getLogger(LogNode.Startup), logManager.getLogger(LogNode.Auth), sessionConfig.bundleVersion, "10.21.1.64969", reload);
  setSession(session);
  const garbageCollector = new GarbageCollector(cache, session, lockManager2), appUrl = baseUrl;
  setAppUrl(appUrl);
  const ui = new WebUI(rootNode, (error) => errorHandler(error), logManager);
  setUI(ui);
  const reloadHandler = new ReloadHandler(ui, session, reload);
  let sessionData;
  window.mx = { isOffline: (entity) => session.isOffline() && !(entity && offlineData().hasOnlineSyncMode(entity)), logger: logManager.getLogger(), remoteUrl: baseUrl, session, version: "10.21.1.64969", appUrl, homeUrl, login: (username, password, onSuccessCallback, onErrorCallback) => login(session, username, password, "default", onSuccessCallback, onErrorCallback), login2: (username, password, useAuthToken, onSuccessCallback, onErrorCallback) => login(session, username, password, useAuthToken, onSuccessCallback, onErrorCallback), logout: () => session.logout().then(() => getData().clear(reload)), reload, reloadWithState: () => reloadHandler.reloadApp(true), ui, addOnLoad(callback) {
    active ? callback() : loadCache.push(callback);
  } };
  try {
    sessionData = await session.startup({ offline: isBrowserWithOfflineSupport(), referrer: (getPathFromHash() ?? "") + location.search, deviceType: isPhone() ? "Phone" : isTablet() ? "Tablet" : "Desktop", profile: getProfileFromUrl(location.search), timezoneoffset: (/* @__PURE__ */ new Date()).getTimezoneOffset(), timezoneId: Intl.DateTimeFormat().resolvedOptions().timeZone, preferredLanguages: navigator.languages, longLiveTheCookie: navigator?.standalone });
  } catch (e) {
    return void function(error, ui2) {
      if (error instanceof ServerError && error.status && 409 === error.status)
        ui2.exception(error.message);
      else if (error instanceof ConnectionError)
        ui2.exception(translatedError(error).content);
      else {
        const loginMessageCode = error instanceof ServerError && error.status && [402, 404, 403, 500, 503].includes(error.status) ? error.status : 0;
        ui2.showLogin(loginMessageCode);
      }
    }(e, ui);
  }
  if (session.getConfig("isDevModeEnabled")) {
    const devTools = new DevTools(baseUrl, logManager);
    devTools.addOnReload(() => async function() {
      const cacheKeys = (await caches.keys()).filter((k) => k.startsWith("mendix-precache"));
      for (const cacheKey of cacheKeys)
        await caches.delete(cacheKey);
    }()), devTools.addOnReload((hotReload) => reloadHandler.reloadApp(hotReload)), devTools.addOnUpdateStyling(() => function() {
      const styleNodes = document.head.querySelectorAll('link[rel="stylesheet"][href^="theme.compiled.css?"]');
      if (0 === styleNodes.length)
        return;
      const removeOldStyles = () => styleNodes.forEach((styleNode) => document.head.removeChild(styleNode)), newStyleNode = document.createElement("link");
      newStyleNode.rel = "stylesheet", newStyleNode.href = `theme.compiled.css?${Date.now()}`, newStyleNode.addEventListener("load", () => {
        requestAnimationFrame(removeOldStyles);
      }), document.head.appendChild(newStyleNode);
    }()), await devTools.connect();
  }
  const onlineDataBackend = new OnlineDataBackend(cache, lockManager2), onlineData = new OnlineData(cache, lockManager2);
  let offlineData$1, data = new Data(cache, lockManager2, onlineDataBackend, garbageCollector);
  if (session.isOffline()) {
    if (!isBrowserWithOfflineSupport())
      throw new Error("Offline functionality is not available because the app is not opened in a Secure Context (using https).");
    const { dataBackend, offlineData: createdOfflineData } = await async function(logManager2, session2, cache2, lockManager3) {
      const { buildOfflineDataBackend } = await import('./buildOfflineDataBackend-TFbsuxTd.js'), database = await async function() {
        const windowAsAny = window, database2 = new SQLiteDB(await createWASQLiteDB("mendixapp.db", { baseUrl, ...windowAsAny.wasqliteOptions ?? {} }));
        return windowAsAny.exposeDb && (windowAsAny.__internal_db_dontUse__ = database2), database2;
      }();
      injectLoggerIntoDatabase(database, logManager2);
      const { setUserScopedNamePrefix } = await Promise.resolve().then(function () { return tablePrefix; });
      logManager2.getLogger(LogNode.Auth).debug("Using scoped database and file system."), setUserScopedNamePrefix(`mx${getUserIdentifier(session2)}`);
      const relativeFilesDirectory = getSessionRelativeFilesDirectory(session2), opfsFileBackend = new LoggableFileBackend(new OpfsFileBackend(relativeFilesDirectory), logManager2);
      await async function(fileBackend, session3, logger2) {
        if (window.localStorage.getItem(USES_SCOPED_DIRECTORIES_KEY))
          return void logger2.debug("The client uses user scoped files directories.");
        const legacyDocumentsDir = "files/documents", legacyThumbnailsDir = "files/thumbnails";
        if (await fileBackend.listDir(legacyDocumentsDir).length)
          return void window.localStorage.setItem(USES_SCOPED_DIRECTORIES_KEY, "true");
        logger2.debug("Migration to user scoped files directories started.");
        const documentsDir = `${getSessionRelativeFilesDirectory(session3)}/documents`, thumbnailsDir = `${getSessionRelativeFilesDirectory(session3)}/thumbnails`, stopwatch = new Stopwatch();
        try {
          await fileBackend.moveDir(legacyDocumentsDir, documentsDir), await fileBackend.moveDir(legacyThumbnailsDir, thumbnailsDir), logger2.debug(`Migration to user scoped files directories completed in ${stopwatch.measure()} milliseconds`);
        } catch (e) {
          if (!(e instanceof DOMException && "NotFoundError" === e.name))
            throw logger2.error("Migration to user scoped files directories failed!", e), e;
        }
        window.localStorage.setItem(USES_SCOPED_DIRECTORIES_KEY, "true");
      }(opfsFileBackend, session2, logManager2.getLogger(LogNode.Auth));
      const getDocumentUrlFn = (fileName, _, isThumb) => opfsFileBackend.getFileUrl(`${relativeFilesDirectory ? `${relativeFilesDirectory}/` : ""}${isThumb ? "thumbnails" : "documents"}/${fileName}`);
      return buildOfflineDataBackend(cache2, lockManager3, database, ensure(session2.getOfflineConfig()), opfsFileBackend, logManager2, getDocumentUrlFn, function() {
        try {
          return window.openDatabase?.("MendixDatabase", "1", "Mendix Database", 10485760);
        } catch {
          return;
        }
      }());
    }(logManager, session, cache, lockManager2);
    offlineData$1 = createdOfflineData, data = new Data(cache, lockManager2, onlineDataBackend, garbageCollector, dataBackend);
  }
  setData(data), window.mx.data = data, data.startup(), initializeCore(session.getConfig(), languages, session.getConfig("microflows"), onlineData, offlineData$1);
  await reloadHandler.tryRestorePage() || await handleRuntimeSuccess(cache, lockManager2, session.getConfig(), { autoRelease: true });
  const uiconfig = session.getConfig("uiconfig");
  ui.setupLocale(), ui.setupProfile(uiconfig), ui.setupRoles(session.getUserRoleNames()), ui.setDirection(uiconfig.direction), ui.setupFocusCapturing();
  if (session.getConfig("uiconfig.pluginWidgets").length > 0 && ui.includePluggableWidgetsCSS(), initialize(), session.isOffline()) {
    const progressId = ui.showProgress(void 0, true);
    try {
      const cachedSessionData = await session.loadCachedSessionData(), dbModelCheckResult = shouldTriggerFullSyncOrDatabaseUpdate(cachedSessionData, sessionData);
      logManager.getLogger("Startup").debug(` The app will ${dbModelCheckResult.shouldSync ? "" : "not "}perform a startup sync.`);
      const cachedOfflineMetadata = session.getOfflineMetadata(), dbOfflineMetadata = await ensure(offlineData$1).retrieveOfflineMetadata();
      await handleOfflineStartup(dbModelCheckResult, cachedOfflineMetadata, dbOfflineMetadata, logManager.getLogger("Startup"));
    } finally {
      ui.hideProgress(progressId);
    }
    await session.saveSessionData();
  }
  for (!function(registerServiceWorkerSetting2, session2) {
    registerServiceWorkerSetting2 && isBrowserWithServiceWorkerSupport() && null != session2.getConfig("uiconfig.profile.progressiveWebApp") && (!function({ offline, precaching, profileKind, languageCode, isReactClient }) {
      const url = new URL(mx.appUrl);
      url.pathname += "service-worker.js", offline && url.searchParams.set("offline", "true"), precaching && url.searchParams.set("precaching", "true"), isReactClient && url.searchParams.set("isReactClient", "true"), url.searchParams.set("profileKind", encodeURIComponent(profileKind)), url.searchParams.set("languageCode", encodeURIComponent(languageCode)), navigator.serviceWorker.register(url.toString()).catch((e) => handleError(e));
    }({ offline: session2.isOffline(), precaching: session2.getConfig("uiconfig.profile.progressiveWebApp.precaching"), profileKind: session2.getConfig("uiconfig.profile.kind"), languageCode: session2.getConfig("locale.code"), isReactClient: true }), false === session2.getConfig("uiconfig.profile.progressiveWebApp.installPrompt") && window.addEventListener("beforeinstallprompt", (event) => {
      event.preventDefault();
    }));
  }(registerServiceWorkerSetting, session), getData().update = function(args) {
    publish(args).then(args.callback).catch((e) => window.mx.onError(e));
  }, Object.defineProperty(getUI(), "modulePath", { get() {
    throw new Error("'modulePath' is not supported in modern client");
  } }), window.mx.parser = new Parser(), getUI().getTemplate = function() {
    throw new Error("'getTemplate' is not supported in modern client");
  }, active = true; loadCache.length > 0; )
    loadCache.shift()?.();
  return session;
}
function getUserIdentifier(session) {
  return session.isGuest() ? "anonymous" : session.getUserId();
}
function getSessionRelativeFilesDirectory(session) {
  return `files/app/${getUserIdentifier(session)}`;
}
const USES_SCOPED_DIRECTORIES_KEY = "usesScopedDirectories";
function login(session, username, password, useAuthToken, onSuccessCallback, onErrorCallback) {
  session.login({ username, password, useAuthToken }).then(() => {
    onSuccessCallback?.();
    const urlParams = new URLSearchParams(location.search);
    if (urlParams.has("c")) {
      const url = new URL(location.href);
      return url.pathname = decodeURIComponent(urlParams.get("c")), urlParams.delete("c"), url.search = urlParams.toString(), void (location.href = url.toString());
    }
    reload();
  }).catch((e) => onErrorCallback?.(e));
}
const App = ({ applicationConfig, rootNode }) => {
  const [session, setSession2] = reactExports.useState(void 0), [popupsOverlay, setPopUpsOverlay] = reactExports.useState({ hasModal: false, zIndex: 0 }), [messagesOverlay, setMessagesOverlay] = reactExports.useState({ hasModal: false, zIndex: 0 }), logManager = LogManager.get();
  reactExports.useEffect(() => {
    logManager.setLogFilter(defaultLogFilter);
    const progressHandlerId = getShowProgressHandler()(void 0, void 0, 500);
    (async () => {
      const newSession = await startupClient(applicationConfig, rootNode, logManager);
      newSession && setSession2(newSession);
    })().catch(handleError).finally(() => {
      progressHandlerId && getHideProgressHandler()(progressHandlerId);
    });
  }, [applicationConfig, logManager, rootNode]);
  const applicationTitle = session?.getConfig("uiconfig.profile.title") ?? "Mendix", demoUsers = session?.getConfig("demoUsers"), activeDemoUser = session?.getUserObject().get2("Name"), overlayIsVisible = popupsOverlay.hasModal || messagesOverlay.hasModal;
  return jsxRuntimeExports.jsxs(ErrorBoundary, { children: [overlayIsVisible && jsxRuntimeExports.jsx(Overlay, { zIndex: Math.max(popupsOverlay.zIndex, messagesOverlay.zIndex) }), jsxRuntimeExports.jsx(Router, { constants: applicationConfig.constants, applicationTitle, onUpdateOverlay: (hasModal, zIndex) => setPopUpsOverlay({ hasModal, zIndex }) }), jsxRuntimeExports.jsx(Messages, { onUpdateOverlay: (hasModal, zIndex) => setMessagesOverlay({ hasModal, zIndex }), overlayIsVisible }), jsxRuntimeExports.jsx(ReloadNotification, {}), demoUsers && jsxRuntimeExports.jsx(DemoUserSwitcher, { activeDemoUser, demoUsers, onSelectUser: async (user) => {
    await session?.logout(), await session?.login({ username: user.name, password: user.password }), reload();
  } })] });
}, startApp = async (applicationConfig) => {
  setupBaseTag();
  const rootNode = ensure(document.getElementById("root"));
  createRoot(rootNode).render(jsxRuntimeExports.jsx(App, { applicationConfig, rootNode }));
};
configure({ reactionScheduler: reactDomExports.unstable_batchedUpdates });

export { Access, ActionContext, AssertionError, Big, ConnectionError, DB_COUNTER_KEY, DB_META_TABLE, DB_VALUE_COLUMN, DayOfWeek, DescribedError, FormatterType, Fragment, GUID_COLUMN, HandledError, LogManager, LogNode, METADATA_TABLE, MxObject, NestedStoreProvider, OfflineToRuntimeGuidMapping, PlaceholderProperty, RuntimeToOfflineGuidMapping, SYNC_ID_COLUMN, Stopwatch, SynchronizationError, SystemAttribute, ValidationError, WidgetIdContext, _DataBackend, action, actionMatcher, addDays, addEnumerations, addMonths, addYears, allowStateChangesInsideComputed, and, asDynamicValue$, asPluginWidgets, asProperty, asReloadable$, asResult, assertIsAttributeValue, assertIsBoolean, assertIsNonEnumValue, assertIsPositiveInteger, assertValidFilterCondition$1 as assertValidFilterCondition, association, attribute, attributeToClientValue, attributeValueToActionArgument, available, cancelChanges, classNames, clearDirtyGuids, clone, commonjsGlobal$1 as commonjsGlobal, comparer, configure, contains, crash, createChange, createChangeFromIncompatibleObjectsJson, createCheckTableExistSqlQuery, createGetDbMetaValue, createGuids, createMemoizedCache, createMendixGuid, createMxObjectJSON, createOfflineGuid, createRetryMiddlewarePredicate, createUpdateCounterValue, dayEquals, dayGreaterThan, dayGreaterThanOrEqual, dayLessThan, dayLessThanOrEqual, dayNotEqual, deepEqual, delocalizeDate, dependOnSubscription, deriveEntity, dynAvailable, dynUnavailable, empty, endsWith, ensure, ensureAssociationId, ensureAttributeId, equalFilterCondition, equals, evaluateActionExpression, evaluateExpressionValue, evaluateFormExpression, executeAsync, executeNoImpactInstructions, expressionVariableToRuntimeArgument, filterValues, flatMapL, formatDate$1 as formatDate, formatNumber, formatValue, fromComputation$, fromComputationWithDeepEquality$, fromConstant$, fromMutableComputation$, fromMxSubscription$, fromObjectItem, fromRequest$, fromTimer$, gatherUpdates, getActionArguments$, getAssociationInfoById, getAssociationStep, getAssociationTypeById, getAttribute$, getAttributeEnumerationType, getAttributeInfoById, getAttributeType$1 as getAttributeType, getAttributeTypeById, getAugmentedNamespace, getByGuid, getByGuids, getCachedObjectsByPath, getData, getDateFormatPlaceholder, getDefaultExportFromCjs, getDefaultExportFromCjs$1, getEntityAssociationsPairs, getEntityMeta, getEnumerationOptions, getFocus, getFocusableContainer, getFormExpressionResult$, getFormExpressionResultFromStore$, getGuidsFromRuntimeArguments, getHTMLElement, getImplicitMicroflowParameters, getLocale, getNanoflowArguments$, getObjectByPath$, getObjectsByPath$, getOrCrashL, getOrElseL, getPreviousValue$, getRefsObjects, getRemoteDynamicResourceUrl, getRequestDataForMicroflow, getRuntimeGuid, getSession, getStaticResourceUrl, getSubscribedObject$, getSubscribedObjectState$, getUI, getUserScopedNamePrefix, getVariableFromStore$, greaterThan, greaterThanOrEqual, handleError, handleRuntimeSuccessResponse, handleValidations, indexByKey, indexMxObjectJsonsByGuid, indexMxObjectsByGuid, isAttributeExpression, isDataSourceValid, isDirtyGuid, isFileDocument, isFileDocumentWithContentNonMetaCheck, isFileDocumentWithContents, isHTMLElement, isImage, isJson, isMobileDevice, isNavigableElement, isObjectItem, isObjectItemArray, isReferenceType, isRuntimeGuid, isStoreVariableSource, isUnlocalizedDateAttribute, jsxRuntimeExports, lessThan, lessThanOrEqual, literal, loading, mapL, mapObject, mapValues, markAsDirty, memoizeConcurrent, methodToPromise, n, nanoflowEngine, newId, notEqual, objectFromArray, offlineData, onlineData, or, pageScope, parseDate, parseNumber, partition, partitionValues, publish, reactDomExports, reactExports, reaction, readUntracked, registerAssociationType, registerAttributeType, registerFilterAttribute, registerMiddleware, repeat, requiredArgs, retrieveByIds, retrieveByXPath$1 as retrieveByXPath, runInAction, runInSynchronizationLock, runSideEffect, runtimeOperation, runtimeValueToExpressionVariable, scheduleSideEffect, selectTranslation, startApp, startOfDay, startsWith, subDays, subMonths, subYears, subtract, syncedObjsRuntimeToOfflineMap, synchronizeObjects, t, toDate, toFriendlyId, toInteger, toNanoflowArguments, toNumber, toObjectItem, toQueryFilter, toRuntimeArgument, toRuntimeArguments, toUserScopedName, toXpathConstraint, translate, translateEnumeration, tuple, unavailable, unique, uniqueBy, unmarkAsDirty, upload, useDependableValue, useDependency, useEnsureConstantValues, useForceUpdate, useIsFirstRender, useOwnStoreBackendSlot, useStoreBackendValue, useValue, validate, validation, wait, withFormSuspension$, withObjectKeeping$, withSideEffect$ };
